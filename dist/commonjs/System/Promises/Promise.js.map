{"version":3,"sources":["System/Promises/Promise.js","System/Promises/Promise.ts"],"names":[],"mappings":"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","file":"System/Promises/Promise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n * Although most of the following code is written from scratch, it is\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\n */\n\"use strict\";\nconst Types_1 = require(\"../Types\");\nconst deferImmediate_1 = require(\"../Tasks/deferImmediate\");\nconst defer_1 = require(\"../Tasks/defer\");\nconst DisposableBase_1 = require(\"../Disposable/DisposableBase\");\nconst InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\nconst ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nconst ObjectPool_1 = require(\"../Disposable/ObjectPool\");\nconst Set_1 = require(\"../Collections/Set\");\nconst VOID0 = void 0, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\nfunction isPromise(value) {\n    return Types_1.default.hasMemberOfType(value, THEN, Types_1.default.FUNCTION);\n}\nfunction resolve(value, resolver, promiseFactory) {\n    let nextValue = resolver\n        ? resolver(value)\n        : value;\n    return nextValue && isPromise(nextValue)\n        ? Promise.wrap(nextValue)\n        : promiseFactory(nextValue);\n}\nfunction pass(source, dest) {\n    return () => {\n        source.then(v => {\n            dest.resolve(v);\n            return dest;\n        }, e => {\n            dest.reject(e);\n            return dest;\n        });\n    };\n}\nfunction handleResolution(p, value, resolver) {\n    try {\n        let v = resolver ? resolver(value) : value;\n        if (p)\n            p.resolve(v);\n    }\n    catch (ex) {\n        p.reject(ex);\n    }\n}\nfunction handleDispatch(p, onFulfilled, onRejected) {\n    if (p instanceof Promise)\n        p.thenThis(onFulfilled, onRejected);\n    else\n        p.then(onFulfilled, onRejected);\n}\nclass PromiseState extends DisposableBase_1.DisposableBase {\n    constructor(_state, _result, _error) {\n        super();\n        this._state = _state;\n        this._result = _result;\n        this._error = _error;\n        this._disposableObjectName = PROMISE_STATE;\n    }\n    _onDispose() {\n        this._state = VOID0;\n        this._result = VOID0;\n        this._error = VOID0;\n    }\n    getState() {\n        return this._state;\n    }\n    get state() {\n        return this._state;\n    }\n    get isPending() {\n        return this.getState() === Promise.State.Pending;\n    }\n    get isSettled() {\n        return this.getState() != Promise.State.Pending;\n    }\n    get isFulfilled() {\n        return this.getState() === Promise.State.Fulfilled;\n    }\n    get isRejected() {\n        return this.getState() === Promise.State.Rejected;\n    }\n    getResult() {\n        return this._result;\n    }\n    get result() {\n        this.throwIfDisposed();\n        return this.getResult();\n    }\n    getError() {\n        return this._error;\n    }\n    get error() {\n        this.throwIfDisposed();\n        return this.getError();\n    }\n}\nexports.PromiseState = PromiseState;\nclass PromiseBase extends PromiseState {\n    constructor() {\n        super(Promise.State.Pending);\n        this._disposableObjectName = PROMISE;\n    }\n    deferAll() {\n        this.throwIfDisposed();\n        return new SubsequentDeferred(this);\n    }\n    defer() {\n        this.throwIfDisposed();\n        var p = Promise.pending();\n        deferImmediate_1.deferImmediate(pass(this, p));\n        return p;\n    }\n    delay(milliseconds) {\n        this.throwIfDisposed();\n        var p = Promise.pending();\n        defer_1.defer(pass(this, p), milliseconds);\n        return p;\n    }\n    'catch'(onRejected) {\n        this.throwIfDisposed();\n        return this.then(VOID0, onRejected);\n    }\n    'finally'(fin) {\n        this.throwIfDisposed();\n        return this.then(fin, fin);\n    }\n    finallyThis(fin) {\n        this.thenThis(fin, fin);\n        return this;\n    }\n}\nexports.PromiseBase = PromiseBase;\nclass Resolvable extends PromiseBase {\n    then(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        try {\n            switch (this.state) {\n                case Promise.State.Fulfilled:\n                    return onFulfilled\n                        ? resolve(this._result, onFulfilled, Promise.resolve)\n                        : this;\n                case Promise.State.Rejected:\n                    return onRejected\n                        ? resolve(this._error, onRejected, Promise.resolve)\n                        : this;\n            }\n        }\n        catch (ex) {\n            return new Rejected(ex);\n        }\n        throw new Error(\"Invalid state for a resolved promise.\");\n    }\n    thenThis(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        switch (this.state) {\n            case Promise.State.Fulfilled:\n                if (onFulfilled)\n                    onFulfilled(this._result);\n                break;\n            case Promise.State.Rejected:\n                if (onRejected)\n                    onRejected(this._error);\n                break;\n        }\n        return this;\n    }\n}\nexports.Resolvable = Resolvable;\nclass Resolved extends Resolvable {\n    constructor(state, result, error) {\n        super();\n        this._result = result;\n        this._error = error;\n        this._state = state;\n    }\n}\nexports.Resolved = Resolved;\nclass Fulfilled extends Resolved {\n    constructor(value) {\n        super(Promise.State.Fulfilled, value);\n    }\n}\nclass Rejected extends Resolved {\n    constructor(error) {\n        super(Promise.State.Rejected, VOID0, error);\n    }\n}\nclass PromiseWrapper extends Resolvable {\n    constructor(_target) {\n        super();\n        this._target = _target;\n        if (!_target)\n            throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n        if (!isPromise(_target))\n            throw new ArgumentException_1.ArgumentException(TARGET, \"Must be a promise-like object.\");\n        _target.then(v => {\n            this._state = Promise.State.Fulfilled;\n            this._result = v;\n            this._error = VOID0;\n            this._target = VOID0;\n        }, e => {\n            this._state = Promise.State.Rejected;\n            this._error = e;\n            this._target = VOID0;\n        });\n    }\n    then(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        var t = this._target;\n        if (!t)\n            return super.then(onFulfilled, onRejected);\n        var p = Promise.pending();\n        handleDispatch(t, result => handleResolution(p, result, onFulfilled), error => onRejected ? handleResolution(p, error, onRejected) : p.reject(error));\n        return p;\n    }\n    thenThis(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        var t = this._target;\n        if (!t)\n            return super.thenThis(onFulfilled, onRejected);\n        handleDispatch(t, onFulfilled, onRejected);\n        return this;\n    }\n    _onDispose() {\n        super._onDispose();\n        this._target = VOID0;\n    }\n}\nclass Promise extends Resolvable {\n    constructor(resolver, resolveImmediate = false) {\n        super();\n        if (resolver)\n            this.resolveUsing(resolver, !resolveImmediate);\n    }\n    then(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        if (this._state)\n            return super.then(onFulfilled, onRejected);\n        var p = new Promise();\n        (this._waiting || (this._waiting = []))\n            .push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\n        return p;\n    }\n    thenThis(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        if (this._state)\n            return super.thenThis(onFulfilled, onRejected);\n        (this._waiting || (this._waiting = []))\n            .push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\n        return this;\n    }\n    _onDispose() {\n        super._onDispose();\n        this._resolvedCalled = VOID0;\n    }\n    resolveUsing(resolver, deferResolution = false, throwIfSettled = false) {\n        if (!resolver)\n            throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n        if (this._resolvedCalled)\n            throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n        if (this.state)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\n        this._resolvedCalled = true;\n        var rejectHandler = (reason) => {\n            this._resolvedCalled = false;\n            this.reject(reason);\n        };\n        var fulfillHandler = (v) => {\n            this._resolvedCalled = false;\n            this.resolve(v);\n        };\n        var r = () => resolver(v => {\n            if (v == this)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n            if (isPromise(v))\n                handleDispatch(v, fulfillHandler, rejectHandler);\n            else\n                fulfillHandler(v);\n        }, rejectHandler);\n        if (deferResolution)\n            deferImmediate_1.deferImmediate(r);\n        else\n            r();\n    }\n    resolve(result, throwIfSettled = false) {\n        this.throwIfDisposed();\n        if (result == this)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n        if (this._state) {\n            if (!throwIfSettled || this._state == Promise.State.Fulfilled && this._result === result)\n                return;\n            throw new InvalidOperationException_1.InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\n        }\n        if (this._resolvedCalled) {\n            if (throwIfSettled)\n                throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n            return;\n        }\n        this._state = Promise.State.Fulfilled;\n        this._result = result;\n        this._error = VOID0;\n        var o = this._waiting;\n        if (o) {\n            this._waiting = VOID0;\n            for (let c of o) {\n                let { onFulfilled, promise } = c, p = promise;\n                pools.PromiseCallbacks.recycle(c);\n                handleResolution(p, result, onFulfilled);\n            }\n            o.length = 0;\n        }\n    }\n    reject(error, throwIfSettled = false) {\n        this.throwIfDisposed();\n        if (this._state) {\n            if (!throwIfSettled || this._state == Promise.State.Rejected && this._error === error)\n                return;\n            throw new InvalidOperationException_1.InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\n        }\n        if (this._resolvedCalled) {\n            if (throwIfSettled)\n                throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n            return;\n        }\n        this._state = Promise.State.Rejected;\n        this._error = error;\n        var o = this._waiting;\n        if (o) {\n            this._waiting = null;\n            for (let c of o) {\n                let { onRejected, promise } = c, p = promise;\n                pools.PromiseCallbacks.recycle(c);\n                if (onRejected)\n                    handleResolution(p, error, onRejected);\n                else\n                    p.reject(error);\n            }\n            o.length = 0;\n        }\n    }\n}\nexports.Promise = Promise;\nclass SubsequentDeferred extends PromiseBase {\n    constructor(_parent) {\n        super();\n        this._parent = _parent;\n        if (!_parent || !(_parent instanceof PromiseBase))\n            throw new ArgumentException_1.ArgumentException(TARGET, \"Must be of type Promise.\");\n    }\n    _onDisposed() {\n        super._onDispose();\n        this._parent = VOID0;\n    }\n    getState() {\n        return this._parent.state;\n    }\n    getResult() {\n        return this._parent.result;\n    }\n    getError() {\n        return this._parent.error;\n    }\n    then(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        var d = this._parent.defer();\n        var p = d.then(onFulfilled, onRejected);\n        d.finally(() => pools.recycle(d));\n        return p;\n    }\n    thenThis(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        var d = this._parent.defer();\n        d.thenThis(onFulfilled, onRejected);\n        d.finally(() => pools.recycle(d));\n        return this;\n    }\n    defer() {\n        this.throwIfDisposed();\n        return this;\n    }\n    deferAll() {\n        this.throwIfDisposed();\n        return this;\n    }\n    get parent() {\n        return this._parent;\n    }\n}\nclass LazyResolved extends Resolved {\n    constructor(_factory) {\n        super(Promise.State.Pending, VOID0);\n        this._factory = _factory;\n        if (!_factory)\n            throw new ArgumentNullException_1.ArgumentNullException(\"factory\");\n    }\n    _onDispose() {\n        super._onDispose();\n        this._factory = VOID0;\n    }\n    getState() {\n        this.getResult();\n        return this._state;\n    }\n    getResult() {\n        if (!this._state) {\n            try {\n                this._result = this._factory();\n                this._state = Promise.State.Fulfilled;\n            }\n            catch (ex) {\n                this._error = ex;\n                this._state = Promise.State.Rejected;\n            }\n            this._factory = VOID0;\n        }\n        return this._result;\n    }\n    getError() {\n        this.getResult();\n        return this._error;\n    }\n    then(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        this.getResult();\n        return super.then(onFulfilled, onRejected);\n    }\n    thenThis(onFulfilled, onRejected) {\n        this.throwIfDisposed();\n        this.getResult();\n        return super.thenThis(onFulfilled, onRejected);\n    }\n    resolve() {\n        this.getResult();\n        return this;\n    }\n    get isResolved() {\n        return !this._factory;\n    }\n}\nexports.LazyResolved = LazyResolved;\nclass LazyPromise extends Promise {\n    constructor(_resolver) {\n        super();\n        this._resolver = _resolver;\n        if (!_resolver)\n            throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n        this._resolvedCalled = true;\n    }\n    _onDispose() {\n        super._onDispose();\n        this._resolver = VOID0;\n    }\n    _onThen() {\n        var r = this._resolver;\n        if (r) {\n            this._resolver = VOID0;\n            this._resolvedCalled = false;\n            this.resolveUsing(r, true);\n        }\n    }\n    then(onFulfilled, onRejected) {\n        this._onThen();\n        return super.then(onFulfilled, onRejected);\n    }\n    thenThis(onFulfilled, onRejected) {\n        this._onThen();\n        return super.thenThis(onFulfilled, onRejected);\n    }\n}\nexports.LazyPromise = LazyPromise;\nvar pools;\n(function (pools) {\n    var pending;\n    (function (pending) {\n        var pool;\n        function getPool() {\n            return pool || (pool = new ObjectPool_1.ObjectPool(40, factory));\n        }\n        function factory() {\n            return new Promise();\n        }\n        function get() {\n            var p = getPool().take();\n            p.__wasDisposed = false;\n            p._state = Promise.State.Pending;\n            return p;\n        }\n        pending.get = get;\n        function recycle(c) {\n            if (!c)\n                return;\n            c.dispose();\n            getPool().add(c);\n        }\n        pending.recycle = recycle;\n    })(pending = pools.pending || (pools.pending = {}));\n    function recycle(c) {\n        if (!c)\n            return;\n        if (c instanceof Promise)\n            pending.recycle(c);\n        else\n            c.dispose();\n    }\n    pools.recycle = recycle;\n    var PromiseCallbacks;\n    (function (PromiseCallbacks) {\n        var pool;\n        function getPool() {\n            return pool || (pool = new ObjectPool_1.ObjectPool(40, factory));\n        }\n        function factory() {\n            return {\n                onFulfilled: null,\n                onRejected: null,\n                promise: null\n            };\n        }\n        function init(onFulfilled, onRejected, promise) {\n            var c = getPool().take();\n            c.onFulfilled = onFulfilled;\n            c.onRejected = onRejected;\n            c.promise = promise;\n            return c;\n        }\n        PromiseCallbacks.init = init;\n        function recycle(c) {\n            c.onFulfilled = null;\n            c.onRejected = null;\n            c.promise = null;\n            getPool().add(c);\n        }\n        PromiseCallbacks.recycle = recycle;\n    })(PromiseCallbacks = pools.PromiseCallbacks || (pools.PromiseCallbacks = {}));\n})(pools || (pools = {}));\n(function (Promise) {\n    (function (State) {\n        State[State[\"Pending\"] = 0] = \"Pending\";\n        State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n        State[State[\"Rejected\"] = -1] = \"Rejected\";\n    })(Promise.State || (Promise.State = {}));\n    var State = Promise.State;\n    Object.freeze(State);\n    function all(first, ...rest) {\n        if (!first && !rest.length)\n            throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n        var promises = (Array.isArray(first) ? first : [first]).concat(rest);\n        if (!promises.length || promises.every(v => !v))\n            return new Fulfilled(promises);\n        var len = promises.length;\n        for (let i = 0; i < len; i++) {\n            var p = promises[i];\n            if (p instanceof SubsequentDeferred)\n                promises[i] = p.parent;\n        }\n        return pending((resolve, reject) => {\n            let checkedAll = false;\n            let result = [];\n            result.length = len;\n            let remaining = new Set_1.Set(promises.map((v, i) => i));\n            let cleanup = () => {\n                reject = null;\n                resolve = null;\n                promises.length = 0;\n                promises = null;\n                remaining.dispose();\n                remaining = null;\n            };\n            let checkIfShouldResolve = () => {\n                let r = resolve;\n                if (r && !remaining.count) {\n                    cleanup();\n                    r(result);\n                }\n            };\n            let onFulfill = (v, i) => {\n                if (resolve) {\n                    result[i] = v;\n                    remaining.remove(i);\n                    checkIfShouldResolve();\n                }\n            };\n            let onReject = (e) => {\n                let r = reject;\n                if (r) {\n                    cleanup();\n                    r(e);\n                }\n            };\n            for (let i = 0; remaining && i < len; i++) {\n                let p = promises[i];\n                if (p)\n                    p.then(v => onFulfill(v, i), onReject);\n                else\n                    remaining.remove(i);\n                checkIfShouldResolve();\n            }\n        });\n    }\n    Promise.all = all;\n    function race(first, ...rest) {\n        var promises = first && (Array.isArray(first) ? first : [first]).concat(rest);\n        if (!promises || !promises.length || !(promises = promises.filter(v => v != null)).length)\n            throw new ArgumentException_1.ArgumentException(\"Nothing to wait for.\");\n        var len = promises.length;\n        if (len == 1)\n            return wrap(promises[0]).defer();\n        for (let i = 0; i < len; i++) {\n            var p = promises[i];\n            if (p instanceof SubsequentDeferred)\n                p = p.parent;\n            if (p instanceof LazyResolved) {\n                if (p.isResolved)\n                    return p.defer();\n            }\n            else if (p instanceof Resolved || p instanceof PromiseBase && p.isSettled) {\n                return p.defer();\n            }\n        }\n        return pending((resolve, reject) => {\n            let cleanup = () => {\n                reject = null;\n                resolve = null;\n                promises.length = 0;\n                promises = null;\n            };\n            let onResolve = (r, v) => {\n                if (r) {\n                    cleanup();\n                    r(v);\n                }\n            };\n            let onFulfill = (v) => onResolve(resolve, v);\n            let onReject = (e) => onResolve(reject, e);\n            for (let p of promises) {\n                if (!resolve)\n                    break;\n                p.then(onFulfill, onReject);\n            }\n        });\n    }\n    Promise.race = race;\n    function resolve(value) {\n        return isPromise(value) ? wrap(value) : new Fulfilled(value);\n    }\n    Promise.resolve = resolve;\n    function reject(reason) {\n        return new Rejected(reason);\n    }\n    Promise.reject = reject;\n    var lazy;\n    (function (lazy) {\n        function resolve(factory) {\n            return new LazyResolved(factory);\n        }\n        lazy.resolve = resolve;\n        function pending(resolver) {\n            return new LazyPromise(resolver);\n        }\n        lazy.pending = pending;\n    })(lazy = Promise.lazy || (Promise.lazy = {}));\n    function wrap(target) {\n        if (!target)\n            throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n        return target instanceof Promise ? this : new PromiseWrapper(target);\n    }\n    Promise.wrap = wrap;\n    function createFrom(then) {\n        if (!then)\n            throw new ArgumentNullException_1.ArgumentNullException(THEN);\n        return new PromiseWrapper({ then: then });\n    }\n    Promise.createFrom = createFrom;\n    function pending(resolver) {\n        var p = pools.pending.get();\n        if (resolver)\n            p.resolveUsing(resolver);\n        return p;\n    }\n    Promise.pending = pending;\n})(Promise = exports.Promise || (exports.Promise = {}));\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n * Although most of the following code is written from scratch, it is\r\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\r\n */\r\n\r\n/*\r\n * Note: The Promise herein does NOT defer by default.\r\n * If you require a promise to defer its result then use the .defer() or .delay(ms) methods.\r\n * The API attempts to follow ES6 style promises.\r\n */\r\n\r\nimport Type from \"../Types\";\r\nimport {Closure, Func} from \"../FunctionTypes\";\r\nimport {deferImmediate} from \"../Tasks/deferImmediate\";\r\nimport {defer} from \"../Tasks/defer\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\nimport {Set} from \"../Collections/Set\";\r\n\r\n\r\nconst VOID0:any = void 0, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\r\n\r\nfunction isPromise<T>(value:any):value is PromiseLike<T>\r\n{\r\n\treturn Type.hasMemberOfType(value, THEN, Type.FUNCTION);\r\n}\r\n\r\nfunction resolve<T>(\r\n\tvalue:Promise.Resolution<T>, resolver:(v:Promise.Resolution<T>)=>any,\r\n\tpromiseFactory:(v:any)=>PromiseBase<any>):PromiseBase<any>\r\n{\r\n\tlet nextValue = resolver\r\n\t\t? resolver(value)\r\n\t\t: value;\r\n\r\n\treturn nextValue && isPromise(nextValue)\r\n\t\t? Promise.wrap(nextValue)\r\n\t\t: promiseFactory(nextValue);\r\n}\r\n\r\nfunction pass<T>(source:PromiseBase<T>, dest:Promise<T>):Closure\r\n{\r\n\treturn ()=>\r\n\t{\r\n\t\tsource.then(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tdest.resolve(v);\r\n\t\t\t\treturn dest;\r\n\t\t\t},\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tdest.reject(e);\r\n\t\t\t\treturn dest;\r\n\t\t\t});\r\n\t}\r\n}\r\n\r\nfunction handleResolution(\r\n\tp:Promise<any>,\r\n\tvalue:Promise.Resolution<any>,\r\n\tresolver?:(v:Promise.Resolution<any>)=>any):void\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(p) p.resolve(v);\r\n\t}\r\n\tcatch(ex)\r\n\t{ p.reject(ex); }\r\n}\r\n\r\nfunction handleDispatch<T,TResult>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\tonRejected?:Promise.Reject<TResult>):void\r\n{\r\n\tif(p instanceof Promise)\r\n\t\tp.thenThis(onFulfilled, onRejected);\r\n\telse\r\n\t\tp.then(<any>onFulfilled, onRejected);\r\n}\r\n\r\nexport class PromiseState<T>\r\nextends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tprotected _state:Promise.State,\r\n\t\tprotected _result?:T,\r\n\t\tprotected _error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = PROMISE_STATE;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._state = VOID0;\r\n\t\tthis._result = VOID0;\r\n\t\tthis._error = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget state():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget isPending():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Pending;\r\n\t}\r\n\r\n\tget isSettled():boolean\r\n\t{\r\n\t\treturn this.getState()!=Promise.State.Pending; // Will also include undefined==0 aka disposed!=resolved.\r\n\t}\r\n\r\n\tget isFulfilled():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Fulfilled;\r\n\t}\r\n\r\n\tget isRejected():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Rejected;\r\n\t}\r\n\r\n\t/*\r\n\t * Providing overrides allows for special defer or lazy sub classes.\r\n\t */\r\n\tprotected getResult():T\r\n\t{\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tget result():T\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getResult();\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class PromiseBase<T>\r\nextends PromiseState<T> implements PromiseLike<T>\r\n{\r\n\tconstructor()\r\n\t{\r\n\t\tsuper(Promise.State.Pending);\r\n\t\tthis._disposableObjectName = PROMISE;\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the respective handlers once the promise is resolved.\r\n\t * For simplicity and performance this can happen synchronously unless you call .defer() before calling .then().\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract then<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>;\r\n\r\n\r\n\t/**\r\n\t * Same as then but does not return the result.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * Errors are not trapped.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>;\r\n\r\n\t/**\r\n\t * Ensures all subsequent then requests are resolved asynchronously.\r\n\t * @returns A promise that defers all subsequent then requests..\r\n\t */\r\n\tdeferAll():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new SubsequentDeferred(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Ensures any immediately following then requests will occur on next cycle or later.\r\n\t * @returns A promise that yields to the current execution and executes after.\r\n\t */\r\n\tdefer():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar p = Promise.pending<T>();\r\n\t\tdeferImmediate(pass(this, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tdelay(milliseconds?:number):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar p = Promise.pending<T>();\r\n\t\tdefer(pass(this, p), milliseconds);\r\n\t\treturn p;\r\n\t}\r\n\r\n\t'catch'<TResult>(onRejected:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this.then(VOID0, onRejected)\r\n\t}\r\n\r\n\t'finally'<TResult>(fin:()=>Promise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this.then(fin, fin);\r\n\t}\r\n\r\n\tfinallyThis(fin:()=>void):PromiseBase<T>\r\n\t{\r\n\t\tthis.thenThis(fin, fin);\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class Resolvable<T> extends PromiseBase<T>\r\n{\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tswitch(this.state)\r\n\t\t\t{\r\n\t\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\t\treturn onFulfilled\r\n\t\t\t\t\t\t? resolve(this._result, onFulfilled, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this; // Provided for catch cases.\r\n\t\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\t\treturn onRejected\r\n\t\t\t\t\t\t? resolve(this._error, onRejected, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn new Rejected<any>(ex);\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Invalid state for a resolved promise.\");\r\n\t}\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tswitch(this.state)\r\n\t\t{\r\n\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\tif(onFulfilled) onFulfilled(this._result);\r\n\t\t\t\tbreak;\r\n\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\tif(onRejected) onRejected(this._error);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The simplest usable version of a promise which returns synchronously the resolved state provided.\r\n */\r\nexport abstract class Resolved<T> extends Resolvable<T>\r\n{\r\n\tconstructor(state:Promise.State, result:T, error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._result = result;\r\n\t\tthis._error = error;\r\n\t\tthis._state = state;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * A fulfilled Resolved<T>.  Provided for readability.\r\n */\r\nclass Fulfilled<T> extends Resolved<T>\r\n{\r\n\tconstructor(value?:T)\r\n\t{\r\n\t\tsuper(Promise.State.Fulfilled, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * A rejected Resolved<T>.  Provided for readability.\r\n */\r\nclass Rejected<T> extends Resolved<T>\r\n{\r\n\tconstructor(error:any)\r\n\t{\r\n\t\tsuper(Promise.State.Rejected, VOID0, error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Provided as a means for extending the interface of other PromiseLike<T> objects.\r\n */\r\nclass PromiseWrapper<T> extends Resolvable<T>\r\n{\r\n\tconstructor(private _target:PromiseLike<T>)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(!_target)\r\n\t\t\tthrow new ArgumentNullException(TARGET);\r\n\r\n\t\tif(!isPromise(_target))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be a promise-like object.\");\r\n\r\n\t\t_target.then(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Fulfilled;\r\n\t\t\t\tthis._result = v;\r\n\t\t\t\tthis._error = VOID0;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t},\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Rejected;\r\n\t\t\t\tthis._error = e;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t})\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.then(onFulfilled, onRejected);\r\n\r\n\t\tvar p = Promise.pending<TResult>();\r\n\t\thandleDispatch(t,\r\n\t\t\tresult=>handleResolution(p, result, onFulfilled),\r\n\t\t\terror=>onRejected ? handleResolution(p, error, onRejected) : p.reject(error));\r\n\t\treturn p;\r\n\t}\r\n\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.thenThis(onFulfilled, onRejected);\r\n\t\thandleDispatch(t, onFulfilled, onRejected);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._target = VOID0;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * This promise class that facilitates pending resolution.\r\n */\r\nexport class Promise<T> extends Resolvable<T>\r\n{\r\n\r\n\tprivate _waiting:IPromiseCallbacks<any>[];\r\n\r\n\t/*\r\n\t * A note about deferring:\r\n\t * The caller can set resolveImmediate to true if they intend to initialize code that will end up being deferred itself.\r\n\t * This eliminates the extra defer that will occur internally.\r\n\t * But for the most part, resolveImmediate = false (the default) will ensure the constructor will not block.\r\n\t *\r\n\t * resolveUsing allows for the same ability but does not defer by default: allowing the caller to take on the work load.\r\n\t * If calling resolve or reject and a deferred response is desired, then use deferImmediate with a closure to do so.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tresolver?:Promise.Executor<T>,\r\n\t\tresolveImmediate:boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(resolver) this.resolveUsing(resolver, !resolveImmediate);\r\n\t}\r\n\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.then(onFulfilled, onRejected);\r\n\r\n\t\tvar p = new Promise<TResult>();\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.thenThis(onFulfilled, onRejected);\r\n\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolvedCalled = VOID0;\r\n\t}\r\n\r\n\t// Protects against double calling.\r\n\tprotected _resolvedCalled:boolean;\r\n\r\n\tresolveUsing(\r\n\t\tresolver:Promise.Executor<T>,\r\n\t\tdeferResolution:boolean = false,\r\n\t\tthrowIfSettled:boolean = false)\r\n\t{\r\n\t\tif(!resolver)\r\n\t\t\tthrow new ArgumentNullException(\"resolver\");\r\n\t\tif(this._resolvedCalled)\r\n\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\tif(this.state)\r\n\t\t\tthrow new InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\r\n\r\n\t\tthis._resolvedCalled = true;\r\n\r\n\t\tvar rejectHandler = (reason:any)=>\r\n\t\t{\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.reject(reason);\r\n\t\t};\r\n\r\n\t\tvar fulfillHandler = (v:any)=>\r\n\t\t{\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolve(v);\r\n\t\t};\r\n\r\n\t\tvar r = ()=>resolver(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tif(v==this) throw new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\t\t\t\tif(isPromise(v))\r\n\t\t\t\t\thandleDispatch(v, fulfillHandler, rejectHandler);\r\n\t\t\t\telse\r\n\t\t\t\t\tfulfillHandler(v);\r\n\t\t\t},\r\n\t\t\trejectHandler);\r\n\r\n\t\tif(deferResolution) deferImmediate(r);\r\n\t\telse r();\r\n\t}\r\n\r\n\tresolve(result?:T, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(<any>result==this)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Fulfilled && this._result===result) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._state = Promise.State.Fulfilled;\r\n\r\n\t\tthis._result = result;\r\n\t\tthis._error = VOID0;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = VOID0;\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onFulfilled, promise} = c, p = (<Promise<T>>promise);\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\thandleResolution(p, result, onFulfilled);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\treject(error:any, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Rejected && this._error===error) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._state = Promise.State.Rejected;\r\n\r\n\t\tthis._error = error;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = null; // null = finished. undefined = hasn't started.\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onRejected, promise} = c, p = (<Promise<T>>promise);\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\tif(onRejected) handleResolution(p, error, onRejected);\r\n\t\t\t\telse p.reject(error);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This promise class ensures that all subsequent then calls resolve in a deferred/async manner.\r\n * This is not intended as a promise generator.  Use Pending for deferring results.\r\n */\r\nclass SubsequentDeferred<T> extends PromiseBase<T>\r\n{\r\n\tconstructor(private _parent:PromiseBase<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_parent || !(_parent instanceof PromiseBase))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be of type Promise.\");\r\n\t}\r\n\r\n\tprotected _onDisposed():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._parent = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\treturn this._parent.state;\r\n\t}\r\n\r\n\tprotected getResult():T\r\n\t{\r\n\t\treturn this._parent.result;\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._parent.error;\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar d = this._parent.defer();\r\n\t\tvar p = d.then(onFulfilled, onRejected);\r\n\t\t// Since there is only 1 'then' for the deferred promise, cleanup immediately after.\r\n\t\td.finally(()=>pools.recycle(d));\r\n\t\treturn p;\r\n\t}\r\n\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar d = this._parent.defer();\r\n\t\td.thenThis(onFulfilled, onRejected);\r\n\t\t// Since there is only 1 'then' for the deferred promise, cleanup immediately after.\r\n\t\td.finally(()=>pools.recycle(d));\r\n\t\treturn this;\r\n\t}\r\n\r\n\tdefer():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tdeferAll():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tget parent():PromiseBase<T>\r\n\t{\r\n\t\treturn this._parent;\r\n\t}\r\n}\r\n\r\n/**\r\n * This promise class only resolves the provided factory if values are requested or state is queried.\r\n * It is considered resolved since the resolution will be generated synchronously.\r\n */\r\nexport class LazyResolved<T> extends Resolved<T>\r\n{\r\n\tconstructor(private _factory:Func<T>)\r\n\t{\r\n\t\tsuper(Promise.State.Pending, VOID0);\r\n\t\tif(!_factory) throw new ArgumentNullException(\"factory\");\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._factory = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\tthis.getResult();\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tprotected getResult():T\r\n\t{\r\n\t\tif(!this._state)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tthis._result = this._factory();\r\n\t\t\t\tthis._state = Promise.State.Fulfilled;\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\tthis._error = ex;\r\n\t\t\t\tthis._state = Promise.State.Rejected;\r\n\t\t\t}\r\n\t\t\tthis._factory = VOID0;\r\n\t\t}\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\tthis.getResult();\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tthis.getResult();\r\n\t\treturn super.then(onFulfilled, onRejected);\r\n\t}\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tthis.getResult();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t/**\r\n\t * This allows for synchronously triggering the factory ahead of time since calling .defer() shouldn't trigger it.\r\n\t * @returns {LazyResolved}\r\n\t */\r\n\tresolve():PromiseBase<T>\r\n\t{\r\n\t\tthis.getResult();\r\n\t\treturn this;\r\n\t}\r\n\r\n\tget isResolved():boolean\r\n\t{\r\n\t\treturn !this._factory;\r\n\t}\r\n}\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends Promise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:Promise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tvar r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r, true);\r\n\t\t}\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.then(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n}\r\n\r\nmodule pools\r\n{\r\n\r\n\texport module pending\r\n\t{\r\n\r\n\r\n\t\tvar pool:ObjectPool<Promise<any>>;\r\n\r\n\t\tfunction getPool()\r\n\t\t{\r\n\t\t\treturn pool || (pool = new ObjectPool<Promise<any>>(40, factory));\r\n\t\t}\r\n\r\n\t\tfunction factory():Promise<any>\r\n\t\t{\r\n\t\t\treturn new Promise();\r\n\t\t}\r\n\r\n\t\texport function get():Promise<any>\r\n\t\t{\r\n\t\t\tvar p:any = getPool().take();\r\n\t\t\tp.__wasDisposed = false;\r\n\t\t\tp._state = Promise.State.Pending;\r\n\t\t\treturn p;\r\n\t\t}\r\n\r\n\t\texport function recycle<T>(c:Promise<T>):void\r\n\t\t{\r\n\t\t\tif(!c) return;\r\n\t\t\tc.dispose();\r\n\t\t\tgetPool().add(c);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport function recycle<T>(c:PromiseBase<T>):void\r\n\t{\r\n\t\tif(!c) return;\r\n\t\tif(c instanceof Promise) pending.recycle(c);\r\n\t\telse c.dispose();\r\n\t}\r\n\r\n\r\n\texport module PromiseCallbacks\r\n\t{\r\n\r\n\t\tvar pool:ObjectPool<IPromiseCallbacks<any>>;\r\n\r\n\t\tfunction getPool()\r\n\t\t{\r\n\t\t\treturn pool || (pool = new ObjectPool<IPromiseCallbacks<any>>(40, factory));\r\n\t\t}\r\n\r\n\t\tfunction factory():IPromiseCallbacks<any>\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tonFulfilled: null,\r\n\t\t\t\tonRejected: null,\r\n\t\t\t\tpromise: null\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\texport function init<T>(\r\n\t\t\tonFulfilled:Promise.Fulfill<T,any>,\r\n\t\t\tonRejected?:Promise.Reject<any>,\r\n\t\t\tpromise?:PromiseLike<any>):IPromiseCallbacks<T>\r\n\t\t{\r\n\r\n\t\t\tvar c = getPool().take();\r\n\t\t\tc.onFulfilled = onFulfilled;\r\n\t\t\tc.onRejected = onRejected;\r\n\t\t\tc.promise = promise;\r\n\t\t\treturn c;\r\n\t\t}\r\n\r\n\t\texport function recycle<T>(c:IPromiseCallbacks<T>):void\r\n\t\t{\r\n\t\t\tc.onFulfilled = null;\r\n\t\t\tc.onRejected = null;\r\n\t\t\tc.promise = null;\r\n\t\t\tgetPool().add(c);\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport module Promise\r\n{\r\n\r\n\t/**\r\n\t * The state of a promise.\r\n\t * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\r\n\t * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.\r\n\t */\r\n\texport enum State {\r\n\t\tPending   = 0,\r\n\t\tFulfilled = 1,\r\n\t\tRejected  = -1\r\n\t}\r\n\tObject.freeze(State);\r\n\r\n\texport type Resolution<TResult> = PromiseLike<TResult>|TResult|void;\r\n\r\n\texport interface Fulfill<T, TResult>\r\n\t{\r\n\t\t(value:T):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Reject<TResult>\r\n\t{\r\n\t\t(err?:any):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Then<T,TResult>\r\n\t{\r\n\t\t(\r\n\t\t\tonFulfilled:Fulfill<T,TResult>,\r\n\t\t\tonRejected?:Reject<TResult>):PromiseBase<TResult>\r\n\t}\r\n\r\n\texport interface Executor<T>\r\n\t{\r\n\t\t(\r\n\t\t\tresolve:(value?:T | PromiseLike<T>) => void,\r\n\t\t\treject:(reason?:any) => void):void;\r\n\t}\r\n\r\n\t// /**\r\n\t//  * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t//  * or rejected.\r\n\t//  * @param values An array of Promises.\r\n\t//  * @returns A new Promise.\r\n\t//  */\r\n\t// // race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\r\n\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t */\r\n\texport function all<T>(promises:PromiseLike<T>[]):PromiseBase<T[]>\r\n\texport function all<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T[]>\r\n\texport function all(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any[]>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tvar promises = (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v=>!v)) return new Fulfilled<any[]>(promises); // it's a new empty, reuse it. :|\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\tvar len = promises.length;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar p = promises[i];\r\n\t\t\tif(p instanceof SubsequentDeferred) promises[i] = p.parent;\r\n\t\t}\r\n\r\n\t\treturn pending<any[]>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet checkedAll = false;\r\n\t\t\tlet result:any[] = [];\r\n\t\t\tresult.length = len;\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i)=>i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = null;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = ()=>\r\n\t\t\t{\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(result);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any, i:number)=>\r\n\t\t\t{\r\n\t\t\t\tif(resolve)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = v;\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onReject = (e?:any)=>\r\n\t\t\t{\r\n\t\t\t\tlet r = reject;\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(e);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v=>onFulfill(v, i), onReject);\r\n\t\t\t\telse remaining.remove(i);\r\n\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise for the first of an array of promises to become settled.\r\n\t */\r\n\texport function race<T>(promises:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any>\r\n\t{\r\n\t\tvar promises = first && (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy?\r\n\t\tif(!promises || !promises.length || !(promises = promises.filter(v=>v!=null)).length)\r\n\t\t\tthrow new ArgumentException(\"Nothing to wait for.\");\r\n\r\n\t\tvar len = promises.length;\r\n\r\n\t\t// Only one?  Nothing to race.\r\n\t\tif(len==1) return wrap(promises[0]).defer();\r\n\r\n\t\t// Look for already resolved promises and the first one wins.\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar p:any = promises[i];\r\n\t\t\tif(p instanceof SubsequentDeferred) p = p.parent;\r\n\t\t\tif(p instanceof LazyResolved)\r\n\t\t\t{\r\n\t\t\t\t// If a a LazyResolved has resolved, then it wins otherwise let it defer and not (potentially) block.\r\n\t\t\t\tif(p.isResolved) return p.defer();\r\n\t\t\t}\r\n\t\t\telse if(p instanceof Resolved || p instanceof PromiseBase && p.isSettled)\r\n\t\t\t{\r\n\t\t\t\treturn p.defer();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn pending((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolve = (r:(x:any)=>void, v:any)=>\r\n\t\t\t{\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(v);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any)=> onResolve(resolve, v);\r\n\t\t\tlet onReject = (e?:any)=> onResolve(reject, e);\r\n\r\n\t\t\tfor(let p of promises)\r\n\t\t\t{\r\n\t\t\t\tif(!resolve) break;\r\n\t\t\t\tp.then(onFulfill, onReject);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new resolved promise .\r\n\t * @returns A resolved promise.\r\n\t */\r\n\texport function resolve():PromiseBase<void>\r\n\r\n\t/**\r\n\t * Creates a new resolved promise for the provided value.\r\n\t * @param value A value or promise.\r\n\t * @returns A promise whose internal state matches the provided promise.\r\n\t */\r\n\texport function resolve<T>(value:T | PromiseLike<T>):PromiseBase<T>;\r\n\texport function resolve(value?:any):PromiseBase<any>\r\n\t{\r\n\r\n\t\treturn isPromise(value) ? wrap(value) : new Fulfilled(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new rejected promise for the provided reason.\r\n\t * @param reason The reason the promise was rejected.\r\n\t * @returns A new rejected Promise.\r\n\t */\r\n\texport function reject<T>(reason:T):PromiseBase<T>\r\n\t{\r\n\t\treturn new Rejected<T>(reason);\r\n\t}\r\n\r\n\r\n\texport module lazy\r\n\t{\r\n\t\t/**\r\n\t\t * Provides a promise that will be resolved immediately at the first 'then' request.\r\n\t\t * @param factory\r\n\t\t */\r\n\t\texport function resolve<T>(factory:Func<T>):LazyResolved<T>\r\n\t\t{\r\n\t\t\treturn new LazyResolved<T>(factory);\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Provides a promise that will trigger the resolver at the first 'then' request.\r\n\t\t * @param resolver\r\n\t\t * @returns {Promise<T>}\r\n\t\t */\r\n\t\texport function pending<T>(resolver:Promise.Executor<T>):LazyPromise<T>\r\n\t\t{\r\n\t\t\treturn new LazyPromise(resolver);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes any Promise-Like object and ensures an extended version of it from this module.\r\n\t * @param target The Promise-Like object\r\n\t * @returns A new target that simply extends the target.\r\n\t */\r\n\texport function wrap<T>(target:PromiseLike<T>):PromiseBase<T>\r\n\t{\r\n\t\tif(!target) throw new ArgumentNullException(TARGET);\r\n\t\treturn target instanceof Promise ? this : new PromiseWrapper(target);\r\n\t}\r\n\r\n\t/**\r\n\t * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.\r\n\t * @param then\r\n\t * @returns {PromiseWrapper<T>}\r\n\t */\r\n\texport function createFrom<T,TResult>(then:Then<T,TResult>):PromiseBase<T>\r\n\t{\r\n\t\tif(!then) throw new ArgumentNullException(THEN);\r\n\t\treturn new PromiseWrapper({then: then});\r\n\t}\r\n\r\n\t/**\r\n\t * Provides a promise that can be resolved later.\r\n\t * @returns {Promise<T>}\r\n\t */\r\n\texport function pending<T>(resolver?:Promise.Executor<T>):Promise<T>\r\n\t{\r\n\t\tvar p = pools.pending.get();\r\n\t\tif(resolver) p.resolveUsing(resolver);\r\n\t\treturn p;\r\n\t}\r\n\r\n\t//export function all()\r\n\r\n}\r\n\r\n\r\ninterface IPromiseCallbacks<T>\r\n{\r\n\tonFulfilled:Promise.Fulfill<T,any>;\r\n\tonRejected:Promise.Reject<any>;\r\n\tpromise?:PromiseLike<any>;\r\n}\r\n"]}