{"version":3,"sources":["System/Text/Utility.ts"],"names":["escapeRegExp","trim","format","supplant"],"mappings":";;;;;;;;;;;;;;;;qBAKiB,UAAU;;;;AAE3B,IAAa,KAAK,GAAU,EAAE,CAAC;;;AAE/B,SAAA,YAAA,CAA6B,MAAa,EAAA;AACzCA,WAAOA,MAAMA,CAACA,OAAOA,CAACA,qCAAqCA,EAAEA,MAAMA,CAACA,CAACA;CACrEA;;AAED,SAAA,IAAA,CAAqB,MAAa,EAAE,KAAsB,EAAC,UAAmB,EAAA;AAE7EC,QAAGA,KAAKA,EAAEA;AACTA,YAAGA,KAAKA,KAAGA,KAAKA,EAAEA,OAAOA,MAAMA,CAACA;AAChCA,YAAIA,OAAOA,GAAGA,YAAYA,CAACA,KAAKA,YAAYA,KAAKA,GAAGA,KAAKA,CAACA,IAAIA,EAAEA,GAAWA,KAAKA,CAACA,CAACA;AAClFA,eAAOA,MAAMA,CAACA,OAAOA,CAACA,IAAIA,MAAMA,CAACA,IAAIA,GAACA,OAAOA,GAACA,MAAMA,GAACA,OAAOA,GAACA,KAAKA,EAACA,GAAGA,IAAEA,UAAUA,GAACA,GAAGA,GAACA,EAAEA,CAAAA,AAACA,CAACA,EAACA,KAAKA,CAACA,CAACA;KACnGA;AAEDA,WAAOA,MAAMA,CAACA,OAAOA,CAACA,YAAYA,EAAEA,KAAKA,CAACA,CAACA;CAC3CA;;AAQD,SAAA,MAAA,CAAuB,MAAa,EAAe;sCAAV,IAAU;AAAV,YAAU;;;AAElDC,WAAOA,QAAQA,CAACA,MAAMA,EAAEA,IAAIA,CAACA,CAACA;CAC9BA;;AAaD,SAAA,QAAA,CAAyB,MAAa,EAAE,MAA+B,EAAA;AAEtEC,QAAIA,QAAQA,GAAGA,MAAMA,YAAYA,KAAKA,CAACA;AACvCA,WAAOA,MAAMA,CAACA,OAAOA,CAACA,eAAeA,EACpCA,UAACA,CAAQA,EAAEA,CAAQA,EAAAA;AAElBA,YAAIA,CAACA,GAAOA,CAACA,CAACA;AACdA,YAAGA,QAAQA,EACXA;AACCA,gBAAIA,CAACA,GAAGA,QAAQA,CAACA,CAACA,CAACA,CAACA;AACpBA,gBAAGA,CAACA,KAAKA,CAACA,CAACA,CAACA,EAAEA,CAACA,GAAGA,CAACA,CAACA;SACpBA;AAEDA,YAAIA,CAACA,GAASA,MAAOA,CAACA,CAACA,CAACA,CAACA;AACzBA,gBAAOA,OAAOA,CAACA;AAEdA,iBAAKA,mBAAKA,MAAMA,CAACA;AACjBA,iBAAKA,mBAAKA,MAAMA,CAACA;AACjBA,iBAAKA,mBAAKA,OAAOA;AAChBA,uBAAOA,CAACA,CAACA;AAAAA,AACVA;AACCA,uBAAOA,CAACA,CAACA;AAAAA,SACVA;KACDA,CACDA,CAACA;CACFA","file":"System/Text/Utility.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport Type from '../Types';\r\n\r\nexport const EMPTY:string = '';\r\n\r\nexport function escapeRegExp(source:string):string {\r\n\treturn source.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\n\r\nexport function trim(source:string, chars?:string|string[],ignoreCase?:boolean):string\r\n{\r\n\tif(chars) {\r\n\t\tif(chars===EMPTY) return source;\r\n\t\tvar escaped = escapeRegExp(chars instanceof Array ? chars.join() : <string>chars);\r\n\t\treturn source.replace(new RegExp('^['+escaped+']+|['+escaped+']+$','g'+(ignoreCase?'i':'')),EMPTY);\r\n\t}\r\n\r\n\treturn source.replace(/^\\s+|\\s+$/g, EMPTY);\r\n}\r\n\r\n/**\r\n * Takes any arg\r\n * @param source\r\n * @param args\r\n * @returns {string}\r\n */\r\nexport function format(source:string, ...args:any[])\r\n{\r\n\treturn supplant(source, args);\r\n}\r\n\r\n//\r\n\r\n/**\r\n * This takes a string and replaces '{string}' with the respected parameter.\r\n * Also allows for passing an array in order to use '{n}' notation.\r\n * Not limited to an array's indexes.  For example, {length} is allowed.\r\n * Based upon Crockford's supplant function.\r\n * @param source\r\n * @param params\r\n * @returns {string}\r\n */\r\nexport function supplant(source:string, params:{[key:string]:any}|any[]):string\r\n{\r\n\tvar oIsArray = params instanceof Array;\r\n\treturn source.replace(/\\{([^{}]*)\\}/g,\r\n\t\t(a:string, b:string):any=>\r\n\t\t{\r\n\t\t\tvar n:any = b;\r\n\t\t\tif(oIsArray)\r\n\t\t\t{\r\n\t\t\t\tlet i = parseInt(b);\r\n\t\t\t\tif(!isNaN(i)) n = i;\r\n\t\t\t}\r\n\r\n\t\t\tvar r = (<any>params)[n];\r\n\t\t\tswitch(typeof r)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\tcase Type.NUMBER:\r\n\t\t\t\tcase Type.BOOLEAN:\r\n\t\t\t\t\treturn r;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn a;\r\n\t\t\t}\r\n\t\t}\r\n\t);\r\n}\r\n"]}