{"version":3,"sources":["System/Text/RegularExpressions.js","System/Text/RegularExpressions.ts"],"names":[],"mappings":"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","file":"System/Text/RegularExpressions.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nconst EMPTY = \"\";\nconst UNDEFINED = \"undefined\";\nconst PATTERN = \"pattern\";\nvar RegexOptions;\n(function (RegexOptions) {\n    RegexOptions.IGNORE_CASE = 'i';\n    RegexOptions.GLOBAL = 'g';\n    RegexOptions.MULTI_LINE = 'm';\n    RegexOptions.UNICODE = 'u';\n    RegexOptions.STICKY = 'y';\n})(RegexOptions = exports.RegexOptions || (exports.RegexOptions = {}));\nclass Regex {\n    constructor(pattern, options) {\n        if (!pattern)\n            throw new ArgumentNullException_1.default(PATTERN);\n        var patternString, flags = options && options.join(EMPTY) || EMPTY;\n        if (pattern instanceof RegExp) {\n            let p = pattern;\n            if (p.ignoreCase && flags.indexOf(RegexOptions.IGNORE_CASE) === -1)\n                flags\n                    += RegexOptions.IGNORE_CASE;\n            if (p.multiline && flags.indexOf(RegexOptions.MULTI_LINE) === -1)\n                flags\n                    += RegexOptions.MULTI_LINE;\n            patternString = p.source;\n        }\n        else {\n            patternString = pattern;\n        }\n        flags = flags.replace(RegexOptions.GLOBAL, EMPTY);\n        var keys = [];\n        {\n            let k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\n            if (k) {\n                for (let i = 0, len = k.length; i < len; i++) {\n                    keys[i + 1] = k[i];\n                }\n                this._keys = keys;\n                this._re = new RegExp(patternString.replace(/\\?<\\w+>/g, EMPTY), flags);\n            }\n            else {\n                this._keys = null;\n                this._re = new RegExp(patternString, flags);\n            }\n        }\n        Object.freeze(this);\n    }\n    match(input) {\n        var _ = this;\n        var r = this._re.exec(input);\n        if (!r)\n            return Match.Empty;\n        var loc = r.index, groups = [], groupMap = {};\n        for (let i = 0, len = r.length; i < len; ++i) {\n            let text = typeof r[i] !== UNDEFINED && r[i].constructor === String ? r[i] : EMPTY;\n            let g = new Group(text, loc);\n            g.freeze();\n            if (i && _._keys && i < _._keys.length)\n                groupMap[_._keys[i]] = g;\n            groups.push(g);\n            if (i !== 0)\n                loc += text.length;\n        }\n        var m = new Match(r[0], r.index, groups, groupMap);\n        m.freeze();\n        return m;\n    }\n    matches(input) {\n        var matches = [], m;\n        while ((m = this.match(input)) && m.success) {\n            matches.push(m);\n            input = input.substring(m.index + m.length);\n        }\n        return matches;\n    }\n    replace(input, r) {\n        return input.replace(this._re, r);\n    }\n    isMatch(input) {\n        return this._re.test(input);\n    }\n    static isMatch(input, pattern, options) {\n        var r = new Regex(pattern, options);\n        return r.isMatch(input);\n    }\n    static replace(input, pattern, e, options) {\n        var r = new Regex(pattern, options);\n        return r.replace(input, e);\n    }\n}\nexports.Regex = Regex;\nclass Capture {\n    constructor(value = EMPTY, index = -1) {\n        this.value = value;\n        this.index = index;\n    }\n    get length() {\n        var v = this.value;\n        return v && v.length || 0;\n    }\n    freeze() {\n        Object.freeze(this);\n    }\n}\nexports.Capture = Capture;\nclass Group extends Capture {\n    constructor(value = EMPTY, index = -1) {\n        super(value, index);\n    }\n    get success() {\n        return this.index != -1;\n    }\n    static get Empty() {\n        return EmptyGroup;\n    }\n}\nexports.Group = Group;\nconst EmptyGroup = new Group();\nclass Match extends Group {\n    constructor(value = EMPTY, index = -1, groups = [], namedGroups = {}) {\n        super(value, index);\n        this.groups = groups;\n        this.namedGroups = namedGroups;\n    }\n    freeze() {\n        if (!this.groups)\n            throw new ArgumentNullException_1.default('groups');\n        if (!this.namedGroups)\n            throw new ArgumentNullException_1.default('groupMap');\n        Object.freeze(this.groups.slice());\n        Object.freeze(this.namedGroups);\n        super.freeze();\n    }\n    static get Empty() {\n        return EmptyMatch;\n    }\n}\nexports.Match = Match;\nconst EmptyMatch = new Match();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Regex;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Collections/Dictionaries/IDictionary\"/>\r\nimport ArgumentNullException from \"../Exceptions/ArgumentNullException\";\r\n\r\nconst EMPTY:string = \"\";\r\nconst UNDEFINED:string = \"undefined\";\r\nconst PATTERN:string = \"pattern\";\r\n\r\n\r\n/**\r\n * https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions%28v=vs.110%29.aspx\r\n */\r\nexport module RegexOptions\r\n{\r\n\t/**\r\n\t * Specifies case-insensitive matching. For more information, see the \"Case-Insensitive Matching \" section in the Regular Expression Options topic.\r\n\t */\r\n\texport const IGNORE_CASE:string = 'i';\r\n\r\n\t/**\r\n\t * Specifies global matching instead of single.\r\n\t */\r\n\texport const GLOBAL:string = 'g';\r\n\r\n\t/**\r\n\t * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \\n or \\r), not only the very beginning or end of the whole input string)\r\n\t */\r\n\texport const MULTI_LINE:string = 'm';\r\n\r\n\t/**\r\n\t * treat pattern as a sequence of unicode code points\r\n\t */\r\n\texport const UNICODE:string = 'u';\r\n\r\n\t/**\r\n\t * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\r\n\t */\r\n\texport const STICKY:string = 'y';\r\n\r\n\texport type Global = 'g';\r\n\texport type IgnoreCase = 'i';\r\n\texport type MultiLine = 'm';\r\n\texport type Unicode = 'u';\r\n\texport type Sticky = 'y';\r\n\r\n\texport type Literal = Global | IgnoreCase | MultiLine | Unicode | Sticky;\r\n}\r\n\r\nexport interface MatchEvaluator\r\n{\r\n\t//(match:Match):string;\r\n\t(substring:string, ...args:any[]):string;\r\n}\r\n\r\nexport class Regex\r\n{\r\n\tprivate _re:RegExp;\r\n\tprivate _keys:string[];\r\n\r\n\tconstructor(\r\n\t\tpattern:string|RegExp,\r\n\t\toptions?:RegexOptions.Literal[])\r\n\t{\r\n\t\tif(!pattern) throw new ArgumentNullException(PATTERN);\r\n\t\tvar patternString:string, flags:string = options && options.join(EMPTY) || EMPTY;\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tlet p = <RegExp>pattern;\r\n\t\t\tif(p.ignoreCase && flags.indexOf(RegexOptions.IGNORE_CASE)=== -1) flags\r\n\t\t\t\t+= RegexOptions.IGNORE_CASE;\r\n\t\t\tif(p.multiline && flags.indexOf(RegexOptions.MULTI_LINE)=== -1) flags\r\n\t\t\t\t+= RegexOptions.MULTI_LINE;\r\n\t\t\tpatternString = p.source;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpatternString = pattern;\r\n\t\t}\r\n\r\n\t\t// For the majority of expected behavior, we need to eliminate global.\r\n\t\tflags = flags.replace(RegexOptions.GLOBAL, EMPTY);\r\n\r\n\t\t// find the keys inside the pattern, and place in mapping array {0:'key1', 1:'key2', ...}\r\n\t\tvar keys:string[] = [];\r\n\t\t{\r\n\t\t\tlet k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = 0, len = k.length; i<len; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys[i+1] = k[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._keys = keys;\r\n\t\t\t\t// remove keys from regexp leaving standard regexp\r\n\t\t\t\tthis._re = new RegExp(patternString.replace(/\\?<\\w+>/g, EMPTY), flags);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis._keys = null;\r\n\t\t\t\tthis._re = new RegExp(patternString, flags);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tmatch(input:string):Match\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar r = this._re.exec(input);\r\n\t\tif(!r) return Match.Empty;\r\n\r\n\t\tvar loc                  = r.index,\r\n\t\t    groups:Group[]       = [],\r\n\t\t    groupMap:IMap<Group> = {};\r\n\r\n\t\tfor(let i = 0, len = r.length; i<len; ++i)\r\n\t\t{\r\n\t\t\tlet text = typeof r[i]!==UNDEFINED && r[i].constructor===String ? r[i] : EMPTY;\r\n\t\t\tlet g = new Group(text, loc);\r\n\t\t\tg.freeze();\r\n\t\t\tif(i && _._keys && i<_._keys.length) groupMap[_._keys[i]] = g;\r\n\t\t\tgroups.push(g);\r\n\t\t\tif(i!==0) loc += text.length;\r\n\t\t}\r\n\r\n\t\tvar m = new Match(r[0], r.index, groups, groupMap);\r\n\t\tm.freeze();\r\n\t\treturn m;\r\n\t}\r\n\r\n\tmatches(input:string):Match[]\r\n\t{\r\n\t\tvar matches:Match[] = [], m:Match;\r\n\t\twhile((m = this.match(input)) && m.success) {\r\n\t\t\tmatches.push(m);\r\n\t\t\tinput = input.substring(m.index+m.length);\r\n\t\t}\r\n\r\n\t\treturn matches;\r\n\t}\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\treplacement:string):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tevaluator:MatchEvaluator):string;\r\n\r\n\treplace(\r\n\t\tinput:string, r:any):string\r\n\t{\r\n\t\treturn input.replace(this._re, r);\r\n\t}\r\n\r\n\tisMatch(input:string):boolean\r\n\t{\r\n\t\treturn this._re.test(input);\r\n\t}\r\n\r\n\tstatic isMatch(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\toptions?:RegexOptions.Literal[]):boolean\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.isMatch(input);\r\n\t}\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\treplacement:string,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\tevaluator:MatchEvaluator,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\te:any,\r\n\t\toptions?:RegexOptions.Literal[]):string\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.replace(input, e);\r\n\t}\r\n}\r\n\r\nexport class Capture\r\n{\r\n\r\n\tget length():number\r\n\t{\r\n\t\tvar v = this.value;\r\n\t\treturn v && v.length || 0;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tpublic value:string = EMPTY,\r\n\t\tpublic index:number = -1)\r\n\t{\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n}\r\n\r\nexport class Group extends Capture\r\n{\r\n\tget success():boolean\r\n\t{\r\n\t\treturn this.index!= -1;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1)\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tstatic get Empty():Group\r\n\t{\r\n\t\treturn EmptyGroup;\r\n\t}\r\n\r\n}\r\nconst EmptyGroup = new Group();\r\n\r\nexport class Match extends Group\r\n{\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1,\r\n\t\tpublic groups:Group[] = [],\r\n\t\tpublic namedGroups:IMap<Group> = {})\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tif(!this.groups) throw new ArgumentNullException('groups');\r\n\t\tif(!this.namedGroups) throw new ArgumentNullException('groupMap');\r\n\t\tObject.freeze(this.groups.slice());\r\n\t\tObject.freeze(this.namedGroups);\r\n\t\tsuper.freeze();\r\n\t}\r\n\r\n\tstatic get Empty():Match\r\n\t{\r\n\t\treturn EmptyMatch;\r\n\t}\r\n}\r\nconst EmptyMatch = new Match();\r\n\r\n\r\n\r\n\r\nexport default Regex;"]}