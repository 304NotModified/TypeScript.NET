{"version":3,"sources":["System/Text/RegularExpressions.js","System/Text/RegularExpressions.ts"],"names":[],"mappings":"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","file":"System/Text/RegularExpressions.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst EMPTY = \"\";\nconst UNDEFINED = \"undefined\";\nvar RegexOptions;\n(function (RegexOptions) {\n    RegexOptions.IGNORE_CASE = 'i';\n    RegexOptions.GLOBAL = 'g';\n    RegexOptions.MULTI_LINE = 'm';\n    RegexOptions.UNICODE = 'u';\n    RegexOptions.STICKY = 'y';\n})(RegexOptions = exports.RegexOptions || (exports.RegexOptions = {}));\nclass Regex {\n    constructor(pattern, options) {\n        if (!pattern)\n            throw new Error(\"'pattern' cannot be null or empty.\");\n        var patternString, flags = options && options.join(EMPTY) || EMPTY;\n        if (pattern instanceof RegExp) {\n            let p = pattern;\n            if (p.ignoreCase && flags.indexOf(RegexOptions.IGNORE_CASE) === -1)\n                flags\n                    += RegexOptions.IGNORE_CASE;\n            if (p.multiline && flags.indexOf(RegexOptions.MULTI_LINE) === -1)\n                flags\n                    += RegexOptions.MULTI_LINE;\n            patternString = p.source;\n        }\n        else {\n            patternString = pattern;\n        }\n        flags = flags.replace(RegexOptions.GLOBAL, EMPTY);\n        var keys = [];\n        {\n            let k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\n            if (k) {\n                for (let i = 0, len = k.length; i < len; i++) {\n                    keys[i + 1] = k[i];\n                }\n                patternString = patternString.replace(/\\?<\\w+>/g, EMPTY);\n                this._keys = keys;\n            }\n            this._re = new RegExp(patternString, flags);\n        }\n        Object.freeze(this);\n    }\n    match(input, startIndex = 0) {\n        var _ = this;\n        var r;\n        if (!input\n            || startIndex >= input.length\n            || !(r = this._re.exec(input.substring(startIndex))))\n            return Match.Empty;\n        if (!(startIndex > 0))\n            startIndex = 0;\n        var first = startIndex + r.index, loc = first, groups = [], groupMap = {};\n        for (let i = 0, len = r.length; i < len; ++i) {\n            let text = typeof r[i] !== UNDEFINED && r[i].constructor === String ? r[i] : EMPTY;\n            let g = new Group(text, loc);\n            g.freeze();\n            if (i && _._keys && i < _._keys.length)\n                groupMap[_._keys[i]] = g;\n            groups.push(g);\n            if (i !== 0)\n                loc += text.length;\n        }\n        var m = new Match(r[0], first, groups, groupMap);\n        m.freeze();\n        return m;\n    }\n    matches(input) {\n        var matches = [], m, p = 0, end = input && input.length || 0;\n        while (p < end && (m = this.match(input, p)) && m.success) {\n            matches.push(m);\n            p = m.index + m.length;\n        }\n        return Object.freeze(matches);\n    }\n    replace(input, r, count = Infinity) {\n        if (!input || r === null || r === void 0 || !(count > 0))\n            return input;\n        var result = [];\n        var p = 0, end = input.length, isEvaluator = typeof r == \"function\";\n        var m, i = 0;\n        while (i < count && p < end && (m = this.match(input, p)) && m.success) {\n            let { index, length } = m;\n            if (p !== index)\n                result.push(input.substring(p, index));\n            result.push(isEvaluator ? r(m, i++) : r);\n            p = index + length;\n        }\n        if (p < end)\n            result.push(input.substring(p));\n        return result.join(EMPTY);\n    }\n    isMatch(input) {\n        return this._re.test(input);\n    }\n    static isMatch(input, pattern, options) {\n        var r = new Regex(pattern, options);\n        return r.isMatch(input);\n    }\n    static replace(input, pattern, e, options) {\n        var r = new Regex(pattern, options);\n        return r.replace(input, e);\n    }\n}\nexports.Regex = Regex;\nclass Capture {\n    constructor(value = EMPTY, index = -1) {\n        this.value = value;\n        this.index = index;\n    }\n    get length() {\n        var v = this.value;\n        return v && v.length || 0;\n    }\n    freeze() {\n        Object.freeze(this);\n    }\n}\nexports.Capture = Capture;\nclass Group extends Capture {\n    constructor(value = EMPTY, index = -1) {\n        super(value, index);\n    }\n    get success() {\n        return this.index != -1;\n    }\n    static get Empty() {\n        return EmptyGroup;\n    }\n}\nexports.Group = Group;\nconst EmptyGroup = new Group();\nclass Match extends Group {\n    constructor(value = EMPTY, index = -1, groups = [], namedGroups = {}) {\n        super(value, index);\n        this.groups = groups;\n        this.namedGroups = namedGroups;\n    }\n    freeze() {\n        if (!this.groups)\n            throw new Error(\"'groups' cannot be null.\");\n        if (!this.namedGroups)\n            throw new Error(\"'groupMap' cannot be null.\");\n        Object.freeze(this.groups.slice());\n        Object.freeze(this.namedGroups);\n        super.freeze();\n    }\n    static get Empty() {\n        return EmptyMatch;\n    }\n}\nexports.Match = Match;\nconst EmptyMatch = new Match();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Regex;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Collections/Dictionaries/IDictionary\"/>\r\n///<reference path=\"../FunctionTypes.d.ts\"/>\r\n\r\n// NOTE: Avoid dependencies so this class can be used cleanly.\r\n\r\nconst EMPTY:string = \"\";\r\nconst UNDEFINED:string = \"undefined\";\r\n\r\n\r\n/**\r\n * https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions%28v=vs.110%29.aspx\r\n */\r\nexport module RegexOptions\r\n{\r\n\t/**\r\n\t * Specifies case-insensitive matching. For more information, see the \"Case-Insensitive Matching \" section in the Regular Expression Options topic.\r\n\t */\r\n\texport const IGNORE_CASE:string = 'i';\r\n\r\n\t/**\r\n\t * Specifies global matching instead of single.\r\n\t */\r\n\texport const GLOBAL:string = 'g';\r\n\r\n\t/**\r\n\t * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \\n or \\r), not only the very beginning or end of the whole input string)\r\n\t */\r\n\texport const MULTI_LINE:string = 'm';\r\n\r\n\t/**\r\n\t * treat pattern as a sequence of unicode code points\r\n\t */\r\n\texport const UNICODE:string = 'u';\r\n\r\n\t/**\r\n\t * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\r\n\t */\r\n\texport const STICKY:string = 'y';\r\n\r\n\texport type Global = 'g';\r\n\texport type IgnoreCase = 'i';\r\n\texport type MultiLine = 'm';\r\n\texport type Unicode = 'u';\r\n\texport type Sticky = 'y';\r\n\r\n\texport type Literal = Global | IgnoreCase | MultiLine | Unicode | Sticky;\r\n}\r\n\r\nexport interface MatchEvaluator extends Selector<Match,Primitive>\r\n{\r\n}\r\n\r\nexport class Regex\r\n{\r\n\tprivate _re:RegExp;\r\n\tprivate _keys:string[];\r\n\r\n\tconstructor(\r\n\t\tpattern:string|RegExp,\r\n\t\toptions?:RegexOptions.Literal[])\r\n\t{\r\n\t\tif(!pattern) throw new Error(\"'pattern' cannot be null or empty.\");\r\n\t\tvar patternString:string, flags:string = options && options.join(EMPTY) || EMPTY;\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tlet p = <RegExp>pattern;\r\n\t\t\tif(p.ignoreCase && flags.indexOf(RegexOptions.IGNORE_CASE)=== -1) flags\r\n\t\t\t\t+= RegexOptions.IGNORE_CASE;\r\n\t\t\tif(p.multiline && flags.indexOf(RegexOptions.MULTI_LINE)=== -1) flags\r\n\t\t\t\t+= RegexOptions.MULTI_LINE;\r\n\t\t\tpatternString = p.source;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpatternString = pattern;\r\n\t\t}\r\n\r\n\t\t// For the majority of expected behavior, we need to eliminate global.\r\n\t\tflags = flags.replace(RegexOptions.GLOBAL, EMPTY);\r\n\r\n\t\t// find the keys inside the pattern, and place in mapping array {0:'key1', 1:'key2', ...}\r\n\t\tvar keys:string[] = [];\r\n\t\t{\r\n\t\t\tlet k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = 0, len = k.length; i<len; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys[i + 1] = k[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// remove keys from regexp leaving standard regexp\r\n\t\t\t\tpatternString = patternString.replace(/\\?<\\w+>/g, EMPTY);\r\n\t\t\t\tthis._keys = keys;\r\n\t\t\t}\r\n\r\n\t\t\tthis._re = new RegExp(patternString, flags);\r\n\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tmatch(input:string, startIndex:number = 0):Match\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar r:RegExpExecArray;\r\n\t\tif(!input\r\n\t\t\t|| startIndex>=input.length\r\n\t\t\t|| !(r = this._re.exec(input.substring(startIndex))))\r\n\t\t\treturn Match.Empty;\r\n\r\n\t\tif(!(startIndex>0)) startIndex = 0;\r\n\r\n\t\tvar first                = startIndex + r.index,\r\n\t\t    loc                  = first,\r\n\t\t    groups:Group[]       = [],\r\n\t\t    groupMap:IMap<Group> = {};\r\n\r\n\t\tfor(let i = 0, len = r.length; i<len; ++i)\r\n\t\t{\r\n\t\t\tlet text = typeof r[i]!==UNDEFINED && r[i].constructor===String ? r[i] : EMPTY;\r\n\t\t\tlet g = new Group(text, loc);\r\n\t\t\tg.freeze();\r\n\t\t\tif(i && _._keys && i<_._keys.length) groupMap[_._keys[i]] = g;\r\n\t\t\tgroups.push(g);\r\n\t\t\tif(i!==0) loc += text.length;\r\n\t\t}\r\n\r\n\t\tvar m = new Match(r[0], first, groups, groupMap);\r\n\t\tm.freeze();\r\n\t\treturn m;\r\n\t}\r\n\r\n\tmatches(input:string):Match[]\r\n\t{\r\n\t\tvar matches:Match[] = [], m:Match, p = 0, end = input && input.length || 0;\r\n\t\twhile(p<end && (m = this.match(input,p)) && m.success)\r\n\t\t{\r\n\t\t\tmatches.push(m);\r\n\t\t\tp = m.index + m.length;\r\n\t\t}\r\n\t\treturn Object.freeze(matches);\r\n\t}\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\treplacement:Primitive,\r\n\t\tcount?:number):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tevaluator:MatchEvaluator,\r\n\t\tcount?:number):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tr:any,\r\n\t\tcount:number = Infinity):string\r\n\t{\r\n\t\tif(!input || r===null || r=== void 0 || !(count>0)) return input;\r\n\t\tvar result:string[] = [];\r\n\t\tvar p = 0, end = input.length, isEvaluator = typeof r==\"function\";\r\n\r\n\t\tvar m:Match, i:number = 0;\r\n\t\twhile(i<count && p<end && (m = this.match(input,p)) && m.success)\r\n\t\t{\r\n\t\t\tlet {index, length} = m;\r\n\t\t\tif(p!==index) result.push(input.substring(p, index));\r\n\t\t\tresult.push(isEvaluator ? r(m, i++) : r);\r\n\t\t\tp = index + length;\r\n\t\t}\r\n\r\n\t\tif(p<end) result.push(input.substring(p));\r\n\r\n\t\treturn result.join(EMPTY);\r\n\t}\r\n\r\n\tisMatch(input:string):boolean\r\n\t{\r\n\t\treturn this._re.test(input);\r\n\t}\r\n\r\n\tstatic isMatch(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\toptions?:RegexOptions.Literal[]):boolean\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.isMatch(input);\r\n\t}\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\treplacement:string,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\tevaluator:MatchEvaluator,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\te:any,\r\n\t\toptions?:RegexOptions.Literal[]):string\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.replace(input, e);\r\n\t}\r\n}\r\n\r\nexport class Capture\r\n{\r\n\r\n\tget length():number\r\n\t{\r\n\t\tvar v = this.value;\r\n\t\treturn v && v.length || 0;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tpublic value:string = EMPTY,\r\n\t\tpublic index:number = -1)\r\n\t{\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n}\r\n\r\nexport class Group extends Capture\r\n{\r\n\tget success():boolean\r\n\t{\r\n\t\treturn this.index!= -1;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1)\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tstatic get Empty():Group\r\n\t{\r\n\t\treturn EmptyGroup;\r\n\t}\r\n\r\n}\r\nconst EmptyGroup = new Group();\r\n\r\nexport class Match extends Group\r\n{\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1,\r\n\t\tpublic groups:Group[] = [],\r\n\t\tpublic namedGroups:IMap<Group> = {})\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tif(!this.groups) throw new Error(\"'groups' cannot be null.\");\r\n\t\tif(!this.namedGroups) throw new Error(\"'groupMap' cannot be null.\");\r\n\t\tObject.freeze(this.groups.slice());\r\n\t\tObject.freeze(this.namedGroups);\r\n\t\tsuper.freeze();\r\n\t}\r\n\r\n\tstatic get Empty():Match\r\n\t{\r\n\t\treturn EmptyMatch;\r\n\t}\r\n}\r\nconst EmptyMatch = new Match();\r\n\r\n\r\nexport default Regex;"]}