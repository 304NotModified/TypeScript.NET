{"version":3,"sources":["System/Tasks/TaskScheduler.ts"],"names":["flush","runSingle","requestFlush","TaskScheduler","TaskScheduler.defer","TaskScheduler.runAfterDeferred"],"mappings":"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","file":"System/Tasks/TaskScheduler.js","sourcesContent":["/*\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based on code from: https://github.com/kriskowal/q\n */\n\nimport Type from '../Types';\nimport LinkedList from \"../Collections/LinkedList\";\nimport Queue from \"../Collections/Queue\";\n\ndeclare module process\n{\n\texport function nextTick(callback:Function):void;\n\texport function toString():string;\n}\n\ninterface IDomain\n{\n\tenter():void;\n\texit():void;\n}\n\ninterface TaskQueueEntry\n{\n\ttask:Function;\n\tdomain?:IDomain;\n}\n\n\n\"use strict\";\n\nvar requestTick:()=>void;\nvar isNodeJS:boolean = false;\nvar flushing:boolean = false;\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\n\n\n\nfunction flush():void\n{\n\t/* jshint loopfunc: true */\n\tvar entry:ILinkedListNode<TaskQueueEntry>;\n\n\twhile(entry = immediateQueue.first)\n\t{\n\t\tlet e = entry.value, domain = e.domain;\n\t\tentry.remove();\n\t\tif(domain) domain.enter();\n\t\trunSingle(e.task, domain);\n\t}\n\n\tvar task:Function;\n\twhile(task = laterQueue.dequeue())\n\t{\n\t\trunSingle(task);\n\t}\n\n\tflushing = false;\n}\n\n\n// linked list of tasks.  Using a real linked list to allow for removal.\nvar immediateQueue:LinkedList<TaskQueueEntry> = new LinkedList<TaskQueueEntry>();\n\n// queue for late tasks, used by unhandled rejection tracking\nvar laterQueue:Queue<Function> = new Queue<Function>();\n\nfunction runSingle(task:Function, domain?:IDomain):void\n{\n\ttry\n\t{\n\t\ttask();\n\n\t}\n\tcatch(e)\n\t{\n\t\tif(isNodeJS)\n\t\t{\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\n\t\t\t// Re-throw them synchronously to interrupt flushing!\n\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\n\t\t\t// listening \"uncaughtException\" events (as domains does).\n\t\t\t// Continue in next event to avoid tick recursion.\n\t\t\tif(domain)\n\t\t\t{\n\t\t\t\tdomain.exit();\n\t\t\t}\n\t\t\tsetTimeout(flush, 0);\n\t\t\tif(domain)\n\t\t\t{\n\t\t\t\tdomain.enter();\n\t\t\t}\n\n\t\t\tthrow e;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// In browsers, uncaught exceptions are not fatal.\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\n\t\t\tsetTimeout(()=>\n\t\t\t{\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\tif(domain)\n\t{\n\t\tdomain.exit();\n\t}\n}\n\nfunction requestFlush():void {\n\tif(!flushing)\n\t{\n\t\tflushing = true;\n\t\trequestTick();\n\t}\n}\n\nmodule TaskScheduler {\n\n\n\texport function defer(task:Function, delay?:number):()=>boolean\n\t{\n\t\tif(Type.isNumber(delay,false) && delay>=0) {\n\n\t\t\tvar timeout:number = 0;\n\n\t\t\tvar cancel = ()=>{\n\t\t\t\tif(timeout) {\n\t\t\t\t\tclearTimeout(timeout);\n\t\t\t\t\ttimeout = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t};\n\n\t\t\ttimeout = setTimeout(()=>{\n\t\t\t\tcancel();\n\t\t\t\ttask();\n\t\t\t},delay);\n\n\t\t\treturn cancel;\n\t\t}\n\n\t\tvar entry = {\n\t\t\ttask:task,\n\t\t\tdomain:isNodeJS && (<any>process)['domain']\n\t\t};\n\n\t\timmediateQueue.add(entry);\n\n\t\trequestFlush();\n\n\t\treturn ()=>!!immediateQueue.remove(entry)\n\t}\n\n\n\t// runs a task after all other tasks have been run\n\t// this is useful for unhandled rejection tracking that needs to happen\n\t// after all `then`d tasks have been run.\n\texport function runAfterDeferred(task:Function):void\n\t{\n\t\tlaterQueue.enqueue(task);\n\t\trequestFlush();\n\t}\n\n}\n\n\n\nif(Type.isObject(process)\n\t&& process.toString()===\"[object process]\"\n\t&& process.nextTick)\n{\n\t// Ensure Q is in a real Node environment, with a `process.nextTick`.\n\t// To see through fake Node environments:\n\t// * Mocha test runner - exposes a `process` global without a `nextTick`\n\t// * Browserify - exposes a `process.nexTick` function that uses\n\t//   `setTimeout`. In this case `setImmediate` is preferred because\n\t//    it is faster. Browserify's `process.toString()` yields\n\t//   \"[object Object]\", while in a real Node environment\n\t//   `process.nextTick()` yields \"[object process]\".\n\tisNodeJS = true;\n\n\trequestTick = ()=>\n\t{\n\t\tprocess.nextTick(flush);\n\t};\n\n}\nelse if(typeof setImmediate===\"function\")\n{\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n\tif(typeof window!==\"undefined\")\n\t{\n\t\trequestTick = setImmediate.bind(window, flush);\n\t}\n\telse\n\t{\n\t\trequestTick = ()=>\n\t\t{\n\t\t\tsetImmediate(flush);\n\t\t};\n\t}\n\n}\nelse if(typeof MessageChannel!==\"undefined\")\n{\n\t// modern browsers\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\n\tvar channel = new MessageChannel();\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n\t// working message ports the first time a page loads.\n\tchannel.port1.onmessage = function()\n\t{\n\t\trequestTick = requestPortTick;\n\t\tchannel.port1.onmessage = flush;\n\t\tflush();\n\t};\n\tvar requestPortTick = ()=>\n\t{\n\t\t// Opera requires us to provide a message payload, regardless of\n\t\t// whether we use it.\n\t\tchannel.port2.postMessage(0);\n\t};\n\trequestTick = ()=>\n\t{\n\t\tsetTimeout(flush, 0);\n\t\trequestPortTick();\n\t};\n\n}\nelse\n{\n\t// old browsers\n\trequestTick = ()=>\n\t{\n\t\tsetTimeout(flush, 0);\n\t};\n}\n\nexport default TaskScheduler;\n"]}