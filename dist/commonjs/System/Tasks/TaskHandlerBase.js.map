{"version":3,"sources":["System/Tasks/TaskHandlerBase.js","System/Tasks/TaskHandlerBase.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;ACAA,IAAA,mBAAA,QAA2B,8BAA3B,CAAA;;IAKA;;;AAGC,aAHD,eAGC,GAAA;8BAHD,iBAGC;;2EAHD,6BAGC;;AAGC,cAAK,GAAL,GAAW,IAAX,CAHD;;KAAA;;iBAHD;;gCAoBS,OAAa;AAEpB,iBAAK,MAAL,GAFoB;AAGpB,gBAAG,MAAM,KAAN,KAAgB,QAAM,CAAN,EACnB;AACC,qBAAK,UAAL,GADD;aADA,MAIK,IAAG,SAAS,KAAT,CAAH,EACL;AACC,qBAAK,GAAL,GAAW,WAAW,gBAAgB,QAAhB,EAA0B,KAArC,EAA4C,IAA5C,CAAX,CADD;aADK;;;;qCAec;AAEnB,iBAAK,MAAL,GAFmB;;;;iCAKd;AAEL,gBAAI,KAAK,KAAK,GAAL,CAFJ;AAGL,gBAAG,EAAH,EACA;AACC,6BAAa,EAAb,EADD;AAEC,qBAAK,GAAL,GAAW,IAAX,CAFD;AAGC,uBAAO,IAAP,CAHD;aADA;AAMA,mBAAO,KAAP,CATK;;;;4BApCS;AACd,mBAAO,CAAC,CAAC,KAAK,GAAL,CADK;;;;iCAuBS,GAAiB;AAExC,cAAE,MAAF,GAFwC;AAGxC,cAAE,UAAF,GAHwC;;;;WAlC1C;EACQ,iBAAA,OAAA;;AA6DR,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;AD9BA,QAAQ,OAAR,GC8Be,eD9Bf","file":"System/Tasks/TaskHandlerBase.js","sourcesContent":["\"use strict\";\nconst DisposableBase_1 = require(\"../Disposable/DisposableBase\");\nclass TaskHandlerBase extends DisposableBase_1.default {\n    constructor() {\n        super();\n        this._id = null;\n    }\n    get isScheduled() {\n        return !!this._id;\n    }\n    execute(defer) {\n        this.cancel();\n        if (isNaN(defer) || defer < 0) {\n            this._onExecute();\n        }\n        else if (isFinite(defer)) {\n            this._id = setTimeout(TaskHandlerBase._handler, defer, this);\n        }\n    }\n    static _handler(d) {\n        d.cancel();\n        d._onExecute();\n    }\n    _onDispose() {\n        this.cancel();\n    }\n    cancel() {\n        var id = this._id;\n        if (id) {\n            clearTimeout(id);\n            this._id = null;\n            return true;\n        }\n        return false;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = TaskHandlerBase;\n","import DisposableBase from \"../Disposable/DisposableBase\";\r\n\r\n/**\r\n * A simple class for handling potentially repeated executions either deferred or immediate.\r\n */\r\nabstract class TaskHandlerBase\r\nextends DisposableBase implements ICancellable\r\n{\r\n\tconstructor()\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._id = null;\r\n\t}\r\n\r\n\tprotected _id:number;\r\n\r\n\tget isScheduled():boolean {\r\n\t\treturn !!this._id;\r\n\t}\r\n\r\n\t/**\r\n\t * Schedules/Reschedules triggering the task.\r\n\t * If defer is omitted it is called synchronously.\r\n\t * @param defer Optional time to wait until triggering.\r\n\t */\r\n\texecute(defer?:number):void\r\n\t{\r\n\t\tthis.cancel();\r\n\t\tif(isNaN(defer) || defer<0)\r\n\t\t{\r\n\t\t\tthis._onExecute();\r\n\t\t}\r\n\t\telse if(isFinite(defer))\r\n\t\t{\r\n\t\t\tthis._id = setTimeout(TaskHandlerBase._handler, defer, this);\r\n\t\t}\r\n\t}\r\n\r\n\t// Use a static function here to avoid recreating a new function every time.\r\n\tprivate static _handler(d:TaskHandlerBase):void\r\n\t{\r\n\t\td.cancel();\r\n\t\td._onExecute();\r\n\t}\r\n\r\n\tprotected abstract _onExecute():void;\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis.cancel();\r\n\t}\r\n\r\n\tcancel():boolean\r\n\t{\r\n\t\tvar id = this._id;\r\n\t\tif(id)\r\n\t\t{\r\n\t\t\tclearTimeout(id);\r\n\t\t\tthis._id = null;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport default TaskHandlerBase;"]}