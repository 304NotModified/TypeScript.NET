{"version":3,"sources":["System/Collections/LinkedList.ts","System/Collections/LinkedList.js"],"names":[],"mappings":"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","file":"System/Collections/LinkedList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n///<reference path=\"ILinkedList.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from '../Compare';\r\nimport * as TextUtility from '../Text/Utility';\r\nimport * as ArrayUtility from '../Collections/Array/Utility';\r\nimport * as Enumerator from './Enumeration/Enumerator';\r\nimport EnumeratorBase from './Enumeration/EnumeratorBase';\r\n\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\n\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n\r\nclass Node<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value?:T,\r\n\t\tpublic prev?:Node<T>,\r\n\t\tpublic next?:Node<T>)\r\n\t{\r\n\t}\r\n\r\n\texternal:ILinkedListNode<T>;\r\n\r\n\tassertDetached():void\r\n\t{\r\n\t\tif(this.next || this.prev)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(node:Node<T>, list:LinkedList<T>):ILinkedListNode<T>\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\r\n\tvar external:ILinkedListNode<T> = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):Node<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\r\n\t\t\t\"Cannot be null.\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tvar n:Node<T> = (<any>node)._node;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nexport default\r\nclass LinkedList<T>\r\nimplements ILinkedList<T>\r\n{\r\n\tprivate _first:Node<T>;\r\n\tprivate _last:Node<T>;\r\n\tprivate _count:number;\r\n\r\n\tconstructor(source?:IEnumerable<T>);\r\n\tconstructor(source?:IArray<T>);\r\n\tconstructor(source:any)\r\n\t{\r\n\t\tvar _ = this, c = 0, first:Node<T> = null, last:Node<T> = null;\r\n\t\tvar e = Enumerator.from<T>(source);\r\n\r\n\t\tif(e.moveNext())\r\n\t\t{\r\n\t\t\tfirst = last = new Node<T>(e.current);\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tlast = last.next = new Node<T>(e.current, last);\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\t_._first = first;\r\n\t\t_._last = last;\r\n\t\t_._count = c;\r\n\t}\r\n\r\n\t// #region Internals.\r\n\r\n\tprivate _addFirst(entry:T):Node<T>\r\n\t{\r\n\t\tvar _ = this, first = _._first;\r\n\t\tvar prev = new Node(entry, null, first);\r\n\t\tif(first)\r\n\t\t\tfirst.prev = prev;\r\n\t\telse\r\n\t\t\t_._last = prev;\r\n\r\n\t\t_._first = prev;\r\n\r\n\t\t_._count += 1;\r\n\r\n\t\treturn prev;\r\n\t}\r\n\r\n\tprivate _addLast(entry:T):Node<T>\r\n\t{\r\n\t\tvar _ = this, last = _._last;\r\n\t\tvar next = new Node(entry, last);\r\n\t\tif(last)\r\n\t\t\tlast.next = next;\r\n\t\telse\r\n\t\t\t_._first = next;\r\n\r\n\t\t_._last = next;\r\n\t\t_._count += 1;\r\n\r\n\t\treturn next;\r\n\t}\r\n\r\n\tprivate _addNodeBefore(n:Node<T>, inserting:Node<T>):void\r\n\t{\r\n\t\tinserting.assertDetached();\r\n\r\n\t\tinserting.next = n;\r\n\t\tinserting.prev = n.prev;\r\n\r\n\t\tn.prev.next = inserting;\r\n\t\tn.prev = inserting;\r\n\r\n\t\tthis._count += 1;\r\n\t}\r\n\r\n\r\n\tprivate _addNodeAfter(n:Node<T>, inserting:Node<T>):void\r\n\t{\r\n\t\tinserting.assertDetached();\r\n\r\n\t\tinserting.prev = n;\r\n\t\tinserting.next = n.next;\r\n\r\n\t\tn.next.prev = inserting;\r\n\t\tn.next = inserting;\r\n\r\n\t\tthis._count += 1;\r\n\t}\r\n\r\n\tprivate _findFirst(entry:T):Node<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    next   = this._first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):Node<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    prev   = this._last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.prev;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\t// #region IEnumerateEach<T>\r\n\tforEach(\r\n\t\taction:Predicate<T> | Action<T>,\r\n\t\tuseCopy:boolean = false):void\r\n\t{\r\n\t\tif(useCopy)\r\n\t\t{\r\n\t\t\tvar array = this.toArray();\r\n\t\t\tArrayUtility.forEach(array, action);\r\n\t\t\tarray.length = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar next = this._first, index:number = 0;\r\n\t\t\twhile(next && <any>action(next.value, index++)!==false)\r\n\t\t\t{\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this, current:Node<T>;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tcurrent = new Node(null, null, _._first);\r\n\t\t\t}, // Initialize anchor...\r\n\t\t\t(yielder)=>\r\n\t\t\t\t(current = current.next)\r\n\t\t\t\t\t? yielder.yieldReturn(current.value)\r\n\t\t\t\t\t: yielder.yieldBreak()\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region ICollection<T>\r\n\tget count():number\r\n\t{\r\n\t\treturn this._count;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(entry:T):void\r\n\t{\r\n\t\tthis._addLast(entry);\r\n\t}\r\n\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._first = null;\r\n\t\t_._last = null;\r\n\t\tvar count = _._count;\r\n\t\t_._count = 0;\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\tcontains(entry:T):boolean\r\n\t{\r\n\t\tvar found:boolean = false, equals = Values.areEqual;\r\n\t\tthis.forEach(e => !(found = equals(entry, e)));\r\n\t\treturn found;\r\n\t}\r\n\r\n\tcopyTo(array:T[], index:number = 0):T[]\r\n\t{\r\n\t\tthis.forEach(\r\n\t\t\t(entry, i) =>\r\n\t\t\t{\r\n\t\t\t\tarray[index + i] = entry;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar array = ArrayUtility.initialize<T>(this._count);\r\n\t\treturn this.copyTo(array);\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar node:Node<T> = _._findFirst(entry);\r\n\t\tif(node)\r\n\t\t{\r\n\t\t\tvar prev = node.prev, next = node.next;\r\n\t\t\tif(prev) prev.next = next;\r\n\t\t\telse _._first = next;\r\n\t\t\tif(next) next.prev = prev;\r\n\t\t\telse _._last = prev;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\r\n\t\treturn node!=null;\r\n\r\n\t}\r\n\r\n\tremove(entry:T):number\r\n\t{\r\n\t\tvar _ = this, removedCount:number = 0;\r\n\t\twhile(_.removeOnce(entry))\r\n\t\t{\r\n\t\t\t++removedCount;\r\n\t\t}\r\n\t\treturn removedCount;\r\n\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\tget first():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._first, this);\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._last, this);\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\tprivate _getNodeAt(index:number):Node<T>\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\r\n\t\t\t\t'index', index, 'Is less than zero.');\r\n\r\n\t\tif(index>=this._count)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\r\n\t\t\t\t'index', index, 'Is greater than count.');\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && index<i++)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tgetValueAt(index:number):T\r\n\t{\r\n\t\treturn this._getNodeAt(index).value;\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):void\r\n\t{\r\n\t\tthis._addFirst(entry);\r\n\t}\r\n\r\n\taddLast(entry:T):void\r\n\t{\r\n\t\tthis._addLast(entry);\r\n\t}\r\n\r\n\tremoveFirst():void\r\n\t{\r\n\t\tvar _ = this, first = _._first;\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tvar next = first.next;\r\n\t\t\t_._first = next;\r\n\t\t\tif(next) // Might have been the last.\r\n\t\t\t\tnext.prev = null;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveLast():void\r\n\t{\r\n\t\tvar _ = this, last = _._last;\r\n\t\tif(last)\r\n\t\t{\r\n\t\t\tvar prev = last.prev;\r\n\t\t\t_._last = prev;\r\n\t\t\tif(prev) // Might have been the first.\r\n\t\t\t\tprev.next = null;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar n:Node<T> = getInternal(node, _);\r\n\t\tvar prev = n.prev, next = n.next, a:boolean = false, b:boolean = false;\r\n\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==n) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.prev = prev;\r\n\t\telse if(_._last==n) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn !a && !b;\r\n\r\n\t}\r\n\r\n\taddBefore(node:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._addNodeBefore(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tnew Node(entry)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\taddAfter(node:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._addNodeAfter(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tnew Node(entry)\r\n\t\t);\r\n\t}\r\n\r\n\taddNodeBefore(node:ILinkedListNode<T>, before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._addNodeBefore(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tgetInternal(before, this)\r\n\t\t);\r\n\t}\r\n\r\n\taddNodeAfter(node:ILinkedListNode<T>, after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._addNodeAfter(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tgetInternal(after, this)\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _node:Node<T>)\r\n\t{\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._node.prev, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._node.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this._node.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis._node.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):void\r\n\t{\r\n\t\tthis._list.addBefore(this, entry);\r\n\t}\r\n\r\n\taddAfter(entry:T):void\r\n\t{\r\n\t\tthis._list.addAfter(this, entry);\r\n\t}\r\n\r\n\taddNodeBefore(before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeBefore(this, before);\r\n\t}\r\n\r\n\taddNodeAfter(after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeAfter(this, after);\r\n\t}\r\n\r\n\tremove():void\r\n\t{\r\n\t\tthis._list.removeNode(this);\r\n\t}\r\n\r\n}\r\n\r\n","/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst Values = require('../Compare');\nconst TextUtility = require('../Text/Utility');\nconst ArrayUtility = require('../Collections/Array/Utility');\nconst Enumerator = require('./Enumeration/Enumerator');\nconst EnumeratorBase_1 = require('./Enumeration/EnumeratorBase');\nconst InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\nconst ArgumentException_1 = require('../Exceptions/ArgumentException');\nconst ArgumentNullException_1 = require('../Exceptions/ArgumentNullException');\nconst ArgumentOutOfRangeException_1 = require('../Exceptions/ArgumentOutOfRangeException');\nclass Node {\n    constructor(value, prev, next) {\n        this.value = value;\n        this.prev = prev;\n        this.next = next;\n    }\n    assertDetached() {\n        if (this.next || this.prev)\n            throw new InvalidOperationException_1.default(\"Adding a node that is already placed.\");\n    }\n}\nfunction ensureExternal(node, list) {\n    if (!node)\n        return null;\n    var external = node.external;\n    if (!external)\n        node.external = external = new LinkedListNode(list, node);\n    return external;\n}\nfunction getInternal(node, list) {\n    if (!node)\n        throw new ArgumentNullException_1.default(\"Cannot be null.\");\n    if (node.list != list)\n        throw new InvalidOperationException_1.default(\"Provided node does not belong to this list.\");\n    var n = node._node;\n    if (!n)\n        throw new InvalidOperationException_1.default(\"Provided node is not valid.\");\n    return n;\n}\nclass LinkedList {\n    constructor(source) {\n        var _ = this, c = 0, first = null, last = null;\n        var e = Enumerator.from(source);\n        if (e.moveNext()) {\n            first = last = new Node(e.current);\n            ++c;\n        }\n        while (e.moveNext()) {\n            last = last.next = new Node(e.current, last);\n            ++c;\n        }\n        _._first = first;\n        _._last = last;\n        _._count = c;\n    }\n    _addFirst(entry) {\n        var _ = this, first = _._first;\n        var prev = new Node(entry, null, first);\n        if (first)\n            first.prev = prev;\n        else\n            _._last = prev;\n        _._first = prev;\n        _._count += 1;\n        return prev;\n    }\n    _addLast(entry) {\n        var _ = this, last = _._last;\n        var next = new Node(entry, last);\n        if (last)\n            last.next = next;\n        else\n            _._first = next;\n        _._last = next;\n        _._count += 1;\n        return next;\n    }\n    _addNodeBefore(n, inserting) {\n        inserting.assertDetached();\n        inserting.next = n;\n        inserting.prev = n.prev;\n        n.prev.next = inserting;\n        n.prev = inserting;\n        this._count += 1;\n    }\n    _addNodeAfter(n, inserting) {\n        inserting.assertDetached();\n        inserting.prev = n;\n        inserting.next = n.next;\n        n.next.prev = inserting;\n        n.next = inserting;\n        this._count += 1;\n    }\n    _findFirst(entry) {\n        var equals = Values.areEqual, next = this._first;\n        while (next) {\n            if (equals(entry, next.value))\n                return next;\n            next = next.next;\n        }\n        return null;\n    }\n    _findLast(entry) {\n        var equals = Values.areEqual, prev = this._last;\n        while (prev) {\n            if (equals(entry, prev.value))\n                return prev;\n            prev = prev.prev;\n        }\n        return null;\n    }\n    forEach(action, useCopy = false) {\n        if (useCopy) {\n            var array = this.toArray();\n            ArrayUtility.forEach(array, action);\n            array.length = 0;\n        }\n        else {\n            var next = this._first, index = 0;\n            while (next && action(next.value, index++) !== false) {\n                next = next.next;\n            }\n        }\n    }\n    getEnumerator() {\n        var _ = this, current;\n        return new EnumeratorBase_1.default(() => {\n            current = new Node(null, null, _._first);\n        }, (yielder) => (current = current.next)\n            ? yielder.yieldReturn(current.value)\n            : yielder.yieldBreak());\n    }\n    get count() {\n        return this._count;\n    }\n    get isReadOnly() {\n        return false;\n    }\n    add(entry) {\n        this._addLast(entry);\n    }\n    clear() {\n        var _ = this;\n        _._first = null;\n        _._last = null;\n        var count = _._count;\n        _._count = 0;\n        return count;\n    }\n    contains(entry) {\n        var found = false, equals = Values.areEqual;\n        this.forEach(e => !(found = equals(entry, e)));\n        return found;\n    }\n    copyTo(array, index = 0) {\n        this.forEach((entry, i) => {\n            array[index + i] = entry;\n        });\n        return array;\n    }\n    toArray() {\n        var array = ArrayUtility.initialize(this._count);\n        return this.copyTo(array);\n    }\n    removeOnce(entry) {\n        var _ = this;\n        var node = _._findFirst(entry);\n        if (node) {\n            var prev = node.prev, next = node.next;\n            if (prev)\n                prev.next = next;\n            else\n                _._first = next;\n            if (next)\n                next.prev = prev;\n            else\n                _._last = prev;\n            _._count -= 1;\n        }\n        return node != null;\n    }\n    remove(entry) {\n        var _ = this, removedCount = 0;\n        while (_.removeOnce(entry)) {\n            ++removedCount;\n        }\n        return removedCount;\n    }\n    get first() {\n        return ensureExternal(this._first, this);\n    }\n    get last() {\n        return ensureExternal(this._last, this);\n    }\n    _getNodeAt(index) {\n        if (index < 0)\n            throw new ArgumentOutOfRangeException_1.default('index', index, 'Is less than zero.');\n        if (index >= this._count)\n            throw new ArgumentOutOfRangeException_1.default('index', index, 'Is greater than count.');\n        var next = this._first, i = 0;\n        while (next && index < i++) {\n            next = next.next;\n        }\n        return next;\n    }\n    getValueAt(index) {\n        return this._getNodeAt(index).value;\n    }\n    getNodeAt(index) {\n        return ensureExternal(this._getNodeAt(index), this);\n    }\n    find(entry) {\n        return ensureExternal(this._findFirst(entry), this);\n    }\n    findLast(entry) {\n        return ensureExternal(this._findLast(entry), this);\n    }\n    addFirst(entry) {\n        this._addFirst(entry);\n    }\n    addLast(entry) {\n        this._addLast(entry);\n    }\n    removeFirst() {\n        var _ = this, first = _._first;\n        if (first) {\n            var next = first.next;\n            _._first = next;\n            if (next)\n                next.prev = null;\n            _._count -= 1;\n        }\n    }\n    removeLast() {\n        var _ = this, last = _._last;\n        if (last) {\n            var prev = last.prev;\n            _._last = prev;\n            if (prev)\n                prev.next = null;\n            _._count -= 1;\n        }\n    }\n    removeNode(node) {\n        var _ = this;\n        var n = getInternal(node, _);\n        var prev = n.prev, next = n.next, a = false, b = false;\n        if (prev)\n            prev.next = next;\n        else if (_._first == n)\n            _._first = next;\n        else\n            a = true;\n        if (next)\n            next.prev = prev;\n        else if (_._last == n)\n            _._last = prev;\n        else\n            b = true;\n        if (a !== b) {\n            throw new ArgumentException_1.default('node', TextUtility.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\n        }\n        return !a && !b;\n    }\n    addBefore(node, entry) {\n        this._addNodeBefore(getInternal(node, this), new Node(entry));\n    }\n    addAfter(node, entry) {\n        this._addNodeAfter(getInternal(node, this), new Node(entry));\n    }\n    addNodeBefore(node, before) {\n        this._addNodeBefore(getInternal(node, this), getInternal(before, this));\n    }\n    addNodeAfter(node, after) {\n        this._addNodeAfter(getInternal(node, this), getInternal(after, this));\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedList;\nclass LinkedListNode {\n    constructor(_list, _node) {\n        this._list = _list;\n        this._node = _node;\n    }\n    get list() {\n        return this._list;\n    }\n    get previous() {\n        return ensureExternal(this._node.prev, this._list);\n    }\n    get next() {\n        return ensureExternal(this._node.next, this._list);\n    }\n    get value() {\n        return this._node.value;\n    }\n    set value(v) {\n        this._node.value = v;\n    }\n    addBefore(entry) {\n        this._list.addBefore(this, entry);\n    }\n    addAfter(entry) {\n        this._list.addAfter(this, entry);\n    }\n    addNodeBefore(before) {\n        this._list.addNodeBefore(this, before);\n    }\n    addNodeAfter(after) {\n        this._list.addNodeAfter(this, after);\n    }\n    remove() {\n        this._list.removeNode(this);\n    }\n}\n"]}