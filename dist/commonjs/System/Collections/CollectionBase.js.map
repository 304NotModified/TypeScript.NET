{"version":3,"sources":["System/Collections/CollectionBase.js","System/Collections/CollectionBase.ts"],"names":[],"mappings":"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","file":"System/Collections/CollectionBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Enumerator_1 = require(\"./Enumeration/Enumerator\");\nconst Compare_1 = require(\"../Compare\");\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nconst InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\nconst DisposableBase_1 = require(\"../Disposable/DisposableBase\");\nconst Types_1 = require(\"../Types\");\nconst NAME = \"CollectionBase\", CMDC = \"Cannot modify a disposed collection.\", CMRO = \"Cannot modify a read-only collection.\", RESOLVE = \"resolve\", LINQ_PATH = \"../../System.Linq/Linq\";\nclass CollectionBase extends DisposableBase_1.DisposableBase {\n    constructor(source, _equalityComparer = Compare_1.areEqual) {\n        super();\n        this._equalityComparer = _equalityComparer;\n        var _ = this;\n        _._disposableObjectName = NAME;\n        _._importEntries(source);\n        _._updateRecursion = 0;\n        _._modifiedCount = 0;\n        _._version = 0;\n    }\n    get count() {\n        return this.getCount();\n    }\n    getIsReadOnly() {\n        return false;\n    }\n    get isReadOnly() {\n        return this.getIsReadOnly();\n    }\n    assertModifiable() {\n        this.throwIfDisposed(CMDC);\n        if (this.getIsReadOnly())\n            throw new InvalidOperationException_1.InvalidOperationException(CMRO);\n    }\n    assertVersion(version) {\n        if (version != this._version)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Collection was modified.\");\n    }\n    _onModified() { }\n    _signalModification(increment) {\n        var _ = this;\n        if (increment)\n            _._modifiedCount++;\n        if (_._modifiedCount && !this._updateRecursion) {\n            _._modifiedCount = 0;\n            _._version++;\n            try {\n                _._onModified();\n            }\n            catch (ex) {\n                console.error(ex);\n            }\n            return true;\n        }\n        return false;\n    }\n    _incrementModified() { this._modifiedCount++; }\n    get isUpdating() { return this._updateRecursion != 0; }\n    handleUpdate(closure) {\n        if (!closure)\n            return false;\n        var _ = this;\n        _.assertModifiable();\n        _._updateRecursion++;\n        var updated = false;\n        try {\n            if (updated = closure())\n                _._modifiedCount++;\n        }\n        finally {\n            _._updateRecursion--;\n        }\n        _._signalModification();\n        return updated;\n    }\n    add(entry) {\n        var _ = this;\n        _.assertModifiable();\n        _._updateRecursion++;\n        try {\n            if (_._addInternal(entry))\n                _._modifiedCount++;\n        }\n        finally {\n            _._updateRecursion--;\n        }\n        _._signalModification();\n    }\n    remove(entry, max = Infinity) {\n        var _ = this;\n        _.assertModifiable();\n        _._updateRecursion++;\n        var n;\n        try {\n            if (n = _._removeInternal(entry, max))\n                _._modifiedCount++;\n        }\n        finally {\n            _._updateRecursion--;\n        }\n        _._signalModification();\n        return n;\n    }\n    clear() {\n        var _ = this;\n        _.assertModifiable();\n        _._updateRecursion++;\n        var n;\n        try {\n            if (n = _._clearInternal())\n                _._modifiedCount++;\n        }\n        finally {\n            _._updateRecursion--;\n        }\n        _._signalModification();\n        return n;\n    }\n    _onDispose() {\n        super._onDispose();\n        this._clearInternal();\n        this._version = 0;\n        this._updateRecursion = 0;\n        this._modifiedCount = 0;\n        var l = this._linq;\n        this._linq = null;\n        if (l)\n            l.dispose();\n    }\n    _importEntries(entries) {\n        var added = 0;\n        if (entries) {\n            if (Array.isArray(entries)) {\n                for (let e of entries) {\n                    if (this._addInternal(e))\n                        added++;\n                }\n            }\n            else {\n                Enumerator_1.forEach(entries, e => {\n                    if (this._addInternal(e))\n                        added++;\n                });\n            }\n        }\n        return added;\n    }\n    importEntries(entries) {\n        var _ = this;\n        _.assertModifiable();\n        _._updateRecursion++;\n        var n;\n        try {\n            if (n = _._importEntries(entries))\n                _._modifiedCount++;\n        }\n        finally {\n            _._updateRecursion--;\n        }\n        _._signalModification();\n        return n;\n    }\n    contains(entry) {\n        if (!this.getCount())\n            return false;\n        var found = false, equals = this._equalityComparer;\n        this.forEach(e => !(found = equals(entry, e)));\n        return found;\n    }\n    forEach(action, useCopy) {\n        if (useCopy) {\n            var a = this.toArray();\n            try {\n                return Enumerator_1.forEach(a, action);\n            }\n            finally {\n                a.length = 0;\n            }\n        }\n        else {\n            return Enumerator_1.forEach(this.getEnumerator(), action);\n        }\n    }\n    copyTo(target, index = 0) {\n        if (!target)\n            throw new ArgumentNullException_1.ArgumentNullException('target');\n        var count = this.getCount(), newLength = count + index;\n        if (target.length < newLength)\n            target.length = newLength;\n        var e = this.getEnumerator();\n        while (e.moveNext()) {\n            target[index++] = e.current;\n        }\n        return target;\n    }\n    toArray() {\n        var count = this.getCount();\n        return this.copyTo(count > 65536 ? new Array(count) : []);\n    }\n    get linq() {\n        if (Types_1.Type.hasMember(require, RESOLVE) && require.length == 1) {\n            var e = this._linq;\n            if (!e)\n                this._linq = e = require(LINQ_PATH).default.from(this);\n            return e;\n        }\n        else {\n            throw \".linq currently only supported within CommonJS.\\nImport System.Linq/Linq and use Enumerable.from(e) instead.\";\n        }\n    }\n}\nexports.CollectionBase = CollectionBase;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = CollectionBase;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {forEach} from \"./Enumeration/Enumerator\";\r\nimport {areEqual} from \"../Compare\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {ICollection} from \"./ICollection\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {IEnumerateEach} from \"./Enumeration/IEnumerateEach\";\r\nimport {EqualityComparison, Predicate, Action, Comparison, Selector} from \"../FunctionTypes\";\r\nimport {IEnumerableOrArray} from \"./IEnumerableOrArray\";\r\nimport {IArray} from \"./Array/IArray\";\r\nimport {Type} from \"../Types\";\r\nimport {IEnumerable} from \"./Enumeration/IEnumerable\";\r\nimport {Comparable} from \"../IComparable\";\r\nimport {IDictionary, IMap} from \"./Dictionaries/IDictionary\";\r\n\r\n//noinspection SpellCheckingInspection\r\nconst NAME      = \"CollectionBase\",\r\n      CMDC      = \"Cannot modify a disposed collection.\",\r\n      CMRO      = \"Cannot modify a read-only collection.\",\r\n      RESOLVE   = \"resolve\",\r\n      LINQ_PATH = \"../../System.Linq/Linq\";\r\n\r\nexport abstract class CollectionBase<T>\r\nextends DisposableBase implements ICollection<T>, IEnumerateEach<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tsource?:IEnumerableOrArray<T>,\r\n\t\tprotected _equalityComparer:EqualityComparison<T> = areEqual)\r\n\t{\r\n\t\tsuper();\r\n\t\tvar _ = this;\r\n\t\t_._disposableObjectName = NAME;\r\n\t\t_._importEntries(source);\r\n\t\t_._updateRecursion = 0;\r\n\t\t_._modifiedCount = 0;\r\n\t\t_._version = 0;\r\n\t}\r\n\r\n\r\n\tprotected abstract getCount():number;\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this.getCount();\r\n\t}\r\n\r\n\tprotected getIsReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn this.getIsReadOnly();\r\n\t}\r\n\r\n\tprotected assertModifiable():void\r\n\t{\r\n\t\tthis.throwIfDisposed(CMDC);\r\n\t\tif(this.getIsReadOnly())\r\n\t\t\tthrow new InvalidOperationException(CMRO);\r\n\t}\r\n\r\n\tprotected _version:number; // Provides an easy means of tracking changes and invalidating enumerables.\r\n\tassertVersion(version:number):void\r\n\t{\r\n\t\tif(version!=this._version)\r\n\t\t\tthrow new InvalidOperationException(\"Collection was modified.\");\r\n\t}\r\n\r\n\t/*\r\n\t * Note: Avoid changing modified count by any means but ++;\r\n\t * If setting modified count by the result of a closure it may be a negative number or NaN and ruin the pattern.\r\n\t */\r\n\tprivate _modifiedCount:number;\r\n\tprivate _updateRecursion:number;\r\n\r\n\tprotected _onModified():void {}\r\n\r\n\tprotected _signalModification(increment?:boolean):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(increment) _._modifiedCount++;\r\n\t\tif(_._modifiedCount && !this._updateRecursion)\r\n\t\t{\r\n\t\t\t_._modifiedCount = 0;\r\n\t\t\t_._version++;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\t_._onModified();\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\t// Avoid fatal errors which may have been caused by consumer.\r\n\t\t\t\tconsole.error(ex);\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _incrementModified():void { this._modifiedCount++; }\r\n\r\n\tget isUpdating():boolean { return this._updateRecursion!=0; }\r\n\r\n\t/**\r\n\t * Takes a closure that if returning true will propagate an update signal.\r\n\t * Multiple update operations can be occurring at once or recursively and the onModified signal will only occur once they're done.\r\n\t * @param closure\r\n\t * @returns {boolean}\r\n\t */\r\n\thandleUpdate(closure?:() => boolean):boolean\r\n\t{\r\n\t\tif(!closure) return false;\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._updateRecursion++;\r\n\t\tvar updated:boolean = false;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif(updated = closure())\r\n\t\t\t\t_._modifiedCount++;\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\t_._updateRecursion--;\r\n\t\t}\r\n\r\n\t\t_._signalModification();\r\n\r\n\t\treturn updated;\r\n\t}\r\n\r\n\tprotected abstract _addInternal(entry:T):boolean;\r\n\r\n\t/*\r\n\t * Note: for a slight amount more code, we avoid creating functions/closures.\r\n\t * Calling handleUpdate is the correct pattern, but if possible avoid creating another function scope.\r\n\t */\r\n\r\n\tadd(entry:T):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._updateRecursion++;\r\n\r\n\t\ttry\r\n\t\t{ if(_._addInternal(entry)) _._modifiedCount++; }\r\n\t\tfinally\r\n\t\t{ _._updateRecursion--; }\r\n\r\n\t\t_._signalModification();\r\n\t}\r\n\r\n\tprotected abstract _removeInternal(entry:T, max?:number):number;\r\n\r\n\tremove(entry:T, max:number = Infinity):number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._updateRecursion++;\r\n\r\n\t\tvar n:number;\r\n\t\ttry\r\n\t\t{ if(n = _._removeInternal(entry, max)) _._modifiedCount++; }\r\n\t\tfinally\r\n\t\t{ _._updateRecursion--; }\r\n\r\n\t\t_._signalModification();\r\n\t\treturn n;\r\n\t}\r\n\r\n\tprotected abstract _clearInternal():number;\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._updateRecursion++;\r\n\r\n\t\tvar n:number;\r\n\t\ttry\r\n\t\t{ if(n = _._clearInternal()) _._modifiedCount++; }\r\n\t\tfinally\r\n\t\t{ _._updateRecursion--; }\r\n\r\n\t\t_._signalModification();\r\n\r\n\t\treturn n;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._clearInternal();\r\n\t\tthis._version = 0;\r\n\t\tthis._updateRecursion = 0;\r\n\t\tthis._modifiedCount = 0;\r\n\t\tvar l = this._linq;\r\n\t\tthis._linq = null;\r\n\t\tif(l) l.dispose();\r\n\t}\r\n\r\n\tprotected _importEntries(entries:IEnumerableOrArray<T>):number\r\n\t{\r\n\t\tvar added = 0;\r\n\t\tif(entries)\r\n\t\t{\r\n\t\t\tif(Array.isArray(entries))\r\n\t\t\t{\r\n\t\t\t\t// Optimize for avoiding a new closure.\r\n\t\t\t\tfor(let e of entries)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(this._addInternal(e)) added++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tforEach(entries, e=>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(this._addInternal(e)) added++;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn added;\r\n\t}\r\n\r\n\timportEntries(entries:IEnumerableOrArray<T>):number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\t\t_._updateRecursion++;\r\n\r\n\t\tvar n:number;\r\n\t\ttry\r\n\t\t{ if(n = _._importEntries(entries)) _._modifiedCount++; }\r\n\t\tfinally\r\n\t\t{ _._updateRecursion--; }\r\n\r\n\t\t_._signalModification();\r\n\t\treturn n;\r\n\t}\r\n\r\n\t// Fundamentally the most important part of the collection.\r\n\tabstract getEnumerator():IEnumerator<T>;\r\n\r\n\tcontains(entry:T):boolean\r\n\t{\r\n\t\tif(!this.getCount()) return false;\r\n\t\tvar found:boolean = false, equals = this._equalityComparer;\r\n\t\tthis.forEach(e => !(found = equals(entry, e)));\r\n\t\treturn found;\r\n\t}\r\n\r\n\tforEach(action:Predicate<T>|Action<T>, useCopy?:boolean):number\r\n\t{\r\n\t\tif(useCopy)\r\n\t\t{\r\n\t\t\tvar a = this.toArray();\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\treturn forEach(a, action);\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\ta.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn forEach(this.getEnumerator(), action);\r\n\t\t}\r\n\t}\r\n\r\n\tcopyTo<TTarget extends IArray<T>>(\r\n\t\ttarget:TTarget,\r\n\t\tindex:number = 0):TTarget\r\n\t{\r\n\t\tif(!target) throw new ArgumentNullException('target');\r\n\r\n\t\tvar count = this.getCount(), newLength = count + index;\r\n\t\tif(target.length<newLength) target.length = newLength;\r\n\r\n\t\tvar e = this.getEnumerator();\r\n\t\twhile(e.moveNext()) // Disposes when finished.\r\n\t\t{\r\n\t\t\ttarget[index++] = e.current;\r\n\t\t}\r\n\t\treturn target;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar count = this.getCount();\r\n\t\treturn this.copyTo(count>65536 ? new Array<T>(count) : []);\r\n\t}\r\n\r\n\tprivate _linq:Enumerable<T>;\r\n\tget linq():Enumerable<T>\r\n\t{\r\n\t\tif(Type.hasMember(require, RESOLVE) && require.length==1)\r\n\t\t{\r\n\t\t\tvar e = this._linq;\r\n\t\t\tif(!e) this._linq = e = require(LINQ_PATH).default.from(this);\r\n\t\t\treturn e;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow \".linq currently only supported within CommonJS.\\nImport System.Linq/Linq and use Enumerable.from(e) instead.\";\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\ndeclare var require:any;\r\n\r\nexport default CollectionBase;\r\n\r\nexport declare const enum EnumerableAction {\r\n\tBreak  = 0,\r\n\tReturn = 1,\r\n\tSkip   = 2,\r\n}\r\nexport declare class InfiniteEnumerable<T> extends DisposableBase implements IEnumerable<T>\r\n{\r\n\tisEndless:boolean;\r\n\r\n\tgetEnumerator():IEnumerator<T>;\r\n\r\n\tasEnumerable():InfiniteEnumerable<T>;\r\n\r\n\tdoAction(\r\n\t\taction:Action<T> | Predicate<T> | Selector<T, number> | Selector<T, EnumerableAction>,\r\n\t\tinitializer?:() => void,\r\n\t\tisEndless?:boolean):InfiniteEnumerable<T>;\r\n\r\n\tforce():void;\r\n\r\n\tskip(count:number):InfiniteEnumerable<T>;\r\n\r\n\ttake(count:number):FiniteEnumerable<T>;\r\n\r\n\telementAt(index:number):T;\r\n\r\n\telementAtOrDefault(index:number, defaultValue?:T):T;\r\n\r\n\tfirst():T;\r\n\r\n\tfirstOrDefault(defaultValue?:T):T;\r\n\r\n\tsingle():T;\r\n\r\n\tsingleOrDefault(defaultValue?:T):T;\r\n\r\n\tany():boolean;\r\n\r\n\tisEmpty():boolean;\r\n\r\n\ttraverseBreadthFirst(childrenSelector:(element:T) => IEnumerableOrArray<T>):Enumerable<T>;\r\n\ttraverseBreadthFirst<TNode>(childrenSelector:(element:T | TNode) => IEnumerableOrArray<TNode>):Enumerable<TNode>;\r\n\ttraverseBreadthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>,\r\n\t\tresultSelector?:(element:T, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\ttraverseBreadthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T | TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector?:(element:TNode, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseDepthFirst(childrenSelector:(element:T) => IEnumerableOrArray<T>):Enumerable<T>;\r\n\ttraverseDepthFirst<TNode>(childrenSelector:(element:T | TNode) => IEnumerableOrArray<TNode>):Enumerable<TNode>;\r\n\ttraverseDepthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>,\r\n\t\tresultSelector?:(element:T, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\ttraverseDepthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T | TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector?:(element:TNode, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\tflatten():Enumerable<any>;\r\n\r\n\tpairwise<TSelect>(selector:(prev:T, current:T) => TSelect):Enumerable<TSelect>;\r\n\r\n\tscan(func:(a:T, b:T) => T, seed?:T):Enumerable<T>;\r\n\r\n\tselect<TResult>(selector:Selector<T, TResult>):InfiniteEnumerable<TResult>;\r\n\r\n\tselectMany<TResult>(collectionSelector:Selector<T, IEnumerableOrArray<TResult>>):InfiniteEnumerable<TResult>;\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector:(collection:T, element:TElement) => TResult):InfiniteEnumerable<TResult>;\r\n\r\n\tchoose():InfiniteEnumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):InfiniteEnumerable<TResult>;\r\n\r\n\twhere(predicate:Predicate<T>):InfiniteEnumerable<T>;\r\n\r\n\tofType<TType>(\r\n\t\ttype:{\r\n\t\t\tnew (...params:any[]):TType;\r\n\t\t}):InfiniteEnumerable<TType>;\r\n\r\n\texcept<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):InfiniteEnumerable<T>;\r\n\r\n\tdistinct(compareSelector?:(value:T) => T):InfiniteEnumerable<T>;\r\n\r\n\tdistinctUntilChanged<TCompare>(compareSelector?:Selector<T, TCompare>):InfiniteEnumerable<T>;\r\n\r\n\tdefaultIfEmpty(defaultValue?:T):Enumerable<T>;\r\n\r\n\tzip<TSecond, TResult>(\r\n\t\tsecond:IEnumerableOrArray<TSecond>,\r\n\t\tresultSelector:(first:T, second:TSecond, index?:number) => TResult):Enumerable<TResult>;\r\n\r\n\tzipMultiple<TSecond, TResult>(\r\n\t\tsecond:IArray<IEnumerableOrArray<TSecond>>,\r\n\t\tresultSelector:(first:T, second:TSecond, index?:number) => TResult):Enumerable<TResult>;\r\n\r\n\tjoin<TInner, TKey, TResult, TCompare>(\r\n\t\tinner:IEnumerableOrArray<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner) => TResult,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<TResult>;\r\n\r\n\tgroupJoin<TInner, TKey, TResult, TCompare>(\r\n\t\tinner:IEnumerableOrArray<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner[]) => TResult,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<TResult>;\r\n\r\n\tmerge(enumerables:IArray<IEnumerableOrArray<T>>):InfiniteEnumerable<T>;\r\n\r\n\tconcat(...enumerables:Array<IEnumerableOrArray<T>>):InfiniteEnumerable<T>;\r\n\r\n\tunion<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):Enumerable<T>;\r\n\r\n\tinsertAt(index:number, other:IEnumerableOrArray<T>):Enumerable<T>;\r\n\r\n\talternateMultiple(sequence:IEnumerableOrArray<T>):Enumerable<T>;\r\n\r\n\talternateSingle(value:T):Enumerable<T>;\r\n\r\n\talternate(...sequence:T[]):Enumerable<T>;\r\n\r\n\tcatchError(handler:(e:any) => void):InfiniteEnumerable<T>;\r\n\r\n\tfinallyAction(action:() => void):InfiniteEnumerable<T>;\r\n\r\n\tbuffer(size:number):InfiniteEnumerable<T[]>;\r\n\r\n\tshare():InfiniteEnumerable<T>;\r\n}\r\nexport declare class Enumerable<T> extends InfiniteEnumerable<T>\r\n{\r\n\tdoAction(\r\n\t\taction:Action<T> | Predicate<T> | Selector<T, number> | Selector<T, EnumerableAction>,\r\n\t\tinitializer?:() => void,\r\n\t\tisEndless?:boolean):Enumerable<T>;\r\n\r\n\tskip(count:number):Enumerable<T>;\r\n\r\n\tskipWhile(predicate:Predicate<T>):Enumerable<T>;\r\n\r\n\ttakeWhile(predicate:Predicate<T>):Enumerable<T>;\r\n\r\n\ttakeUntil(predicate:Predicate<T>, includeUntilValue?:boolean):Enumerable<T>;\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void;\r\n\r\n\ttoArray(predicate?:Predicate<T>):T[];\r\n\r\n\tcopyTo(target:T[], index?:number, count?:number):T[];\r\n\r\n\ttoLookup<TKey, TValue, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TValue>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):ILookup<TKey, TValue>;\r\n\r\n\ttoMap<TResult>(\r\n\t\tkeySelector:Selector<T, string>,\r\n\t\telementSelector:Selector<T, TResult>):IMap<TResult>;\r\n\r\n\ttoDictionary<TKey, TValue, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TValue>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):IDictionary<TKey, TValue>;\r\n\r\n\ttoJoinedString(separator?:string, selector?:Selector<T, string>):string;\r\n\r\n\ttakeExceptLast(count?:number):Enumerable<T>;\r\n\r\n\tskipToLast(count:number):Enumerable<T>;\r\n\r\n\twhere(predicate:Predicate<T>):Enumerable<T>;\r\n\r\n\tselect<TResult>(selector:Selector<T, TResult>):Enumerable<TResult>;\r\n\r\n\tselectMany<TResult>(collectionSelector:Selector<T, IEnumerableOrArray<TResult>>):Enumerable<TResult>;\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector:(collection:T, element:TElement) => TResult):Enumerable<TResult>;\r\n\r\n\tchoose():Enumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):Enumerable<TResult>;\r\n\r\n\treverse():Enumerable<T>;\r\n\r\n\tshuffle():Enumerable<T>;\r\n\r\n\tcount(predicate?:Predicate<T>):number;\r\n\r\n\tall(predicate:Predicate<T>):boolean;\r\n\r\n\tevery(predicate:Predicate<T>):boolean;\r\n\r\n\tany(predicate?:Predicate<T>):boolean;\r\n\r\n\tsome(predicate:Predicate<T>):boolean;\r\n\r\n\tcontains<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):boolean;\r\n\r\n\tindexOf<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):number;\r\n\r\n\tlastIndexOf<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):number;\r\n\r\n\tmerge(enumerables:IArray<IEnumerableOrArray<T>>):Enumerable<T>;\r\n\r\n\tconcat(...enumerables:Array<IEnumerableOrArray<T>>):Enumerable<T>;\r\n\r\n\tintersect<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):Enumerable<T>;\r\n\r\n\tsequenceEqual(second:IEnumerableOrArray<T>, equalityComparer?:EqualityComparison<T>):boolean;\r\n\r\n\tofType<TType>(\r\n\t\ttype:{\r\n\t\t\tnew (...params:any[]):TType;\r\n\t\t}):Enumerable<TType>;\r\n\r\n\texcept<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):Enumerable<T>;\r\n\r\n\tdistinct(compareSelector?:(value:T) => T):Enumerable<T>;\r\n\r\n\tdistinctUntilChanged<TCompare>(compareSelector?:Selector<T, TCompare>):Enumerable<T>;\r\n\r\n\torderBy<TKey extends Comparable>(keySelector?:Selector<T, TKey>):IOrderedEnumerable<T>;\r\n\r\n\torderUsing(comparison:Comparison<T>):IOrderedEnumerable<T>;\r\n\r\n\torderUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>;\r\n\r\n\torderByDescending<TKey extends Comparable>(keySelector?:Selector<T, TKey>):IOrderedEnumerable<T>;\r\n\r\n\tbuffer(size:number):Enumerable<T[]>;\r\n\r\n\tgroupBy<TKey>(keySelector:Selector<T, TKey>):Enumerable<IGrouping<TKey, T>>;\r\n\tgroupBy<TKey, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, T>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, T>>;\r\n\r\n\tpartitionBy<TKey>(keySelector:Selector<T, TKey>):Enumerable<IGrouping<TKey, T>>;\r\n\tpartitionBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TElement>,\r\n\t\tresultSelector?:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, TElement>>;\r\n\r\n\taggregate(func:(a:T, b:T) => T, seed?:T):T;\r\n\r\n\taverage(selector?:Selector<T, number>):number;\r\n\r\n\tmax():T;\r\n\r\n\tmin():T;\r\n\r\n\tmaxBy<TCompare>(keySelector?:Selector<T, TCompare>):T;\r\n\r\n\tminBy<TCompare>(keySelector?:Selector<T, TCompare>):T;\r\n\r\n\tsum(selector?:Selector<T, number>):number;\r\n\r\n\tproduct(selector?:Selector<T, number>):number;\r\n\r\n\tquotient(selector?:Selector<T, number>):number;\r\n\r\n\tlast():T;\r\n\r\n\tlastOrDefault(defaultValue?:T):T;\r\n\r\n\tshare():Enumerable<T>;\r\n\r\n\tcatchError(handler:(e:any) => void):Enumerable<T>;\r\n\r\n\tfinallyAction(action:() => void):Enumerable<T>;\r\n\r\n\tmemoize():Enumerable<T>;\r\n}\r\nexport declare class FiniteEnumerable<T> extends Enumerable<T>\r\n{\r\n\r\n}\r\nexport declare interface IGrouping<TKey, TElement> extends Enumerable<TElement>\r\n{\r\n\tkey:TKey;\r\n}\r\nexport declare interface ILookup<TKey, TElement> extends IEnumerable<IGrouping<TKey, TElement>>\r\n{\r\n\tcount:number;\r\n\tget(key:TKey):TElement[];\r\n\tcontains(key:TKey):boolean;\r\n}\r\nexport declare interface IOrderedEnumerable<T> extends FiniteEnumerable<T>\r\n{\r\n\tthenBy(keySelector:(value:T) => any):IOrderedEnumerable<T>;\r\n\tthenByDescending(keySelector:(value:T) => any):IOrderedEnumerable<T>;\r\n\tthenUsing(comparison:Comparison<T>):IOrderedEnumerable<T>;\r\n\tthenUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>;\r\n}"]}