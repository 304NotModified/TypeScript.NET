{"version":3,"sources":["System/Collections/Dictionaries/DictionaryAbstractBase.ts"],"names":["DictionaryAbstractBase","DictionaryAbstractBase.constructor","DictionaryAbstractBase._onValueUpdate","DictionaryAbstractBase._onUpdated","DictionaryAbstractBase.handleUpdate","DictionaryAbstractBase.add","DictionaryAbstractBase.clear","DictionaryAbstractBase.contains","DictionaryAbstractBase.copyTo","DictionaryAbstractBase.toArray","DictionaryAbstractBase.remove","DictionaryAbstractBase.addByKeyValue","DictionaryAbstractBase.getValue","DictionaryAbstractBase.setValue","DictionaryAbstractBase.containsKey","DictionaryAbstractBase.containsValue","DictionaryAbstractBase.removeByKey","DictionaryAbstractBase.removeByValue","DictionaryAbstractBase.importPairs","DictionaryAbstractBase.getEnumerator","DictionaryAbstractBase.isUpdating","DictionaryAbstractBase.isReadOnly","DictionaryAbstractBase.count","DictionaryAbstractBase.keys","DictionaryAbstractBase.values","notImplemented"],"mappings":"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","file":"System/Collections/Dictionaries/DictionaryAbstractBase.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDictionary.d.ts\"/>\r\nimport {areEqual} from '../../Compare';\r\nimport EnumeratorBase from '../Enumeration/EnumeratorBase';\r\nimport NotImplementedException from '../../Exceptions/NotImplementedException';\r\nimport ArgumentException from '../../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../../Exceptions/ArgumentNullException';\r\nimport InvalidOperationException from '../../Exceptions/InvalidOperationException';\r\n\r\n\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nexport default\r\nclass DictionaryAbstractBase<TKey, TValue> implements IDictionary<TKey, TValue>\r\n{\r\n\t// This allows for batch updates in order to improve the efficiency of responsive systems.\r\n\tprivate _updateRecursion:number = 0;\r\n\r\n\tget isUpdating():boolean { return this._updateRecursion!=0; }\r\n\r\n\t// Could implement an event dispatcher pattern here easily...\r\n\tpublic onValueChanged:(key:TKey, value:TValue, old:TValue) => void;\r\n\r\n\t// Pseudo-protected.\r\n\tpublic _onValueUpdate(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t\tif(!areEqual(value, old, true))\r\n\t\t{\r\n\r\n\t\t\tvar _ = this;\r\n\t\t\tif(_.onValueChanged)\r\n\t\t\t\t_.onValueChanged(key, value, old);\r\n\r\n\t\t\t// If the update recursion is zero, then we are finished with updates.\r\n\t\t\tif(_._updateRecursion==0)\r\n\t\t\t\t_._onUpdated();\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// Listening to every value update can get noisy.  Here we allow for batch update signaling.\r\n\t// The consumer of this class can also wire up their own event system.\r\n\tpublic onUpdated:() => void;\r\n\r\n\tprivate _onUpdated():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.onUpdated)\r\n\t\t\t_.onUpdated();\r\n\t}\r\n\r\n\t// Takes a closure that if returning true will propagate an update signal.\r\n\tpublic handleUpdate(closure?:() => boolean):boolean\r\n\t{\r\n\t\tvar _ = this, result:boolean;\r\n\t\tif(closure)\r\n\t\t{\r\n\t\t\t_._updateRecursion++;\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tresult = closure();\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._updateRecursion--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = _._updateRecursion==0;\r\n\r\n\t\tif(result && _._updateRecursion==0)\r\n\t\t\t_._onUpdated();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// ICollection<T>\r\n\t/////////////////////////////////////////\r\n\tget isReadOnly():boolean { return false; }\r\n\r\n\tget count():number {\r\n\t\tthrow notImplemented(\"count\");\r\n\t}\r\n\r\n\tadd(item:IKeyValuePair<TKey, TValue>):void\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'item',\r\n\t\t\t\t'Dictionaries must use a valid key/value pair. \\''+item+'\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\tthis.addByKeyValue(item.key, item.value);\r\n\t}\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, keys = _.keys, count = keys.length;\r\n\r\n\t\tif(count)\r\n\t\t\t_.handleUpdate(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys.forEach(key=> { _.removeByKey(key); });\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\tif(_.count!=0) // After they've all been removed, then should be zero.\r\n\t\t\tconsole.warn(\"Dictionary clear() results in mismatched count.\");\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:IKeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item) return false;\r\n\r\n\t\tvar value = this.getValue(item.key);\r\n\t\treturn areEqual(value, item.value);\r\n\t}\r\n\r\n\tcopyTo(array:IKeyValuePair<TKey, TValue>[], index:number = 0):IKeyValuePair<TKey, TValue>[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t// This is a generic implementation that will work for all derived classes.\r\n\t\t// It can be overridden and optimized.\r\n\t\tvar e = this.getEnumerator();\r\n\t\twhile(e.moveNext()) // Disposes when finished.\r\n\t\t{\r\n\t\t\tarray[index++] = e.current;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\ttoArray():IKeyValuePair<TKey,TValue>[] {\r\n\t\treturn this.copyTo([],0);\r\n\t}\r\n\r\n\tremove(item:IKeyValuePair<TKey, TValue>):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\tvar key = item.key, value = this.getValue(key);\r\n\t\treturn (areEqual(value, item.value) && this.removeByKey(key))\r\n\t\t\t? 1 : 0;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\tget keys():TKey[] { throw notImplemented(\"keys\"); }\r\n\r\n\tget values():TValue[] { throw notImplemented(\"values\"); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key)) {\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\t_.setValue(key, value);\r\n\t}\r\n\r\n\tgetValue(key:TKey):TValue\r\n\t{\r\n\t\tthrow notImplemented(\r\n\t\t\t\"getValue(key: TKey): TValue\", \"When calling for key: \" + key\r\n\t\t);\r\n\t}\r\n\r\n\tsetValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tthrow notImplemented(\r\n\t\t\t\"setValue(key: TKey, value: TValue): boolean\", \"When setting \" + key + \":\" + value + \".\"\r\n\t\t);\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\tvar value = this.getValue(key);\r\n\t\treturn value!==undefined;\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, undefined);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\t_.keys.forEach(key=>\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportPairs(pairs:IKeyValuePair<TKey, TValue>[]):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\treturn _.handleUpdate(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar changed:boolean = false;\r\n\t\t\t\tpairs.forEach(\r\n\t\t\t\t\t\tpair=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_.setValue(pair.key, pair.value);\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\treturn changed;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tkeys = _.keys;\r\n\t\t\t\tlen = keys.length\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==undefined) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\nfunction notImplemented<T>(name:string, log:string = \"\"):any\r\n{\r\n\tconsole.log(\"DictionaryAbstractBase sub-class has not overridden \" + name + \". \" + log);\r\n\treturn new NotImplementedException(\"DictionaryAbstractBase.\" + name + \": Not implemented.\");\r\n}\r\n"]}