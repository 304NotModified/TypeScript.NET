{"version":3,"sources":["System/Collections/Dictionaries/Dictionary.ts","System/Collections/Dictionaries/Dictionary.js"],"names":[],"mappings":"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","file":"System/Collections/Dictionaries/Dictionary.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Original: http://linqjs.codeplex.com/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../../FunctionTypes.d.ts\"/>\r\n///<reference path=\"../ILinkedListNode.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport Type from \"../../Types\";\r\nimport Functions from \"../../Functions\";\r\nimport DictionaryBase from \"./DictionaryBase\";\r\nimport EnumeratorBase from \"../Enumeration/EnumeratorBase\";\r\nimport LinkedNodeList from \"../LinkedNodeList\";\r\nimport ObjectPool from \"../../Disposable/ObjectPool\";\r\n\r\nconst VOID0:any = void 0;\r\n\r\n// LinkedList for Dictionary\r\nclass HashEntry<TKey, TValue>\r\nimplements ILinkedNode<HashEntry<TKey, TValue>>, IKeyValuePair<TKey,TValue>\r\n{\r\n\tconstructor(\r\n\t\tpublic key?:TKey,\r\n\t\tpublic value?:TValue,\r\n\t\tpublic previous?:HashEntry<TKey, TValue>,\r\n\t\tpublic next?:HashEntry<TKey, TValue>)\r\n\t{ }\r\n}\r\n\r\nvar linkedListPool:ObjectPool<LinkedNodeList<any>>;\r\nfunction linkedNodeList():LinkedNodeList<any>;\r\nfunction linkedNodeList(recycle?:LinkedNodeList<any>):void;\r\nfunction linkedNodeList(recycle?:LinkedNodeList<any>):LinkedNodeList<any> {\r\n\tif(!linkedListPool)\r\n\t\tlinkedListPool\r\n\t\t\t= new ObjectPool<LinkedNodeList<any>>(20,()=>new LinkedNodeList<any>());\r\n\tif(!recycle) return linkedListPool.take();\r\n\trecycle.clear();\r\n\tlinkedListPool.add(recycle);\r\n}\r\n\r\n// static utility methods\r\nfunction callHasOwnProperty(target:any, key:string)\r\n{\r\n\treturn Object.prototype.hasOwnProperty.call(target, key);\r\n}\r\n\r\nconst NULL = \"null\", GET_HASH_CODE = \"getHashCode\";\r\nfunction getHashString(obj:any):string\r\n{\r\n\tif(obj===null) return NULL;\r\n\tif(obj===VOID0) return Type.UNDEFINED;\r\n\r\n\t// See IHashable.\r\n\tif(Type.hasMemberOfType(obj, GET_HASH_CODE, Type.FUNCTION))\r\n\t{\r\n\t\treturn obj.getHashCode();\r\n\t}\r\n\r\n\treturn (typeof obj.toString==Type.FUNCTION)\r\n\t\t? obj.toString()\r\n\t\t: Object.prototype.toString.call(obj);\r\n}\r\n\r\n\r\nexport default\r\nclass Dictionary<TKey, TValue> extends DictionaryBase<TKey, TValue>\r\n{\r\n\t// Retains the order...\r\n\tprivate _entries:LinkedNodeList<HashEntry<TKey, TValue>>;\r\n\tprivate _buckets:IMap<LinkedNodeList<HashEntry<TKey, HashEntry<TKey, TValue>>>>;\r\n\r\n\tconstructor(\r\n\t\tprivate _keyComparer:Selector<TKey,any> = Functions.Identity)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._entries = linkedNodeList();\r\n\t\tthis._buckets = {};\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\treturn this._entries.unsafeCount;\r\n\t}\r\n\r\n\r\n\tprivate _getBucket(\r\n\t\thash:string,\r\n\t\tcreateIfMissing?:boolean):LinkedNodeList<HashEntry<TKey,HashEntry<TKey,TValue>>>\r\n\t{\r\n\t\tif(hash===null || hash===VOID0 || !createIfMissing && !this.getCount())\r\n\t\t\treturn null;\r\n\r\n\t\tvar buckets = this._buckets;\r\n\t\tvar bucket = callHasOwnProperty(buckets, hash) ? buckets[hash] : VOID0;\r\n\r\n\t\tif(createIfMissing && !bucket)\r\n\t\t\tbuckets[hash]\r\n\t\t\t\t= bucket\r\n\t\t\t\t= linkedNodeList();\r\n\r\n\t\treturn bucket;\r\n\t}\r\n\r\n\tprivate _getBucketEntry(\r\n\t\tkey:TKey,\r\n\t\thash?:string,\r\n\t\tbucket?:LinkedNodeList<HashEntry<TKey,HashEntry<TKey,TValue>>>):HashEntry<TKey,HashEntry<TKey,TValue>>\r\n\t{\r\n\t\tif(key===null || key===VOID0 || !this.getCount())\r\n\t\t\treturn null;\r\n\r\n\t\tvar _          = this,\r\n\t\t    comparer   = _._keyComparer,\r\n\t\t    compareKey = comparer(key);\r\n\r\n\t\tif(!bucket) bucket = _._getBucket(hash || getHashString(compareKey));\r\n\r\n\t\treturn bucket && bucket\r\n\t\t\t\t.find(e=>comparer(e.key)===compareKey);\r\n\t}\r\n\r\n\tprotected _getEntry(key:TKey):HashEntry<TKey,TValue>\r\n\t{\r\n\t\tvar e = this._getBucketEntry(key);\r\n\t\treturn e && e.value;\r\n\t}\r\n\r\n\tgetValue(key:TKey):TValue\r\n\t{\r\n\t\tvar e = this._getEntry(key);\r\n\t\treturn e ? e.value : VOID0;\r\n\t}\r\n\r\n\tprotected _setValueInternal(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tvar _           = this,\r\n\t\t    buckets     = _._buckets,\r\n\t\t    entries     = _._entries,\r\n\t\t    comparer    = _._keyComparer,\r\n\t\t    compareKey  = comparer(key),\r\n\t\t    hash        = getHashString(compareKey),\r\n\t\t    bucket      = _._getBucket(hash),\r\n\t\t    bucketEntry = bucket && _._getBucketEntry(key, hash, bucket);\r\n\r\n\t\t// Entry exits? Delete or update\r\n\t\tif(bucketEntry)\r\n\t\t{\r\n\t\t\tif(value===VOID0)\r\n\t\t\t{\r\n\t\t\t\tlet x = bucket.removeNode(bucketEntry),\r\n\t\t\t\t    y = entries.removeNode(bucketEntry.value);\r\n\r\n\t\t\t\tif(x && !bucket.count) {\r\n\t\t\t\t\tdelete buckets[hash];\r\n\t\t\t\t\tlinkedNodeList(bucket);\r\n\t\t\t\t\tbucket = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(x!==y) throw \"Entries and buckets are out of sync.\";\r\n\r\n\t\t\t\tif(x) return true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// We don't expose the internal hash entries so replacing the value is ok.\r\n\t\t\t\tvar old = bucketEntry.value.value;\r\n\t\t\t\tbucketEntry.value.value = value;\r\n\t\t\t\treturn !areEqual(value, old);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse if(value!==VOID0)\r\n\t\t{\r\n\t\t\tif(!bucket) bucket = _._getBucket(hash, true);\r\n\t\t\tlet entry = new HashEntry(key, value);\r\n\t\t\tentries.addNode(entry);\r\n\t\t\tbucket.addNode(new HashEntry(key, entry));\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tvar _ = this, buckets = _._buckets;\r\n\r\n\t\t// Ensure reset and clean...\r\n\t\tfor(let key in buckets)\r\n\t\t{\r\n\t\t\tif(buckets.hasOwnProperty(key))\r\n\t\t\t{\r\n\t\t\t\tlet bucket = buckets[key];\r\n\t\t\t\tdelete buckets[key];\r\n\t\t\t\tlinkedNodeList(bucket);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn _._entries.clear();\r\n\t}\r\n\r\n\t/*\r\n\t * Note: super.getEnumerator() works perfectly well,\r\n\t * but enumerating the internal linked node list is much more efficient.\r\n\t */\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this, ver:number, currentEntry:HashEntry<TKey, TValue>;\r\n\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tver = _._version;\r\n\t\t\t\tcurrentEntry = _._entries.first;\r\n\t\t\t},\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\tif(currentEntry!=null)\r\n\t\t\t\t{\r\n\t\t\t\t\t_.assertVersion(ver);\r\n\t\t\t\t\tvar result = {key: currentEntry.key, value: currentEntry.value};\r\n\t\t\t\t\tcurrentEntry = currentEntry.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t}\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tprotected getKeys():TKey[]\r\n\t{\r\n\t\tvar _ = this, result:TKey[] = [];\r\n\t\tvar e = _._entries.first;\r\n\t\twhile(e)\r\n\t\t{\r\n\t\t\tresult.push(e.key);\r\n\t\t\te = e.next;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected getValues():TValue[]\r\n\t{\r\n\t\tvar _ = this, result:TValue[] = [];\r\n\t\tvar e = _._entries.first;\r\n\t\twhile(e)\r\n\t\t{\r\n\t\t\tresult.push(e.value);\r\n\t\t\te = e.next;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n}\r\n","/*!\n * @author electricessence / https://github.com/electricessence/\n * Original: http://linqjs.codeplex.com/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst Compare_1 = require(\"../../Compare\");\nconst Types_1 = require(\"../../Types\");\nconst Functions_1 = require(\"../../Functions\");\nconst DictionaryBase_1 = require(\"./DictionaryBase\");\nconst EnumeratorBase_1 = require(\"../Enumeration/EnumeratorBase\");\nconst LinkedNodeList_1 = require(\"../LinkedNodeList\");\nconst ObjectPool_1 = require(\"../../Disposable/ObjectPool\");\nconst VOID0 = void 0;\nclass HashEntry {\n    constructor(key, value, previous, next) {\n        this.key = key;\n        this.value = value;\n        this.previous = previous;\n        this.next = next;\n    }\n}\nvar linkedListPool;\nfunction linkedNodeList(recycle) {\n    if (!linkedListPool)\n        linkedListPool\n            = new ObjectPool_1.default(20, () => new LinkedNodeList_1.default());\n    if (!recycle)\n        return linkedListPool.take();\n    recycle.clear();\n    linkedListPool.add(recycle);\n}\nfunction callHasOwnProperty(target, key) {\n    return Object.prototype.hasOwnProperty.call(target, key);\n}\nconst NULL = \"null\", GET_HASH_CODE = \"getHashCode\";\nfunction getHashString(obj) {\n    if (obj === null)\n        return NULL;\n    if (obj === VOID0)\n        return Types_1.default.UNDEFINED;\n    if (Types_1.default.hasMemberOfType(obj, GET_HASH_CODE, Types_1.default.FUNCTION)) {\n        return obj.getHashCode();\n    }\n    return (typeof obj.toString == Types_1.default.FUNCTION)\n        ? obj.toString()\n        : Object.prototype.toString.call(obj);\n}\nclass Dictionary extends DictionaryBase_1.default {\n    constructor(_keyComparer = Functions_1.default.Identity) {\n        super();\n        this._keyComparer = _keyComparer;\n        this._entries = linkedNodeList();\n        this._buckets = {};\n    }\n    getCount() {\n        return this._entries.unsafeCount;\n    }\n    _getBucket(hash, createIfMissing) {\n        if (hash === null || hash === VOID0 || !createIfMissing && !this.getCount())\n            return null;\n        var buckets = this._buckets;\n        var bucket = callHasOwnProperty(buckets, hash) ? buckets[hash] : VOID0;\n        if (createIfMissing && !bucket)\n            buckets[hash]\n                = bucket\n                    = linkedNodeList();\n        return bucket;\n    }\n    _getBucketEntry(key, hash, bucket) {\n        if (key === null || key === VOID0 || !this.getCount())\n            return null;\n        var _ = this, comparer = _._keyComparer, compareKey = comparer(key);\n        if (!bucket)\n            bucket = _._getBucket(hash || getHashString(compareKey));\n        return bucket && bucket\n            .find(e => comparer(e.key) === compareKey);\n    }\n    _getEntry(key) {\n        var e = this._getBucketEntry(key);\n        return e && e.value;\n    }\n    getValue(key) {\n        var e = this._getEntry(key);\n        return e ? e.value : VOID0;\n    }\n    _setValueInternal(key, value) {\n        var _ = this, buckets = _._buckets, entries = _._entries, comparer = _._keyComparer, compareKey = comparer(key), hash = getHashString(compareKey), bucket = _._getBucket(hash), bucketEntry = bucket && _._getBucketEntry(key, hash, bucket);\n        if (bucketEntry) {\n            if (value === VOID0) {\n                let x = bucket.removeNode(bucketEntry), y = entries.removeNode(bucketEntry.value);\n                if (x && !bucket.count) {\n                    delete buckets[hash];\n                    linkedNodeList(bucket);\n                    bucket = null;\n                }\n                if (x !== y)\n                    throw \"Entries and buckets are out of sync.\";\n                if (x)\n                    return true;\n            }\n            else {\n                var old = bucketEntry.value.value;\n                bucketEntry.value.value = value;\n                return !Compare_1.areEqual(value, old);\n            }\n        }\n        else if (value !== VOID0) {\n            if (!bucket)\n                bucket = _._getBucket(hash, true);\n            let entry = new HashEntry(key, value);\n            entries.addNode(entry);\n            bucket.addNode(new HashEntry(key, entry));\n            return true;\n        }\n        return false;\n    }\n    _clearInternal() {\n        var _ = this, buckets = _._buckets;\n        for (let key in buckets) {\n            if (buckets.hasOwnProperty(key)) {\n                let bucket = buckets[key];\n                delete buckets[key];\n                linkedNodeList(bucket);\n            }\n        }\n        return _._entries.clear();\n    }\n    getEnumerator() {\n        var _ = this, ver, currentEntry;\n        return new EnumeratorBase_1.default(() => {\n            ver = _._version;\n            currentEntry = _._entries.first;\n        }, (yielder) => {\n            if (currentEntry != null) {\n                _.assertVersion(ver);\n                var result = { key: currentEntry.key, value: currentEntry.value };\n                currentEntry = currentEntry.next;\n                return yielder.yieldReturn(result);\n            }\n            return yielder.yieldBreak();\n        });\n    }\n    getKeys() {\n        var _ = this, result = [];\n        var e = _._entries.first;\n        while (e) {\n            result.push(e.key);\n            e = e.next;\n        }\n        return result;\n    }\n    getValues() {\n        var _ = this, result = [];\n        var e = _._entries.first;\n        while (e) {\n            result.push(e.value);\n            e = e.next;\n        }\n        return result;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Dictionary;\n"]}