{"version":3,"sources":["System/Collections/LinkedNodeList.ts","System/Collections/LinkedNodeList.js"],"names":[],"mappings":"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","file":"System/Collections/LinkedNodeList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as TextUtility from '../Text/Utility';\r\n\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\n\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport default\r\nclass LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode;\r\n\tprivate _last:TNode;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t * @returns {TNode}\r\n\t */\r\n\tget first():TNode\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t * @returns {TNode}\r\n\t */\r\n\tget last():TNode\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number {\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, n:TNode, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n) {\r\n\t\t\tcF++;\r\n\t\t\tn.previous = null;\r\n\t\t\tn = n.next;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n) {\r\n\t\t\tcL++;\r\n\t\t\tn.next = null;\r\n\t\t\tn = n.previous;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing.');\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!=-1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t * @returns {TNode}\r\n\t */\r\n\tgetNodeAt(index:number):TNode\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && index<i++)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number {\r\n\t\tif(node!=null && (node.previous || node.next)) {\r\n\r\n\t\t\tvar index = 0;\r\n\t\t\tvar c = this._first;\r\n\t\t\twhile(c) {\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t\tc = c.next;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tvar _ = this;\r\n\t\tvar prev = node.previous, next = node.next, a:boolean = false, b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn !a && !b;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t */\r\n\taddNode(node:TNode):void {\r\n\t\tthis.addNodeAfter(node);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t */\r\n\taddNodeBefore(node:TNode, before?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!before) {\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before) {\r\n\t\t\tnode.previous = before.previous;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(before==_._first) _._last = node;\r\n\t\t} else {\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t */\r\n\taddNodeAfter(node:TNode, after?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!after) {\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after) {\r\n\t\t\tnode.next = after.next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t} else {\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):void {\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tassertValidDetached(replacement,'replacement');\r\n\r\n\t\tvar _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(node:TNode, propName:string = 'node') {\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}","/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst TextUtility = require('../Text/Utility');\nconst InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\nconst ArgumentException_1 = require('../Exceptions/ArgumentException');\nconst ArgumentNullException_1 = require('../Exceptions/ArgumentNullException');\nclass LinkedNodeList {\n    constructor() {\n        this._first = null;\n        this._last = null;\n    }\n    get first() {\n        return this._first;\n    }\n    get last() {\n        return this._last;\n    }\n    get count() {\n        var next = this._first, i = 0;\n        while (next) {\n            i++;\n            next = next.next;\n        }\n        return i;\n    }\n    clear() {\n        var _ = this, n, cF = 0, cL = 0;\n        n = _._first;\n        _._first = null;\n        while (n) {\n            cF++;\n            n.previous = null;\n            n = n.next;\n        }\n        n = _._last;\n        _._last = null;\n        while (n) {\n            cL++;\n            n.next = null;\n            n = n.previous;\n        }\n        if (cF !== cL)\n            console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing.');\n        return cF;\n    }\n    dispose() {\n        this.clear();\n    }\n    contains(node) {\n        return this.indexOf(node) != -1;\n    }\n    getNodeAt(index) {\n        if (index < 0)\n            return null;\n        var next = this._first, i = 0;\n        while (next && index < i++) {\n            next = next.next;\n        }\n        return next;\n    }\n    indexOf(node) {\n        if (node != null && (node.previous || node.next)) {\n            var index = 0;\n            var c = this._first;\n            while (c) {\n                if (c === node)\n                    return index;\n                index++;\n                c = c.next;\n            }\n        }\n        return -1;\n    }\n    removeFirst() {\n        return this.removeNode(this._first);\n    }\n    removeLast() {\n        return this.removeNode(this._last);\n    }\n    removeNode(node) {\n        if (node == null)\n            throw new ArgumentNullException_1.default('node');\n        var _ = this;\n        var prev = node.previous, next = node.next, a = false, b = false;\n        if (prev)\n            prev.next = next;\n        else if (_._first == node)\n            _._first = next;\n        else\n            a = true;\n        if (next)\n            next.previous = prev;\n        else if (_._last == node)\n            _._last = prev;\n        else\n            b = true;\n        if (a !== b) {\n            throw new ArgumentException_1.default('node', TextUtility.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\n        }\n        return !a && !b;\n    }\n    addNode(node) {\n        this.addNodeAfter(node);\n    }\n    addNodeBefore(node, before) {\n        assertValidDetached(node);\n        var _ = this;\n        if (!before) {\n            before = _._first;\n        }\n        if (before) {\n            node.previous = before.previous;\n            node.next = before;\n            before.previous = node;\n            if (before == _._first)\n                _._last = node;\n        }\n        else {\n            _._first = _._last = node;\n        }\n    }\n    addNodeAfter(node, after) {\n        assertValidDetached(node);\n        var _ = this;\n        if (!after) {\n            after = _._last;\n        }\n        if (after) {\n            node.next = after.next;\n            node.previous = after;\n            after.next = node;\n            if (after == _._last)\n                _._last = node;\n        }\n        else {\n            _._first = _._last = node;\n        }\n    }\n    replace(node, replacement) {\n        if (node == null)\n            throw new ArgumentNullException_1.default('node');\n        assertValidDetached(replacement, 'replacement');\n        var _ = this;\n        replacement.previous = node.previous;\n        replacement.next = node.next;\n        if (node.previous)\n            node.previous.next = replacement;\n        if (node.next)\n            node.next.previous = replacement;\n        if (node == _._first)\n            _._first = replacement;\n        if (node == _._last)\n            _._last = replacement;\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedNodeList;\nfunction assertValidDetached(node, propName = 'node') {\n    if (node == null)\n        throw new ArgumentNullException_1.default(propName);\n    if (node.next || node.previous)\n        throw new InvalidOperationException_1.default(\"Cannot add a node to a LinkedNodeList that is already linked.\");\n}\n"]}