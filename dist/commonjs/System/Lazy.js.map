{"version":3,"sources":["System/Lazy.js","System/Lazy.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;ACCA,IAAA,mBAAA,QAA6B,6BAA7B,CAAA;AAGA,IAAA,0BAAA,QAAoC,oCAApC,CAAA;;IAGA;;;AAMC,aAND,IAMC,CAAsB,QAAtB,EAAsC;8BANvC,MAMuC;;2EANvC,kBAMuC;;AAAhB,cAAA,QAAA,GAAA,QAAA,CAAgB;AAGrC,YAAG,CAAC,QAAD,EAAW,MAAM,IAAI,wBAAA,qBAAA,CAAsB,UAA1B,CAAN,CAAd;AACA,cAAK,qBAAL,GAA6B,MAA7B,CAJqC;;KAAtC;;iBAND;;mCA4BS;AAEP,gBAAI,IAAI,IAAJ,CAFG;AAIP,cAAE,eAAF,GAJO;AAMP,gBAAI;AACH,oBAAG,CAAC,EAAE,eAAF,IAAqB,EAAE,QAAF,EAAY;AACpC,wBAAI,IAAI,EAAE,QAAF,EAAJ,CADgC;AAEpC,sBAAE,MAAF,GAAW,CAAX,CAFoC;AAGpC,sBAAE,MAAF,GAAW,KAAK,CAAL,CAHyB;AAIpC,2BAAO,CAAP,CAJoC;iBAArC;aADD,CAQA,OAAM,EAAN,EAAU;AACT,kBAAE,MAAF,GAAW,EAAX,CADS;AAET,sBAAM,EAAN,CAFS;aAAV,SAIQ;AACP,kBAAE,iBAAF,GADO;AAEP,kBAAE,eAAF,GAAoB,IAApB,CAFO;aAZR;AAiBA,mBAAO,EAAE,MAAF,CAvBA;;;;4CA2BmB;AAC1B,iBAAK,QAAL,GAAgB,IAAhB,CAD0B;;;;qCAKP;AACnB,iBAAK,QAAL,GAAgB,IAAhB,CADmB;AAEnB,iBAAK,MAAL,GAAc,IAAd,CAFmB;;;;+BAKb,OAAa;AAEnB,mBAAO,QAAM,KAAN,CAFY;;;;oCAKR,OAAa;AAExB,mBAAO,KAAK,MAAL,CAAY,KAAZ,KAAsB,KAAK,KAAL,KAAa,MAAM,KAAN,CAFlB;;;;4BAzDP;AAEjB,mBAAO,KAAK,eAAL,CAFU;;;;4BAKT;AAER,mBAAO,KAAK,QAAL,EAAP,CAFQ;;;;4BAMA;AACR,mBAAO,KAAK,MAAL,CADC;;;;WAxBV;EAA6B,iBAAA,cAAA;;AAAhB,QAAA,IAAA,GAAI,IAAJ;;IA4Eb;;;;;;;;;;;iCAIU,uBAA8B;AAEtC,gBAAI,+BANN,uDAMM,CAFkC;AAGtC,gBAAG,qBAAH,EAA0B,2BAP5B,gEAO4B,CAA1B;AACA,mBAAO,CAAP,CAJsC;;;;4CAOZ;;;8BAWrB,oBAA2B;AAChC,gBAAI,IAAI,IAAJ,CAD4B;AAGhC,gBAAG,kBAAH,EACC,EAAE,eAAF,GADD;AAGA,gBAAG,CAAC,EAAE,QAAF,EAAY;AACf,oBAAG,kBAAH,EACC,MAAM,IAAI,KAAJ,CAAU,iEAAV,CAAN,CADD;AAEA,uBAAO,KAAP,CAHe;aAAhB,MAKK;AACJ,kBAAE,eAAF,GAAoB,KAApB,CADI;AAEJ,kBAAE,MAAF,GAAW,IAAX,CAFI;AAGJ,kBAAE,MAAF,GAAW,KAAK,CAAL,CAHP;AAIJ,uBAAO,IAAP,CAJI;aALL;;;;4BAZW;AAEX,mBAAO,CAAC,KAAK,WAAL,IAAoB,CAAC,CAAE,KAAK,QAAL,CAFpB;;;;WAhBb;EAAuC;;AAA1B,QAAA,cAAA,GAAc,cAAd;AA4Cb,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADxCA,QAAQ,OAAR,GCwCe,IDxCf","file":"System/Lazy.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst DisposableBase_1 = require(\"./Disposable/DisposableBase\");\nconst ArgumentNullException_1 = require(\"./Exceptions/ArgumentNullException\");\nclass Lazy extends DisposableBase_1.DisposableBase {\n    constructor(_closure) {\n        super();\n        this._closure = _closure;\n        if (!_closure)\n            throw new ArgumentNullException_1.ArgumentNullException(\"_closure\");\n        this._disposableObjectName = 'Lazy';\n    }\n    get isValueCreated() {\n        return this._isValueCreated;\n    }\n    get value() {\n        return this.getValue();\n    }\n    get error() {\n        return this._error;\n    }\n    getValue() {\n        var _ = this;\n        _.throwIfDisposed();\n        try {\n            if (!_._isValueCreated && _._closure) {\n                var v = _._closure();\n                _._value = v;\n                _._error = void 0;\n                return v;\n            }\n        }\n        catch (ex) {\n            _._error = ex;\n            throw ex;\n        }\n        finally {\n            _._onValueRequested();\n            _._isValueCreated = true;\n        }\n        return _._value;\n    }\n    _onValueRequested() {\n        this._closure = null;\n    }\n    _onDispose() {\n        this._closure = null;\n        this._value = null;\n    }\n    equals(other) {\n        return this == other;\n    }\n    valueEquals(other) {\n        return this.equals(other) || this.value === other.value;\n    }\n}\nexports.Lazy = Lazy;\nclass ResettableLazy extends Lazy {\n    getValue(clearClosureReference) {\n        var v = super.getValue();\n        if (clearClosureReference)\n            super._onValueRequested();\n        return v;\n    }\n    _onValueRequested() {\n    }\n    get canReset() {\n        return !this.wasDisposed && !!(this._closure);\n    }\n    reset(throwIfCannotReset) {\n        var _ = this;\n        if (throwIfCannotReset)\n            _.throwIfDisposed();\n        if (!_._closure) {\n            if (throwIfCannotReset)\n                throw new Error(\"Cannot reset.  This Lazy has already de-referenced its closure.\");\n            return false;\n        }\n        else {\n            _._isValueCreated = false;\n            _._value = null;\n            _._error = void 0;\n            return true;\n        }\n    }\n}\nexports.ResettableLazy = ResettableLazy;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Lazy;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {DisposableBase} from \"./Disposable/DisposableBase\";\r\nimport {ILazy} from \"./ILazy\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ArgumentNullException} from \"./Exceptions/ArgumentNullException\";\r\n\r\n// We need a non-resettable lazy to ensure it can be passed safely around.\r\nexport class Lazy<T> extends DisposableBase implements ILazy<T>\r\n{\r\n\r\n\tprotected _isValueCreated:boolean;\r\n\tprotected _value:T;\r\n\r\n\tconstructor(protected _closure:Func<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_closure) throw new ArgumentNullException(\"_closure\");\r\n\t\tthis._disposableObjectName = 'Lazy';\r\n\t}\r\n\r\n\tget isValueCreated():boolean\r\n\t{\r\n\t\treturn this._isValueCreated;\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this.getValue();\r\n\t}\r\n\r\n\tprotected _error:any;\r\n\tget error():any {\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tgetValue():T {\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\ttry {\r\n\t\t\tif(!_._isValueCreated && _._closure) {\r\n\t\t\t\tvar v = _._closure();\r\n\t\t\t\t_._value = v;\r\n\t\t\t\t_._error = void 0;\r\n\t\t\t\treturn v;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex) {\r\n\t\t\t_._error = ex;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\t\tfinally {\r\n\t\t\t_._onValueRequested();\r\n\t\t\t_._isValueCreated = true;\r\n\t\t}\r\n\r\n\t\treturn _._value;\r\n\r\n\t}\r\n\r\n\tprotected _onValueRequested() {\r\n\t\tthis._closure = null;\r\n\t}\r\n\r\n\r\n\tprotected _onDispose():void {\r\n\t\tthis._closure = null;\r\n\t\tthis._value = null;\r\n\t}\r\n\r\n\tequals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this==other;\r\n\t}\r\n\r\n\tvalueEquals(other:Lazy<T>):boolean\r\n\t{\r\n\t\treturn this.equals(other) || this.value===other.value;\r\n\t}\r\n}\r\n\r\nexport class ResettableLazy<T> extends Lazy<T> {\r\n\r\n\r\n\r\n\tgetValue(clearClosureReference?:boolean):T {\r\n\r\n\t\tvar v = super.getValue();\r\n\t\tif(clearClosureReference) super._onValueRequested();\r\n\t\treturn v;\r\n\t}\r\n\r\n\tprotected _onValueRequested() {\r\n\t\t// Do nothing special...\r\n\t}\r\n\r\n\t// Adding a 'resettable' mechanism allows for simply resetting a lazy instead of re-instantiating a new one.\r\n\tget canReset():boolean\r\n\t{\r\n\t\treturn !this.wasDisposed && !!(this._closure);\r\n\t}\r\n\r\n\t// Returns true if successfully reset.\r\n\treset(throwIfCannotReset?:boolean):boolean {\r\n\t\tvar _ = this;\r\n\r\n\t\tif(throwIfCannotReset)\r\n\t\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!_._closure) {\r\n\t\t\tif(throwIfCannotReset)\r\n\t\t\t\tthrow new Error(\"Cannot reset.  This Lazy has already de-referenced its closure.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t_._isValueCreated = false;\r\n\t\t\t_._value = null;\r\n\t\t\t_._error = void 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport default Lazy;"]}