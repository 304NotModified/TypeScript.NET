{"version":3,"sources":["System/Uri/QueryBuilder.ts"],"names":["QueryBuilder","QueryBuilder.constructor","QueryBuilder.importFromString","QueryBuilder.encode","QueryBuilder.toString","QueryBuilder.init"],"mappings":";;;;;;;;;;;;;;;;;;;;;;qBASiB,UAAU;;;;2BAEE,eAAe;;IAAhC,WAAW;;iEACgB,wDAAwD;;;;AAE/F,IACA,eAAe,GAAO,GAAG;IACzB,mBAAmB,GAAG,GAAG,CAAC;;IAO1B,YAAA;cAAA,YAAA;;AAICA,aAJD,YAAA,CAKEA,KAA6BA,EACFA;YAA3BA,YAAYA,yDAAWA,IAAIA;;8BAN7B,YAAA;;AAQEC,mCARF,YAAA,6CAQUA;AAERA,YAAGA,mBAAKA,QAAQA,CAACA,KAAKA,CAACA,EACvBA;AACCA,gBAAIA,CAACA,gBAAgBA,CAASA,KAAKA,EAAEA,YAAYA,CAACA,CAACA;SACnDA,MAEDA;AACCA,gBAAIA,CAACA,SAASA,CAAmBA,KAAKA,CAACA,CAACA;SACxCA;KACDA;;iBAlBF,YAAA;;eA2BiBD,0BACfA,MAAaA,EAEcA;gBAD3BA,WAAWA,yDAAWA,IAAIA;gBAC1BA,YAAYA,yDAAWA,IAAIA;;AAE3BE,gBAAIA,CAACA,GAAGA,IAAIA,CAACA;AACbA,uBAAWA,CAACA,KAAKA,CAACA,MAAMA,EACvBA,UAACA,GAAGA,EAAEA,KAAKA,EAAAA;AAEVA,oBAAGA,CAACA,CAACA,WAAWA,CAACA,GAAGA,CAACA,EACrBA;AACCA,wBAAIA,IAAIA,GAAGA,CAACA,CAACA,QAAQA,CAACA,GAAGA,CAACA,CAACA;AAC3BA,wBAAGA,IAAIA,YAAYA,KAAKA,EACvBA,IAAIA,CAACA,IAAIA,CAACA,KAAKA,CAACA,CAACA,KAEjBA,CAACA,CAACA,QAAQA,CAACA,GAAGA,EAAEA,CAAoBA,IAAIA,EAAEA,KAAKA,CAACA,CAACA,CAACA;iBACnDA,MAEAA,CAACA,CAACA,QAAQA,CAACA,GAAGA,EAAEA,KAAKA,CAACA,CAACA;aACxBA,EACDA,WAAWA,EACXA,YAAYA,CAACA,CAACA;AAEfA,mBAAOA,IAAIA,CAACA;SACZA;;;eAYKF,gBAACA,gBAAyBA,EAAAA;AAE/BG,gBAAIA,OAAOA,GAAYA,EAAEA,CAACA;AAC1BA,gBAAIA,IAAIA,GAAGA,IAAIA,CAACA,IAAIA,CAACA;;;;;;AACrBA,qCAAaA,IAAIA,8HACjBA;wBADQA,CAACA;;AAERA,wBAAIA,KAAKA,GAAGA,IAAIA,CAACA,QAAQA,CAACA,CAACA,CAACA,CAACA;;;;;;AAG7BA,+CAAaA,KAAKA,YAAYA,KAAKA,GAAGA,KAAKA,GAAGA,CAACA,KAAKA,CAACA,CAAAA,mIACrDA;gCADQA,CAACA;;AAERA,mCAAOA,CAACA,IAAIA,CACXA,CAACA,GAAGA,mBAAmBA,GACrBA,WAAWA,CAACA,WAAWA,CAAoBA,CAACA,CAACA,CAACA,CAACA;yBAClDA;;;;;;;;;;;;;;;iBACDA;;;;;;;;;;;;;;;;AAEDA,mBAAOA,CAACA,OAAOA,CAACA,MAAMA,IAAIA,gBAAgBA,GAAGA,GAAGA,GAAGA,EAAEA,CAAAA,GAClDA,OAAOA,CAACA,IAAIA,CAACA,eAAeA,CAACA,CAACA;SACjCA;;;eAEOH,oBAAAA;AAEPI,mBAAOA,IAAIA,CAACA,MAAMA,EAAEA,CAACA;SACrBA;;;eAlCUJ,cACVA,KAA6BA,EACFA;gBAA3BA,YAAYA,yDAAWA,IAAIA;;AAE3BK,mBAAOA,IAAIA,YAAYA,CAACA,KAAKA,EAAEA,YAAYA,CAACA,CAACA;SAC7CA;;;WA1DF,YAAA;;;qBAAA,YAAA","file":"System/Uri/QueryBuilder.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Collections/Dictionaries/IDictionary.d.ts\"/>\r\n///<reference path=\"../Serialization/ISerializable.d.ts\"/>\r\n///<reference path=\"IUriComponentFormattable.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\nimport Type from '../Types';\r\nimport * as Serialization from '../Serialization/Utility';\r\nimport * as QueryParams from './QueryParams';\r\nimport OrderedStringKeyDictionary from '../Collections/Dictionaries/OrderedStringKeyDictionary';\r\n\r\nconst\r\nENTRY_SEPARATOR     = \"&\",\r\nKEY_VALUE_SEPARATOR = \"=\";\r\n\r\n/**\r\n * Provides a means for parsing and building a set of parameters.\r\n *\r\n * In other languages, dictionaries are not reliable for retaining the order of stored values. So for certainty and flexibility we use an ordered dictionary as a base class.\r\n */\r\nexport default\r\nclass QueryBuilder extends OrderedStringKeyDictionary<UriComponentValue|UriComponentValue[]>\r\n{\r\n\r\n\tconstructor(\r\n\t\tquery:string|IUriComponentMap,\r\n\t\tdecodeValues:boolean = true)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(Type.isString(query))\r\n\t\t{\r\n\t\t\tthis.importFromString(<string>query, decodeValues);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.importMap(<IUriComponentMap>query);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Property parses the components of an URI into their values or array of values.\r\n\t * @param values\r\n\t * @param deserialize\r\n\t * @param decodeValues\r\n\t * @returns {QueryBuilder}\r\n\t */\r\n\timportFromString(\r\n\t\tvalues:string,\r\n\t\tdeserialize:boolean = true,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tQueryParams.parse(values,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\tif(_.containsKey(key))\r\n\t\t\t\t{\r\n\t\t\t\t\tvar prev = _.getValue(key);\r\n\t\t\t\t\tif(prev instanceof Array)\r\n\t\t\t\t\t\tprev.push(value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t_.setValue(key, [<UriComponentValue>prev, value]);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\t_.setValue(key, value);\r\n\t\t\t},\r\n\t\t\tdeserialize,\r\n\t\t\tdecodeValues);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tstatic init(\r\n\t\tquery:string|IUriComponentMap,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\t\treturn new QueryBuilder(query, decodeValues);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the encoded URI string\r\n\t */\r\n\tencode(prefixIfNotEmpty?:boolean):string\r\n\t{\r\n\t\tvar entries:string[] = [];\r\n\t\tvar keys = this.keys;\r\n\t\tfor(let k of keys)\r\n\t\t{\r\n\t\t\tvar value = this.getValue(k);\r\n\t\t\t// Since the values can either be UriComponentValues or an array of UriComponentValues..\r\n\t\t\t// This creates a single code path for both options.\r\n\t\t\tfor(let v of value instanceof Array ? value : [value])\r\n\t\t\t{\r\n\t\t\t\tentries.push(\r\n\t\t\t\t\tk + KEY_VALUE_SEPARATOR\r\n\t\t\t\t\t+ QueryParams.encodeValue(<UriComponentValue>v));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn (entries.length && prefixIfNotEmpty ? '?' : '')\r\n\t\t\t+ entries.join(ENTRY_SEPARATOR);\r\n\t}\r\n\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.encode();\r\n\t}\r\n}\r\n"]}