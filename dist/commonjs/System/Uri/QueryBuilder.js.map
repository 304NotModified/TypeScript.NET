{"version":3,"sources":["System/Uri/QueryBuilder.ts","System/Uri/QueryBuilder.js"],"names":[],"mappings":";;;;AASA;;;;;;;;;;AAEA,IAAA,UAAA,QAAiB,UAAjB,CAAA;AAEA,IAAY,cAAW,QAAM,eAAN,CAAX;AACZ,IAAA,+BAAA,QAAuC,wDAAvC,CAAA;AACA,IAAA,eAAA,QAA2B,uCAA3B,CAAA;AAGA,IACA,kBAAsB,GAAtB;IACA,sBAAsB,GAAtB;;IAOA;;;AAIC,aAJD,YAIC,CACC,KADD,EAK4B;YAA3B,qEAAuB,oBAAI;;8BAT7B,cAS6B;;2EAT7B,0BAS6B;;AAI3B,cAAK,WAAL,CAAiB,KAAjB,EAAuB,YAAvB,EAJ2B;;KAL5B;;iBAJD;;oCA4BE,OAI2B;gBAA3B,qEAAuB,oBAAI;;AAE3B,gBAAG,QAAA,OAAA,CAAK,QAAL,CAAc,KAAd,CAAH,EACA;AACC,qBAAK,gBAAL,CAA8B,KAA9B,EAAqC,YAArC,EADD;aADA,MAIK,IAAG,MAAM,OAAN,CAAc,KAAd,KAAwB,aAAA,YAAA,CAAa,KAAb,CAAxB,EACR;AACC,qBAAK,WAAL,CAAiB,KAAjB,EADD;aADK,MAKL;AACC,qBAAK,SAAL,CAAiC,KAAjC,EADD;aALK;AASL,mBAAO,IAAP,CAf2B;;;;yCA0B3B,QAE2B;gBAD3B,oEAAsB,oBACK;gBAA3B,qEAAuB,oBAAI;;AAE3B,gBAAI,IAAI,IAAJ,CAFuB;AAG3B,wBAAY,KAAZ,CAAkB,MAAlB,EACC,UAAC,GAAD,EAAM,KAAN,EAAW;AAEV,oBAAG,EAAE,WAAF,CAAc,GAAd,CAAH,EACA;AACC,wBAAI,OAAO,EAAE,QAAF,CAAW,GAAX,CAAP,CADL;AAEC,wBAAG,MAAM,OAAN,CAAc,IAAd,CAAH,EACC,KAAK,IAAL,CAAU,KAAV,EADD,KAGC,EAAE,QAAF,CAAW,GAAX,EAAgB,CAAoB,IAApB,EAA0B,KAA1B,CAAhB,EAHD;iBAHD,MASC,EAAE,QAAF,CAAW,GAAX,EAAgB,KAAhB,EATD;aAFD,EAaA,WAdD,EAeC,YAfD,EAH2B;AAoB3B,mBAAO,IAAP,CApB2B;;;;+BA4BrB,kBAAyB;AAE/B,gBAAI,UAAmB,EAAnB,CAF2B;AAG/B,gBAAI,OAAO,KAAK,IAAL,CAHoB;;;;;;AAI/B,qCAAa,8BAAb,oGACA;wBADQ,gBACR;;AACC,wBAAI,QAAQ,KAAK,QAAL,CAAc,CAAd,CAAR,CADL;;;;;;AAIC,+CAAa,MAAM,OAAN,CAAc,KAAd,IAAuB,KAAvB,GAA+B,CAAC,KAAD,CAA/B,4BAAb,wGACA;gCADQ,iBACR;;AACC,oCAAQ,IAAR,CACC,IAAI,mBAAJ,GACE,YAAY,WAAZ,CAA2C,CAA3C,CADF,CADD,CADD;yBADA;;;;;;;;;;;;;;qBAJD;iBADA;;;;;;;;;;;;;;aAJ+B;;AAiB/B,mBAAO,CAAC,QAAQ,MAAR,IAAkB,gBAAlB,GAAqC,GAArC,GAA2C,EAA3C,CAAD,GACJ,QAAQ,IAAR,CAAa,eAAb,CADI,CAjBwB;;;;mCAqBxB;AAEP,mBAAO,KAAK,MAAL,EAAP,CAFO;;;;6BA3FP,OAI2B;gBAA3B,qEAAuB,oBAAI;;AAE3B,mBAAO,IAAI,YAAJ,CAAiB,KAAjB,EAAwB,YAAxB,CAAP,CAF2B;;;;WAtB7B;EAC2B,6BAAA,OAAA;;AAD3B,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ACoCA,QAAQ,OAAR,GAAkB,YAAlB","file":"System/Uri/QueryBuilder.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Collections/Dictionaries/IDictionary.d.ts\"/>\r\n///<reference path=\"../Serialization/ISerializable.d.ts\"/>\r\n///<reference path=\"IUriComponentFormattable.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport Type from '../Types';\r\nimport * as Serialization from '../Serialization/Utility';\r\nimport * as QueryParams from './QueryParams';\r\nimport OrderedStringKeyDictionary from '../Collections/Dictionaries/OrderedStringKeyDictionary';\r\nimport {isEnumerable} from '../Collections/Enumeration/Enumerator';\r\n\r\n\r\nconst\r\nENTRY_SEPARATOR     = \"&\",\r\nKEY_VALUE_SEPARATOR = \"=\";\r\n\r\n/**\r\n * Provides a means for parsing and building a set of parameters.\r\n *\r\n * In other languages, dictionaries are not reliable for retaining the order of stored values. So for certainty and flexibility we use an ordered dictionary as a base class.\r\n */\r\nexport default\r\nclass QueryBuilder extends OrderedStringKeyDictionary<UriComponentValue|UriComponentValue[]>\r\n{\r\n\r\n\tconstructor(\r\n\t\tquery:string\r\n\t\t\t|IUriComponentMap\r\n\t\t\t|StringKeyValuePair<UriComponentValue|UriComponentValue[]>[]\r\n\t\t\t|IEnumerable<StringKeyValuePair<UriComponentValue|UriComponentValue[]>>,\r\n\t\tdecodeValues:boolean = true)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.importQuery(query,decodeValues);\r\n\t}\r\n\r\n\r\n\tstatic init(\r\n\t\tquery:string\r\n\t\t\t|IUriComponentMap\r\n\t\t\t|StringKeyValuePair<UriComponentValue|UriComponentValue[]>[]\r\n\t\t\t|IEnumerable<StringKeyValuePair<UriComponentValue|UriComponentValue[]>>,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\t\treturn new QueryBuilder(query, decodeValues);\r\n\t}\r\n\r\n\timportQuery(\r\n\t\tquery:string\r\n\t\t\t|IUriComponentMap\r\n\t\t\t|StringKeyValuePair<UriComponentValue|UriComponentValue[]>[]\r\n\t\t\t|IEnumerable<StringKeyValuePair<UriComponentValue|UriComponentValue[]>>,\r\n\t\tdecodeValues:boolean = true):QueryBuilder {\r\n\r\n\t\tif(Type.isString(query))\r\n\t\t{\r\n\t\t\tthis.importFromString(<string>query, decodeValues);\r\n\t\t}\r\n\t\telse if(Array.isArray(query) || isEnumerable(query))\r\n\t\t{\r\n\t\t\tthis.importPairs(query);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.importMap(<IUriComponentMap>query);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Property parses the components of an URI into their values or array of values.\r\n\t * @param values\r\n\t * @param deserialize\r\n\t * @param decodeValues\r\n\t * @returns {QueryBuilder}\r\n\t */\r\n\timportFromString(\r\n\t\tvalues:string,\r\n\t\tdeserialize:boolean = true,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tQueryParams.parse(values,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\tif(_.containsKey(key))\r\n\t\t\t\t{\r\n\t\t\t\t\tvar prev = _.getValue(key);\r\n\t\t\t\t\tif(Array.isArray(prev))\r\n\t\t\t\t\t\tprev.push(value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t_.setValue(key, [<UriComponentValue>prev, value]);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\t_.setValue(key, value);\r\n\t\t\t},\r\n\t\t\tdeserialize,\r\n\t\t\tdecodeValues);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\r\n\t/**\r\n\t * Returns the encoded URI string\r\n\t */\r\n\tencode(prefixIfNotEmpty?:boolean):string\r\n\t{\r\n\t\tvar entries:string[] = [];\r\n\t\tvar keys = this.keys;\r\n\t\tfor(let k of keys)\r\n\t\t{\r\n\t\t\tvar value = this.getValue(k);\r\n\t\t\t// Since the values can either be UriComponentValues or an array of UriComponentValues..\r\n\t\t\t// This creates a single code path for both options.\r\n\t\t\tfor(let v of Array.isArray(value) ? value : [value])\r\n\t\t\t{\r\n\t\t\t\tentries.push(\r\n\t\t\t\t\tk + KEY_VALUE_SEPARATOR\r\n\t\t\t\t\t+ QueryParams.encodeValue(<UriComponentValue>v));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn (entries.length && prefixIfNotEmpty ? '?' : '')\r\n\t\t\t+ entries.join(ENTRY_SEPARATOR);\r\n\t}\r\n\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.encode();\r\n\t}\r\n}\r\n","/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n'use strict';\nconst Types_1 = require('../Types');\nconst QueryParams = require('./QueryParams');\nconst OrderedStringKeyDictionary_1 = require('../Collections/Dictionaries/OrderedStringKeyDictionary');\nconst Enumerator_1 = require('../Collections/Enumeration/Enumerator');\nconst ENTRY_SEPARATOR = \"&\", KEY_VALUE_SEPARATOR = \"=\";\nclass QueryBuilder extends OrderedStringKeyDictionary_1.default {\n    constructor(query, decodeValues = true) {\n        super();\n        this.importQuery(query, decodeValues);\n    }\n    static init(query, decodeValues = true) {\n        return new QueryBuilder(query, decodeValues);\n    }\n    importQuery(query, decodeValues = true) {\n        if (Types_1.default.isString(query)) {\n            this.importFromString(query, decodeValues);\n        }\n        else if (Array.isArray(query) || Enumerator_1.isEnumerable(query)) {\n            this.importPairs(query);\n        }\n        else {\n            this.importMap(query);\n        }\n        return this;\n    }\n    importFromString(values, deserialize = true, decodeValues = true) {\n        var _ = this;\n        QueryParams.parse(values, (key, value) => {\n            if (_.containsKey(key)) {\n                var prev = _.getValue(key);\n                if (Array.isArray(prev))\n                    prev.push(value);\n                else\n                    _.setValue(key, [prev, value]);\n            }\n            else\n                _.setValue(key, value);\n        }, deserialize, decodeValues);\n        return this;\n    }\n    encode(prefixIfNotEmpty) {\n        var entries = [];\n        var keys = this.keys;\n        for (let k of keys) {\n            var value = this.getValue(k);\n            for (let v of Array.isArray(value) ? value : [value]) {\n                entries.push(k + KEY_VALUE_SEPARATOR\n                    + QueryParams.encodeValue(v));\n            }\n        }\n        return (entries.length && prefixIfNotEmpty ? '?' : '')\n            + entries.join(ENTRY_SEPARATOR);\n    }\n    toString() {\n        return this.encode();\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = QueryBuilder;\n"]}