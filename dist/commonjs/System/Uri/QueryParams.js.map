{"version":3,"sources":["System/Uri/QueryParams.ts"],"names":["encode","encodeValue","isUriComponentFormattable","parse","parseToMap","parseToArray","Separator"],"mappings":"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","file":"System/Uri/QueryParams.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IUriComponentFormattable.d.ts\"/>\r\n///<reference path=\"../Collections/Dictionaries/IDictionary.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\nimport Type from '../Types';\r\nimport * as Serialization from '../Serialization/Utility';\r\n\r\n/*\r\n * This module is provided as a lighter weight utility for acquiring query params.\r\n * If more detailed operations are necessary, consider importing QueryBuilder.\r\n */\r\n\r\nconst\r\n\tENTRY_SEPARATOR = \"&\",\r\n\tKEY_VALUE_SEPARATOR = \"=\";\r\n\r\n/**\r\n * Returns the encoded URI string\r\n */\r\nexport function encode(\r\n\tvalues:IUriComponentMap|IKeyValuePair<string,Primitive>[],\r\n\tprefixIfNotEmpty?:boolean):string\r\n{\r\n\tif(!values) return '';\r\n\tvar entries:string[] = [];\r\n\r\n\tif(Array.isArray(values))\r\n\t{\r\n\t\tfor(let kvp of values)\r\n\t\t{\r\n\t\t\tif(kvp) entries.push(kvp.key + KEY_VALUE_SEPARATOR + encodeValue(kvp.value));\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tvar keys = Object.keys(values);\r\n\t\tfor(let k of keys)\r\n\t\t{\r\n\t\t\tentries.push(k + KEY_VALUE_SEPARATOR + encodeValue((<any>values)[k]));\r\n\t\t}\r\n\t}\r\n\r\n\treturn (entries.length && prefixIfNotEmpty ? '?' : '')\r\n\t\t+ entries.join(ENTRY_SEPARATOR);\r\n}\r\n\r\n/**\r\n * Converts any primitive, serializable or uri-component object to an encoded string.\r\n * @param value\r\n * @returns {string}\r\n */\r\nexport function encodeValue(value:Primitive|ISerializable|IUriComponentFormattable):string\r\n{\r\n\tvar v:string = null;\r\n\tif(isUriComponentFormattable(value))\r\n\t{\r\n\t\tv = value.toUriComponent();\r\n\t\tif(v && v.indexOf('&')!=1)\r\n\t\t\tthrow '.toUriComponent() did not encode the value.';\r\n\t}\r\n\telse\r\n\t{\r\n\t\tv = encodeURIComponent(Serialization.toString(v));\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n/**\r\n * A shortcut for identifying an IUriComponentFormattable object.\r\n * @param instance\r\n * @returns {boolean}\r\n */\r\nexport function isUriComponentFormattable(instance:any):instance is IUriComponentFormattable\r\n{\r\n\treturn Type.hasMemberOfType<IUriComponentFormattable>(instance, \"toUriComponent\", Type.FUNCTION);\r\n}\r\n\r\n/**\r\n * Parses a string for valid query param entries and pipes them through a handler.\r\n * @param query\r\n * @param entryHandler\r\n * @param deserialize\r\n * @param decodeValues\r\n */\r\nexport function parse(\r\n\tquery:string,\r\n\tentryHandler:(key:string, value:Primitive)=>void,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):void\r\n{\r\n\tif(query && (query = query.replace(/^\\s*\\?+/, '')))\r\n\t{\r\n\t\tvar entries = query.split(ENTRY_SEPARATOR);\r\n\t\tfor(let entry of entries)\r\n\t\t{\r\n\t\t\t/*\r\n\t\t\t * Since it is technically possible to have multiple '=' we need to identify the first one.\r\n\t\t\t * And if there is no '=' then the entry is ignored.\r\n\t\t\t */\r\n\t\t\tvar si = entry.indexOf(KEY_VALUE_SEPARATOR);\r\n\t\t\tif(si!= -1)\r\n\t\t\t{\r\n\t\t\t\tvar key = entry.substring(0, si);\r\n\t\t\t\tvar value = <any>entry.substring(si + 1);\r\n\t\t\t\tif(decodeValues) value = decodeURIComponent(value);\r\n\t\t\t\tif(deserialize) value = Serialization.toPrimitive(value);\r\n\t\t\t\tentryHandler(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value map of the entries.\r\n * @param query\r\n * @param deserialize\r\n * @param decodeValues\r\n * @returns {IMap<Primitive>}\r\n */\r\nexport function parseToMap(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IMap<Primitive|Primitive[]>\r\n{\r\n\tvar result:IMap<Primitive|Primitive[]> = {};\r\n\tparse(query,\r\n\t\t(key, value)=>\r\n\t\t{\r\n\t\t\tif((key)in(result))\r\n\t\t\t{\r\n\t\t\t\tvar prev:any = result[key];\r\n\t\t\t\tif(!(Array.isArray(prev)))\r\n\t\t\t\t\tresult[key] = prev = [prev];\r\n\t\t\t\tprev.push(value);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult[key] = value;\r\n\t\t},\r\n\t\tdeserialize,\r\n\t\tdecodeValues);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value pair array of the entries.\r\n * @param query\r\n * @param deserialize\r\n * @param decodeValues\r\n * @returns {IKeyValuePair<string, Primitive>[]}\r\n */\r\nexport function parseToArray(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IKeyValuePair<string,Primitive>[]\r\n{\r\n\tvar result:IKeyValuePair<string,Primitive>[] = [];\r\n\tparse(query,\r\n\t\t(key, value)=> {result.push({key: key, value: value});},\r\n\t\tdeserialize,\r\n\t\tdecodeValues\r\n\t);\r\n\treturn result;\r\n}\r\n\r\nexport module Separator\r\n{\r\n\texport const Entry:string = ENTRY_SEPARATOR;\r\n\texport const KeyValue:string = KEY_VALUE_SEPARATOR;\r\n}\r\nObject.freeze(Separator);\r\n\r\n"]}