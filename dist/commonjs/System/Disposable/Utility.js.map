{"version":3,"sources":["System/Disposable/Utility.ts"],"names":["dispose","disposeWithoutException","disposeThese","using","disposeSingle","disposeTheseInternal"],"mappings":";;;;;;;;;;;;;;;;qBAOiB,UAAU;;;;AAE3B,YAAY,CAAC;;AAQb,SAAA,OAAA,GAAoD;sCAAzB,WAAyB;AAAzB,mBAAyB;;;AAGnDA,wBAAoBA,CAACA,WAAWA,EAAEA,KAAKA,CAACA,CAACA;CACzCA;;AASD,SAAA,uBAAA,GAAoE;uCAAzB,WAAyB;AAAzB,mBAAyB;;;AAGnEC,WAAOA,oBAAoBA,CAACA,WAAWA,EAAEA,IAAIA,CAACA,CAACA;CAC/CA;;AAQD,SAAA,YAAA,CAA6B,WAAyB,EAAE,cAAuB,EAAA;AAE9EC,WAAOA,WAAWA,IAAIA,WAAWA,CAACA,MAAMA,GACrCA,oBAAoBA,CAACA,WAAWA,CAACA,KAAKA,EAAEA,EAAEA,cAAcA,CAACA,GACzDA,IAAIA,CAACA;CACRA;;AAiBD,SAAA,KAAA,CACC,UAAsB,EACtB,OAA2C,EAAA;AAE3CC,QACAA;AACCA,eAAOA,OAAOA,CAACA,UAAUA,CAACA,CAACA;KAC3BA,SAEDA;AACCA,qBAAaA,CAACA,UAAUA,EAAEA,KAAKA,CAACA,CAACA;KACjCA;CACDA;;AAOD,SAAA,aAAA,CACC,UAAsB,EACtB,cAAsB,EAAA;AAEtBC,QAAGA,mBAAKA,EAAEA,CAACA,UAAUA,CAACA,CAACA,MAAMA,CAACA,SAASA,CAACA,CAACA,UAAUA,EACnDA;AACCA,YAAGA,cAAcA,EACjBA;AACCA,gBACAA;AACCA,0BAAUA,CAACA,OAAOA,EAAEA,CAACA;aAEtBA,CAAAA,OAAMA,EAAEA,EACRA;AACCA,uBAAOA,EAAEA,CAACA;aACVA;SACDA,MAEAA,UAAUA,CAACA,OAAOA,EAAEA,CAACA;KACtBA;AAEDA,WAAOA,IAAIA,CAACA;CACZA;AAKD,SAAA,oBAAA,CACC,WAAyB,EACzB,cAAsB,EACN;QAAhB,KAAK,yDAAU,CAAC;;AAEhBC,QAAIA,UAAgBA,CAACA;AACrBA,QAAIA,GAAGA,GAAGA,WAAWA,CAACA,MAAMA,CAACA;AAE7BA,WAAMA,KAAKA,GAACA,GAAGA,EAAEA,KAAKA,EAAEA,EACxBA;AACCA,YAAIA,IAAIA,GAAGA,WAAWA,CAACA,KAAKA,CAACA,CAACA;AAC9BA,YAAGA,CAACA,IAAIA,EAAEA,SAASA;AACnBA,YAAGA,cAAcA,EACjBA;AACCA,gBAAIA,EAAEA,GAAGA,aAAaA,CAACA,IAAIA,EAAEA,IAAIA,CAACA,CAACA;AACnCA,gBAAGA,EAAEA,EACLA;AACCA,oBAAGA,CAACA,UAAUA,EAAEA,UAAUA,GAAGA,EAAEA,CAACA;AAChCA,0BAAUA,CAACA,IAAIA,CAACA,EAAEA,CAACA,CAACA;aACpBA;SACDA,MAEDA;AACCA,gBAAIA,OAAOA,GAAGA,KAAKA,CAACA;AACpBA,gBACAA;AACCA,6BAAaA,CAACA,IAAIA,EAAEA,KAAKA,CAACA,CAACA;AAC3BA,uBAAOA,GAAGA,IAAIA,CAACA;aACfA,SAGDA;AACCA,oBAAGA,CAACA,OAAOA,IAAIA,KAAKA,GAAGA,CAACA,GAACA,GAAGA,EAC5BA;AAGCA,wCAAoBA,CAACA,WAAWA,EAAEA,KAAKA,EAAEA,KAAKA,GAAGA,CAACA,CAACA,CAACA;iBACpDA;aACDA;AAEDA,gBAAGA,CAACA,OAAOA,EAAEA,MAAMA;SACnBA;KACDA;AAEDA,WAAOA,UAAUA,CAACA;CAClBA","file":"System/Disposable/Utility.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDisposable.d.ts\"/>\r\n///<reference path=\"../Collections/Array/IArray.d.ts\"/>\r\nimport Type from '../Types';\r\n\r\n'use strict';\r\n\r\n/**\r\n * Takes any number of disposables as arguments and attempts to dispose them.\r\n * Any exceptions thrown within a dispose are not trapped.\r\n * Use 'disposeWithoutException' to automatically trap exceptions.\r\n * @param disposables\r\n */\r\nexport function dispose(...disposables:IDisposable[]):void\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\tdisposeTheseInternal(disposables, false);\r\n}\r\n\r\n\r\n/**\r\n * Takes any number of disposables and traps any errors that occur when disposing.\r\n * Returns an array of the exceptions thrown.\r\n * @param disposables\r\n * @returns {any[]} Returns an array of exceptions that occurred, if there are any.\r\n */\r\nexport function disposeWithoutException(...disposables:IDisposable[]):any[]\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\treturn disposeTheseInternal(disposables, true);\r\n}\r\n\r\n/**\r\n * Takes an array of disposable objects and ensures they are disposed.\r\n * @param disposables\r\n * @param trapExceptions If true, prevents exceptions from being thrown when disposing.\r\n * @returns {any[]} If 'trapExceptions' is true, returns an array of exceptions that occurred, if there are any.\r\n */\r\nexport function disposeThese(disposables:IDisposable[], trapExceptions?:boolean):any[]\r\n{\r\n\treturn disposables && disposables.length\r\n\t\t? disposeTheseInternal(disposables.slice(), trapExceptions)\r\n\t\t: null;\r\n}\r\n\r\n/**\r\n * Just like in C# this 'using' function will ensure the passed disposable is disposed when the closure has finished.\r\n *\r\n * Usage:\r\n * ```typescript\r\n * using(new DisposableObject(),(myObj)=>{\r\n *   // do work with myObj\r\n * });\r\n * // myObj automatically has it's dispose method called.\r\n * ```\r\n *\r\n * @param disposable Object to be disposed.\r\n * @param closure Function call to execute.\r\n * @returns {TReturn} Returns whatever the closure's return value is.\r\n */\r\nexport function using<TDisposable extends IDisposable,TReturn>(\r\n\tdisposable:TDisposable,\r\n\tclosure:(disposable:TDisposable) => TReturn):TReturn\r\n{\r\n\ttry\r\n\t{\r\n\t\treturn closure(disposable);\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tdisposeSingle(disposable, false);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This private function makes disposing more robust for when there's no type checking.\r\n * If trapExceptions is 'true' it catches and returns any exception instead of throwing.\r\n */\r\nfunction disposeSingle(\r\n\tdisposable:IDisposable,\r\n\ttrapExceptions:boolean):any\r\n{\r\n\tif(Type.of(disposable).member('dispose').isFunction)\r\n\t{\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposable.dispose();\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\treturn ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tdisposable.dispose();\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * This dispose method assumes it's working on a local copy and is unsafe for external use.\r\n */\r\nfunction disposeTheseInternal(\r\n\tdisposables:IDisposable[],\r\n\ttrapExceptions:boolean,\r\n\tindex:number = 0):any[]\r\n{\r\n\tvar exceptions:any[];\r\n\tvar len = disposables.length;\r\n\r\n\tfor(; index<len; index++)\r\n\t{\r\n\t\tvar next = disposables[index];\r\n\t\tif(!next) continue;\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\tvar ex = disposeSingle(next, true);\r\n\t\t\tif(ex)\r\n\t\t\t{\r\n\t\t\t\tif(!exceptions) exceptions = [];\r\n\t\t\t\texceptions.push(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar success = false;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposeSingle(next, false);\r\n\t\t\t\tsuccess = true;\r\n\t\t\t}\r\n\t\t\t\t// Don't trap the exception in order to allow it to propagate the stack trace.\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tif(!success && index + 1<len)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* If code is 'continued' by the debugger,\r\n\t\t\t\t\t * need to ensure the rest of the disposables are cared for. */\r\n\t\t\t\t\tdisposeTheseInternal(disposables, false, index + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Just in case...  Should never happen, but asserts the intention.\r\n\t\t\tif(!success) break;\r\n\t\t}\r\n\t}\r\n\r\n\treturn exceptions;\r\n}\r\n"]}