{"version":3,"sources":["System.Threading/Tasks/Task.ts"],"names":["Task","Task.constructor","Task.runSynchronously","Task.start","Task.then","Task.waitWith","Task.equals","Task.delay","Task.continueWith","Task._executeEntry","Task.id","Task.result","Task.exception","Task.asyncState","Task.creationOptions","Task.status","Task.isRunning","Task.isCancelled","Task.isCompleted","Task.isFaulted","Task._executingTaskScheduler"],"mappings":"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","file":"System.Threading/Tasks/Task.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * .NET Reference:\r\n *\thttp://msdn.microsoft.com/en-us/library/dd321424%28v=vs.110%29.aspx\r\n *\thttp://referencesource.microsoft.com/#mscorlib/system/threading/Tasks/Task.cs\r\n */\r\n\r\n\r\n///<reference path=\"ITask\"/>\r\n///<reference path=\"TaskCreationOptions.d.ts\"/>\r\n///<reference path=\"../../System/Promises/IPromise.d.ts\"/>\r\nimport Type from \"../../System/Types\";\r\nimport TimeSpan from \"../../System/Time/TimeSpan\";\r\nimport DisposableBase from \"../../System/Disposable/DisposableBase\";\r\nimport CancellationToken from \"../CancellationToken\";\r\n\r\nexport default class Task<TResult>\r\nextends DisposableBase implements ITask<TResult>\r\n{\r\n\tconstructor(\r\n\t\tprivate _task:(state?:any) => TResult,\r\n\t\tprivate _asyncState?:any,\r\n\t\tprivate _cancellationToken?:CancellationToken,\r\n\t\tprivate _creationOptions:TaskCreationOptions = TaskCreationOptions.None)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._result = void 0; // Assume 'void' in the beginning.\r\n\t\tthis._status = TaskStatus.Created;\r\n\t}\r\n\r\n\tprivate _id:number;\r\n\tget id():number\r\n\t{\r\n\t\treturn this._id;\r\n\t}\r\n\r\n\r\n\tprivate _result:TResult;\r\n\tget result():TResult\r\n\t{\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tprivate _exception:Error;\r\n\tget exception():Error\r\n\t{\r\n\t\treturn this._exception;\r\n\t}\r\n\r\n\tget asyncState():any\r\n\t{\r\n\t\treturn this._asyncState;\r\n\t}\r\n\r\n\tget creationOptions():TaskCreationOptions\r\n\t{\r\n\t\treturn this._creationOptions;\r\n\t}\r\n\r\n\r\n\t// #region State\r\n\tprivate _status:TaskStatus;\r\n\tget status():TaskStatus\r\n\t{\r\n\t\treturn this._status;\r\n\t}\r\n\r\n\tget isRunning():boolean\r\n\t{\r\n\t\treturn this._status==TaskStatus.Running;\r\n\t}\r\n\r\n\tget isCancelled():boolean\r\n\t{\r\n\t\treturn this._status==TaskStatus.Canceled;\r\n\t}\r\n\r\n\tget isCompleted():boolean\r\n\t{\r\n\t\treturn this._status==TaskStatus.RanToCompletion;\r\n\t}\r\n\r\n\tget isFaulted():boolean\r\n\t{\r\n\t\treturn this._status==TaskStatus.Faulted;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\trunSynchronously(scheduler?:ITaskScheduler):void\r\n\t{\r\n\t}\r\n\r\n\tstart(scheduler?:ITaskScheduler):void\r\n\t{\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:(value:TResult)=>(IPromise<TResult>|TResult),\r\n\t\tonRejected:(reason:any)=>(IPromise<TResult>|TResult)):IPromise<TResult>\r\n\t{\r\n\t\tthrow 'not implemented yet';\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Waits for the task to be done then passes the task to the continuationAction.\r\n\t * @param continuationAction\r\n\t */\r\n\twaitWith(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>void):void;\r\n\r\n\t/**\r\n\t * Waits for the task to be done then passes the task to the continuationAction.\r\n\t * @param continuationAction\r\n\t * @param token\r\n\t */\r\n\twaitWith(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>void,\r\n\t\ttoken:CancellationToken):void;\r\n\r\n\t/**\r\n\t * Waits for the task to be done or milliseconds to pass then passes the task to the continuationAction.\r\n\t * @param continuationAction\r\n\t * @param milliseconds\r\n\t * @param token\r\n\t */\r\n\twaitWith(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>void,\r\n\t\tmilliseconds:number,\r\n\t\ttoken?:CancellationToken):void;\r\n\r\n\r\n\t/**\r\n\t * Waits for the task to be done or time to pass then passes the task to the continuationAction.\r\n\t * @param continuationAction\r\n\t * @param time\r\n\t * @param token\r\n\t */\r\n\twaitWith(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>void,\r\n\t\ttime:ITimeQuantity,\r\n\t\ttoken?:CancellationToken):void;\r\n\r\n\twaitWith(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>void,\r\n\t\ttimeOrCancel?:CancellationToken | number | ITimeQuantity,\r\n\t\ttoken?:CancellationToken):void\r\n\t{\r\n\t\tif(Type.isInstanceOf<CancellationToken>(timeOrCancel, CancellationToken))\r\n\t\t\ttoken = timeOrCancel;\r\n\r\n\t\tvar milliseconds:number = Type.isNumber(timeOrCancel)\r\n\t\t\t? timeOrCancel\r\n\t\t\t: 0;\r\n\r\n\t\tif(Type.isInstanceOf<TimeSpan>(timeOrCancel, TimeSpan))\r\n\t\t\tmilliseconds = timeOrCancel.milliseconds;\r\n\r\n\t\t// TODO: Above is just the scaffold.  Next up, respond to parameters.\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tequals(other:Task<TResult>):boolean\r\n\t{\r\n\t\treturn this===other || this.id===other.id;\r\n\t}\r\n\r\n\r\n\tdelay(milliseconds:number):ITask<TResult>;\r\n\tdelay(time:ITimeQuantity):ITask<TResult>;\r\n\tdelay(time:number|ITimeQuantity):ITask<TResult>\r\n\t{\r\n\t\tthrow 'not implemented yet';\r\n\t}\r\n\r\n\r\n\tcontinueWith<TContinue>(continuationAction:(task:ITask<TResult>)=>TContinue):ITask<TContinue>;\r\n\r\n\tcontinueWith<TContinue>(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>TContinue,\r\n\t\tcontinuationOptions:TaskContinuationOptions,\r\n\t\tscheduler:ITaskScheduler):ITask<TContinue>;\r\n\r\n\tcontinueWith<TContinue>(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>TContinue,\r\n\t\tscheduler:ITaskScheduler):ITask<TContinue>;\r\n\r\n\tcontinueWith<TContinue>(\r\n\t\tcontinuationAction:(task:ITask<TResult>)=>TContinue,\r\n\t\tcancellationToken:CancellationToken,\r\n\t\tcontinuationOptions:TaskContinuationOptions,\r\n\t\tscheduler:ITaskScheduler):ITask<TContinue>;\r\n\r\n\tcontinueWith<TContinue, TState>(\r\n\t\tcontinuationAction:(\r\n\t\t\ttask:ITask<TResult>,\r\n\t\t\tstate:TState)=>TContinue,\r\n\t\tstate:TState,\r\n\t\tcancellationToken:CancellationToken,\r\n\t\tcontinuationOptions:TaskContinuationOptions,\r\n\t\tscheduler:ITaskScheduler):ITask<TContinue>;\r\n\r\n\tcontinueWith<TContinue, TState>(\r\n\t\tcontinuationAction:(\r\n\t\t\ttask:ITask<TResult>,\r\n\t\t\tstate:TState)=>TContinue,\r\n\t\tstate:TState,\r\n\t\tcontinuationOptions:TaskContinuationOptions,\r\n\t\tscheduler:ITaskScheduler):ITask<TContinue>;\r\n\r\n\tcontinueWith<TContinue, TState>(\r\n\t\tcontinuationAction:(\r\n\t\t\ttask:ITask<TResult>,\r\n\t\t\tstate:TState)=>TContinue,\r\n\t\ta?:TState|CancellationToken|ITaskScheduler|TaskContinuationOptions,\r\n\t\tb?:CancellationToken|ITaskScheduler|TaskContinuationOptions,\r\n\t\tc?:ITaskScheduler|TaskContinuationOptions,\r\n\t\td?:ITaskScheduler):ITask<TContinue>\r\n\t{\r\n\t\tthrow 'not implemented yet';\r\n\t}\r\n\r\n\tprivate _scheduler:ITaskScheduler;\r\n\t// Internal...\r\n\tget _executingTaskScheduler():ITaskScheduler\r\n\t{\r\n\t\treturn this._scheduler;\r\n\t}\r\n\r\n\t_executeEntry(bPreventDoubleExecution:boolean):boolean\r\n\t{\r\n\t\t/*\r\n\t\t if (bPreventDoubleExecution || ((Options & (TaskCreationOptions)InternalTaskOptions.SelfReplicating) != 0))\r\n\t\t {\r\n\t\t int previousState = 0;\r\n\r\n\t\t // Do atomic state transition from queued to invoked. If we observe a task that's already invoked,\r\n\t\t // we will return false so that TaskScheduler.ExecuteTask can throw an exception back to the custom scheduler.\r\n\t\t // However we don't want this exception to be throw if the task was already canceled, because it's a\r\n\t\t // legitimate scenario for custom schedulers to dequeue a task and mark it as canceled (example: throttling scheduler)\r\n\r\n\t\t if (!AtomicStateUpdate(TASK_STATE_DELEGATE_INVOKED,\r\n\t\t    TASK_STATE_DELEGATE_INVOKED | TASK_STATE_COMPLETED_MASK,\r\n\t\t    ref previousState) && (previousState & TASK_STATE_CANCELED) == 0)\r\n\t\t {\r\n\t\t    // This task has already been invoked.  Don't invoke it again.\r\n\t\t    return false;\r\n\t\t }\r\n\t\t }\r\n\t\t else\r\n\t\t {\r\n\t\t    // Remember that we started running the task delegate.\r\n\t\t    m_stateFlags |= TASK_STATE_DELEGATE_INVOKED;\r\n\t\t }\r\n\r\n\t\t if (!IsCancellationRequested && !IsCanceled)\r\n\t\t {\r\n\t\t    ExecuteWithThreadLocal(ref t_currentTask);\r\n\t\t }\r\n\t\t else if (!IsCanceled)\r\n\t\t {\r\n\t\t    int prevState = Interlocked.Exchange(ref m_stateFlags, m_stateFlags | TASK_STATE_CANCELED);\r\n\t\t\tif ((prevState & TASK_STATE_CANCELED) == 0)\r\n\t\t\t{\r\n\t\t\t    CancellationCleanupLogic();\r\n\t\t\t}\r\n\t\t }\r\n\t\t */\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n *  Task creation flags which are only used internally.\r\n */\r\nconst enum InternalTaskOptions\r\n{\r\n\t/**\r\n\t * Specifies \"No internal task options\"\r\n\t */\r\n\tNone,\r\n\r\n\t/**\r\n\t * Used to filter out internal vs. public task creation options.\r\n\t */\r\n\tInternalOptionsMask = 0x0000FF00,\r\n\r\n\tChildReplica        = 0x0100,\r\n\tContinuationTask    = 0x0200,\r\n\tPromiseTask         = 0x0400,\r\n\tSelfReplicating     = 0x0800,\r\n\r\n\t/**\r\n\t *  Store the presence of TaskContinuationOptions.LazyCancellation, since it does not directly\r\n\t *  translate into any TaskCreationOptions.\r\n\t */\r\n\tLazyCancellation    = 0x1000,\r\n\r\n\t/**\r\n\t * Specifies that the task will be queued by the runtime before handing it over to the user.\r\n\t *  This flag will be used to skip the cancellation-token registration step, which is only meant for unstarted tasks.\r\n\t */\r\n\tQueuedByRuntime     = 0x2000,\r\n\r\n\t/**\r\n\t *  Denotes that Dispose should be a complete nop for a Task.  Used when constructing tasks that are meant to be cached/reused.\r\n\t */\r\n\tDoNotDispose        = 0x4000\r\n}\r\n"]}