{"version":3,"sources":["System/Threading/Tasks/Parallel.js","System/Threading/Tasks/Parallel.ts"],"names":["define","require","exports","Promise_1","Types_1","Worker_1","deferImmediate_1","Environment_1","extend","from","to","_i","_a","Object","keys","length","i","interact","w","onMessage","onError","message","onmessage","onerror","VOID0","postMessage","terminate","worker","deferImmediate","URL","self","Type","UNDEFINED","webkitURL","_supports","isNodeJS","Worker","defaults","evalPath","__dirname","maxConcurrency","cpus","navigator","hardwareConcurrency","allowSynchronous","env","envNamespace","WorkerPromise","_super","data","call","this","resolve","reject","response","e","__extends","Promise","Parallel","options","_requiredScripts","_requiredFunctions","prototype","getWorkerSource","task","scripts","functions","preStr","join","functions_1","name_1","name","fn","source","toString","JSON","stringify","ns","required","arguments","requireThese","required_1","a","STRING","push","FUNCTION","OBJECT","TypeError","_spawnWorker","src","Error","blob","Blob","type","url","createObjectURL","startNew","_","finallyThis","defineProperty","get","enumerable","configurable","forEach","_this","slice","error","resolved","_loop_1","len","all","map","d","r","j","ex","thenThis","value","next","wp_1","thenSynchronous","dispose","Math","min","state_1","Fulfilled"],"mappings":"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","file":"System/Threading/Tasks/Parallel.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\n */\ndefine([\"require\", \"exports\", \"../../Promises/Promise\", \"../../Types\", \"../Worker\", \"../deferImmediate\", \"../../Environment\"], function (require, exports, Promise_1, Types_1, Worker_1, deferImmediate_1, Environment_1) {\n    \"use strict\";\n    var VOID0 = void 0, URL = typeof self !== Types_1.Type.UNDEFINED ? (self.URL ? self.URL : self.webkitURL) : null, _supports = (Environment_1.isNodeJS || self.Worker) ? true : false;\n    var defaults = {\n        evalPath: Environment_1.isNodeJS ? __dirname + '/eval.js' : null,\n        maxConcurrency: Environment_1.isNodeJS ? require('os').cpus().length : (navigator.hardwareConcurrency || 4),\n        allowSynchronous: true,\n        env: {},\n        envNamespace: 'env'\n    };\n    function extend(from, to) {\n        if (!to)\n            to = {};\n        for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\n            var i = _a[_i];\n            if (to[i] === void 0)\n                to[i] = from[i];\n        }\n        return to;\n    }\n    function interact(w, onMessage, onError, message) {\n        if (onMessage)\n            w.onmessage = onMessage;\n        if (onError)\n            w.onerror = onError;\n        if (message !== VOID0)\n            w.postMessage(message);\n    }\n    function terminate(worker) {\n        if (worker)\n            deferImmediate_1.deferImmediate(function () { return worker.terminate(); });\n        return null;\n    }\n    var WorkerPromise = (function (_super) {\n        __extends(WorkerPromise, _super);\n        function WorkerPromise(worker, data) {\n            _super.call(this, function (resolve, reject) {\n                interact(worker, function (response) {\n                    resolve(response.data);\n                }, function (e) {\n                    reject(e);\n                }, data);\n            }, true);\n        }\n        return WorkerPromise;\n    }(Promise_1.Promise));\n    var Parallel = (function () {\n        function Parallel(options) {\n            this.options = extend(defaults, options);\n            this._requiredScripts = [];\n            this._requiredFunctions = [];\n        }\n        Parallel.prototype.getWorkerSource = function (task, env) {\n            var scripts = this._requiredScripts, functions = this._requiredFunctions;\n            var preStr = '';\n            if (!Environment_1.isNodeJS && scripts.length) {\n                preStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\n            }\n            for (var _i = 0, functions_1 = functions; _i < functions_1.length; _i++) {\n                var _a = functions_1[_i], name_1 = _a.name, fn = _a.fn;\n                var source = fn.toString();\n                preStr += name_1\n                    ? \"var \" + name_1 + \" = \" + source + \";\"\n                    : source;\n            }\n            env = JSON.stringify(env || {});\n            var ns = this.options.envNamespace;\n            return preStr + (Environment_1.isNodeJS\n                ? \"process.on(\\\"message\\\", function(e) {global.\" + ns + \" = \" + env + \";process.send(JSON.stringify((\" + task.toString() + \")(JSON.parse(e).data)))})\"\n                : \"self.onmessage = function(e) {var global = {}; global.\" + ns + \" = \" + env + \"';self.postMessage((\" + task.toString() + \")(e.data))}\");\n        };\n        Parallel.prototype.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i - 0] = arguments[_i];\n            }\n            return this.requireThese(required);\n        };\n        Parallel.prototype.requireThese = function (required) {\n            for (var _i = 0, required_1 = required; _i < required_1.length; _i++) {\n                var a = required_1[_i];\n                switch (typeof a) {\n                    case Types_1.Type.STRING:\n                        this._requiredScripts.push(a);\n                        break;\n                    case Types_1.Type.FUNCTION:\n                        this._requiredFunctions.push({ fn: a });\n                        break;\n                    case Types_1.Type.OBJECT:\n                        this._requiredFunctions.push(a);\n                        break;\n                    default:\n                        throw new TypeError(\"Invalid type.\");\n                }\n            }\n            return this;\n        };\n        Parallel.prototype._spawnWorker = function (task, env) {\n            var worker;\n            var src = this.getWorkerSource(task, env);\n            if (Worker_1.default === VOID0)\n                return VOID0;\n            var scripts = this._requiredScripts, evalPath = this.options.evalPath;\n            if (!evalPath) {\n                if (Environment_1.isNodeJS)\n                    throw new Error(\"Can't use NodeJD without eval.js!\");\n                if (scripts.length)\n                    throw new Error(\"Can't use required scripts without eval.js!\");\n                if (!URL)\n                    throw new Error(\"Can't create a blob URL in this browser!\");\n            }\n            if (Environment_1.isNodeJS || scripts.length || !URL) {\n                worker = new Worker_1.default(evalPath);\n                worker.postMessage(src);\n            }\n            else if (URL) {\n                var blob = new Blob([src], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                worker = new Worker_1.default(url);\n            }\n            return worker;\n        };\n        Parallel.prototype.startNew = function (data, task, env) {\n            var _ = this;\n            var worker = _._spawnWorker(task, extend(_.options.env, env || {}));\n            if (worker)\n                return new WorkerPromise(worker, data)\n                    .finallyThis(function () { return worker.terminate(); });\n            if (_.options.allowSynchronous)\n                return new Promise_1.Promise(function (resolve, reject) {\n                    try {\n                        resolve(task(data));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            throw new Error('Workers do not exist and synchronous operation not allowed!');\n        };\n        Object.defineProperty(Parallel, \"isSupported\", {\n            get: function () { return _supports; },\n            enumerable: true,\n            configurable: true\n        });\n        Parallel.options = function (options) {\n            return new Parallel(options);\n        };\n        Parallel.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i - 0] = arguments[_i];\n            }\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.requireThese = function (required) {\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.startNew = function (data, task, env) {\n            return (new Parallel()).startNew(data, task, env);\n        };\n        Parallel.prototype.forEach = function (data, task, env) {\n            var _this = this;\n            if (!data || !data.length)\n                return new Promise_1.Fulfilled();\n            data = data.slice();\n            return new Promise_1.Promise(function (resolve, reject) {\n                var maxConcurrency = _this.options.maxConcurrency, error;\n                var i = 0, resolved = 0;\n                var _loop_1 = function(w, len) {\n                    var worker = _this._spawnWorker(task, env);\n                    if (!worker) {\n                        if (!_this.options.allowSynchronous)\n                            throw new Error('Workers do not exist and synchronous operation not allowed!');\n                        Promise_1.Promise\n                            .all(data.map(function (d) { return new Promise_1.Promise(function (r, j) {\n                            try {\n                                r(task(d));\n                            }\n                            catch (ex) {\n                                j(ex);\n                            }\n                        }); }))\n                            .thenThis(function () { return resolve; }, reject);\n                        return { value: void 0 };\n                    }\n                    var next = function () {\n                        if (error) {\n                            worker = terminate(worker);\n                        }\n                        if (worker) {\n                            if (i < len) {\n                                var wp_1 = new WorkerPromise(worker, data[i++]);\n                                wp_1\n                                    .thenSynchronous(next, function (e) {\n                                    if (!error) {\n                                        error = e;\n                                        reject(e);\n                                        worker = terminate(worker);\n                                    }\n                                })\n                                    .thenThis(function () {\n                                    resolved++;\n                                    if (resolved > len)\n                                        throw Error(\"Resolved count exceeds data length.\");\n                                    if (resolved === len)\n                                        resolve();\n                                })\n                                    .finallyThis(function () {\n                                    return wp_1.dispose();\n                                });\n                            }\n                            else {\n                                worker = terminate(worker);\n                            }\n                        }\n                    };\n                    next();\n                };\n                for (var w = 0, len = data.length; !error && i < Math.min(len, maxConcurrency); w++) {\n                    var state_1 = _loop_1(w, len);\n                    if (typeof state_1 === \"object\") return state_1.value;\n                }\n            });\n        };\n        return Parallel;\n    }());\n    exports.Parallel = Parallel;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Parallel;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\r\n */\r\n\r\nimport {Promise, PromiseBase, Fulfilled} from \"../../Promises/Promise\";\r\nimport {Type} from \"../../Types\";\r\nimport Worker from \"../Worker\";\r\nimport {WorkerLike} from \"../WorkerType\";\r\nimport {deferImmediate} from \"../deferImmediate\";\r\nimport {isNodeJS} from \"../../Environment\";\r\n\r\ndeclare const navigator:any;\r\ndeclare const require:any;\r\ndeclare const self:any;\r\ndeclare const __dirname:string;\r\n\r\n//noinspection JSUnusedAssignment\r\nconst\r\n\tVOID0:any = void 0,\r\n\tURL       = typeof self!==Type.UNDEFINED ? (self.URL ? self.URL : self.webkitURL) : null,\r\n\t_supports = (isNodeJS || self.Worker) ? true : false; // node always supports parallel\r\n\r\nexport interface ParallelOptions\r\n{\r\n\t/**\r\n\t * This is the path to the file eval.js.  This is required when running in node, and required for some browsers (IE 10) in order to work around cross-domain restrictions for web workers.  Defaults to the same location as parallel.js in node environments, and null in the browser.\r\n\t **/\r\n\tevalPath?:string;\r\n\r\n\t/**\r\n\t * The maximum number of permitted worker threads.  This will default to 4, or the number of CPUs on your computer if you're running node.\r\n\t **/\r\n\tmaxConcurrency?:number;\r\n\r\n\t/**\r\n\t * If WebWorkers are not available, whether or not to fall back to synchronous processing using setTimeout.  Defaults to true.\r\n\t **/\r\n\tallowSynchronous?:boolean;\r\n\r\n\tenv?:any\r\n\tenvNamespace?:string\r\n}\r\n\r\n//noinspection JSUnusedAssignment\r\nconst defaults:ParallelOptions = {\r\n\tevalPath: isNodeJS ? __dirname + '/eval.js' : null,\r\n\tmaxConcurrency: isNodeJS ? require('os').cpus().length : (navigator.hardwareConcurrency || 4),\r\n\tallowSynchronous: true,\r\n\tenv: {},\r\n\tenvNamespace: 'env'\r\n};\r\n\r\nfunction extend<T extends any>(from:T, to:T):T\r\n{\r\n\tif(!to) to = <any>{};\r\n\tfor(var i of Object.keys(from))\r\n\t{\r\n\t\tif(to[i]=== void 0) to[i] = from[i];\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nfunction interact(\r\n\tw:WorkerLike,\r\n\tonMessage:(msg:{data:any})=>void,\r\n\tonError:(e:any)=>void,\r\n\tmessage?:any):void\r\n{\r\n\tif(onMessage) w.onmessage = onMessage;\r\n\tif(onError) w.onerror = onError;\r\n\tif(message!==VOID0) w.postMessage(message);\r\n}\r\n\r\nfunction terminate(worker:WorkerLike):any\r\n{\r\n\tif(worker) deferImmediate(()=>worker.terminate());\r\n\treturn null;\r\n}\r\n\r\nclass WorkerPromise<T> extends Promise<T>\r\n{\r\n\tconstructor(worker:WorkerLike, data:any)\r\n\t{\r\n\t\tsuper((resolve, reject)=>\r\n\t\t{\r\n\t\t\tinteract(\r\n\t\t\t\tworker,\r\n\t\t\t\t(response:{data:any})=>\r\n\t\t\t\t{\r\n\t\t\t\t\tresolve(response.data);\r\n\t\t\t\t},\r\n\t\t\t\t(e:any)=>\r\n\t\t\t\t{\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t},\r\n\t\t\t\tdata)\r\n\t\t}, true);\r\n\t}\r\n}\r\n\r\nexport type RequireType = string | Function | {name?:string,fn:Function};\r\n\r\nexport class Parallel\r\n{\r\n\r\n\toptions:ParallelOptions;\r\n\t_requiredScripts:string[];\r\n\t_requiredFunctions:{name?:string,fn:Function}[];\r\n\r\n\tconstructor(options?:ParallelOptions)\r\n\t{\r\n\t\tthis.options = extend(defaults, options);\r\n\r\n\t\tthis._requiredScripts = [];\r\n\t\tthis._requiredFunctions = [];\r\n\t}\r\n\r\n\tgetWorkerSource(task:Function, env?:any):string\r\n\t{\r\n\t\tvar scripts = this._requiredScripts, functions = this._requiredFunctions;\r\n\t\tvar preStr = '';\r\n\r\n\t\tif(!isNodeJS && scripts.length)\r\n\t\t{\r\n\t\t\tpreStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\r\n\t\t}\r\n\r\n\t\tfor(let {name, fn} of functions)\r\n\t\t{\r\n\t\t\tvar source = fn.toString();\r\n\t\t\tpreStr += name\r\n\t\t\t\t? `var ${name} = ${source};`\r\n\t\t\t\t: source;\r\n\t\t}\r\n\r\n\r\n\t\tenv = JSON.stringify(env || {});\r\n\r\n\t\tconst ns = this.options.envNamespace;\r\n\r\n\t\treturn preStr + (\r\n\t\t\t\tisNodeJS\r\n\t\t\t\t\t? `process.on(\"message\", function(e) {global.${ns} = ${env};process.send(JSON.stringify((${task.toString()})(JSON.parse(e).data)))})`\r\n\t\t\t\t\t: `self.onmessage = function(e) {var global = {}; global.${ns} = ${env}';self.postMessage((${task.toString()})(e.data))}`\r\n\t\t\t);\r\n\t}\r\n\r\n\trequire(...required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn this.requireThese(required);\r\n\t}\r\n\r\n\trequireThese(required:RequireType[]):Parallel\r\n\t{\r\n\t\tfor(let a of required)\r\n\t\t{\r\n\t\t\tswitch(typeof a)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\t\tthis._requiredScripts.push(<string>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.FUNCTION:\r\n\t\t\t\t\tthis._requiredFunctions.push({fn: <Function>a});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.OBJECT:\r\n\t\t\t\t\tthis._requiredFunctions.push(<{name?:string,fn:Function}>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new TypeError(\"Invalid type.\");\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _spawnWorker(task:Function, env?:any):WorkerLike\r\n\t{\r\n\t\tvar worker:WorkerLike;\r\n\t\tvar src = this.getWorkerSource(task, env);\r\n\r\n\t\tif(Worker===VOID0) return VOID0;\r\n\r\n\t\tvar scripts = this._requiredScripts, evalPath = this.options.evalPath;\r\n\r\n\t\tif(!evalPath)\r\n\t\t{\r\n\t\t\tif(isNodeJS)\r\n\t\t\t\tthrow new Error(\"Can't use NodeJD without eval.js!\");\r\n\t\t\tif(scripts.length)\r\n\t\t\t\tthrow new Error(\"Can't use required scripts without eval.js!\");\r\n\t\t\tif(!URL)\r\n\t\t\t\tthrow new Error(\"Can't create a blob URL in this browser!\");\r\n\t\t}\r\n\r\n\t\tif(isNodeJS || scripts.length || !URL)\r\n\t\t{\r\n\t\t\tworker = new Worker(evalPath);\r\n\t\t\tworker.postMessage(src);\r\n\t\t}\r\n\t\telse if(URL)\r\n\t\t{\r\n\t\t\tvar blob = new Blob([src], {type: 'text/javascript'});\r\n\t\t\tvar url = URL.createObjectURL(blob);\r\n\r\n\t\t\tworker = new Worker(url);\r\n\t\t}\r\n\r\n\t\treturn worker;\r\n\t}\r\n\r\n\tstartNew<T,U>(data:T, task:(data:T) => U, env?:any):PromiseBase<U>\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\tlet worker = _._spawnWorker(task, extend(_.options.env, env || {}));\r\n\t\tif(worker)\r\n\t\t\treturn new WorkerPromise<U>(worker, data)\r\n\t\t\t\t.finallyThis(()=>worker.terminate());\r\n\r\n\t\tif(_.options.allowSynchronous)\r\n\t\t\treturn new Promise<U>(\r\n\t\t\t\t(resolve, reject)=>\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve(task(data));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\t}\r\n\r\n\tstatic get isSupported() { return _supports; }\r\n\r\n\tstatic options(options?:ParallelOptions):Parallel\r\n\t{\r\n\t\treturn new Parallel(options);\r\n\t}\r\n\r\n\tstatic require(...required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic requireThese(required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic startNew<T,U>(data:T, task:(data:T) => U, env?:any):PromiseBase<U>\r\n\t{\r\n\t\treturn (new Parallel()).startNew(data, task, env);\r\n\t}\r\n\r\n\tforEach<T>(data:T[], task:(data:T) => void, env?:any):PromiseBase<void>\r\n\t{\r\n\t\tif(!data || !data.length) return new Fulfilled<void>();\r\n\t\tdata = data.slice(); // Never use the original.\r\n\t\treturn new Promise<void>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tvar {maxConcurrency} = this.options, error:any;\r\n\t\t\tlet i = 0, resolved = 0;\r\n\t\t\tfor(let w = 0, len = data.length; !error && i<Math.min(len, maxConcurrency); w++)\r\n\t\t\t{\r\n\t\t\t\tlet worker = this._spawnWorker(task, env);\r\n\r\n\t\t\t\tif(!worker)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!this.options.allowSynchronous)\r\n\t\t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\r\n\t\t\t\t\tPromise\r\n\t\t\t\t\t\t.all(data.map(d=>new Promise<void>((r, j)=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tr(task(d));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch(ex)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tj(ex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})))\r\n\t\t\t\t\t\t.thenThis(()=>resolve, reject);\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet next = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(error)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworker = terminate(worker);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(worker)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(i<len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet wp = new WorkerPromise(worker, data[i++]);\r\n\t\t\t\t\t\t\twp\r\n\t\t\t\t\t\t\t\t.thenSynchronous(next, e=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(!error)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\terror = e;\r\n\t\t\t\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t\t\t\t\tworker = terminate(worker);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.thenThis(()=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresolved++;\r\n\t\t\t\t\t\t\t\t\tif(resolved>len) throw Error(\"Resolved count exceeds data length.\");\r\n\t\t\t\t\t\t\t\t\tif(resolved===len) resolve();\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.finallyThis(()=>\r\n\t\t\t\t\t\t\t\t\twp.dispose());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tworker = terminate(worker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnext();\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t}\r\n}\r\n\r\n//\r\n// export class ParallelExtended<TEntry, T extends Array<TEntry>> extends Parallel<T>\r\n// {\r\n//\r\n// \tprivate _spawnMapWorker<N>(\r\n// \t\tdata:T,\r\n// \t\ttask:(data:N) => N,\r\n// \t\tdone:(e?:any, w?:WorkerLike)=>void,\r\n// \t\tenv:any,\r\n// \t\tworker?:WorkerLike):Promise<N>\r\n// \t{\r\n// \t\tconst _ = this;\r\n//\r\n// \t\tif(!worker) worker = _._spawnWorker(task, env);\r\n// \t\tif(worker)\r\n//\r\n// \t\t\treturn new Promise<N>(resolve=>\r\n// \t\t\t{\r\n// \t\t\t\tif(worker!==VOID0)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tinteract(\r\n// \t\t\t\t\t\tworker,\r\n// \t\t\t\t\t\t(msg:{data:any})=>\r\n// \t\t\t\t\t\t{\r\n// \t\t\t\t\t\t\tresolve(msg.data);\r\n// \t\t\t\t\t\t\tdone(null, worker);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\t(e:any)=>\r\n// \t\t\t\t\t\t{\r\n// \t\t\t\t\t\t\tdeferImmediate(()=>worker.terminate());\r\n// \t\t\t\t\t\t\tdone(e);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\t_.data[i]);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.options.allowSynchronous)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tdeferImmediate(()=>\r\n// \t\t\t\t\t{\r\n// \t\t\t\t\t\t_.data[i] = task(_.data[i]);\r\n// \t\t\t\t\t\tdone();\r\n// \t\t\t\t\t});\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n// \t\t\t\t}\r\n// \t\t\t}, true);\r\n//\r\n//\r\n// \t}\r\n//\r\n// \tprivate _spawnReduceWorker<N>(\r\n// \t\tdata:any,\r\n// \t\tcb:(data:N) => N,\r\n// \t\tdone:(err?:any, wrk?:WorkerLike)=>void,\r\n// \t\tenv?:any,\r\n// \t\twrk?:WorkerLike)\r\n// \t{\r\n// \t\tconst _ = this;\r\n// \t\tif(!wrk) wrk = _._spawnWorker(cb, env);\r\n//\r\n// \t\tif(wrk!==VOID0)\r\n// \t\t{\r\n// \t\t\tinteract(wrk,\r\n// \t\t\t\tmsg=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\t_.data[_.data.length] = msg.data;\r\n// \t\t\t\t\tdone(null, wrk);\r\n// \t\t\t\t},\r\n// \t\t\t\te=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\twrk.terminate();\r\n// \t\t\t\t\tdone(e, null);\r\n// \t\t\t\t},\r\n// \t\t\t\tdata);\r\n// \t\t}\r\n// \t\telse if(_.options.allowSynchronous)\r\n// \t\t{\r\n// \t\t\tdeferImmediate(()=>\r\n// \t\t\t{\r\n// \t\t\t\t_.data[_.data.length] = cb(data);\r\n// \t\t\t\tdone();\r\n// \t\t\t});\r\n// \t\t}\r\n// \t\telse\r\n// \t\t{\r\n// \t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n// \t\t}\r\n// \t}\r\n//\r\n//\r\n// \tmap<N>(callback:(data:N) => N, env?:any)\r\n// \t{\r\n// \t\tenv = extend(this.options.env, env || {});\r\n// \t\tconst _ = this;\r\n// \t\tif(!Array.isArray(_.data))\r\n// \t\t{\r\n// \t\t\treturn _.start(callback, env);\r\n// \t\t}\r\n//\r\n// \t\tvar startedOps = 0;\r\n// \t\tvar doneOps = 0;\r\n//\r\n// \t\t_._operation = new Promise<any>((resolve, reject)=>\r\n// \t\t{\r\n//\r\n// \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\r\n// \t\t\t{\r\n// \t\t\t\tif(err)\r\n// \t\t\t\t{\r\n// \t\t\t\t\treject(err);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(++doneOps===_.data.length)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tresolve(_.data);\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(startedOps<_.data.length)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t_._spawnMapWorker(startedOps++, callback, done, env, wrk);\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n//\r\n// \t\t\tfor(\r\n// \t\t\t\t; startedOps - doneOps<_.options.maxConcurrency && startedOps<_.data.length;\r\n// \t\t\t\t  ++startedOps\r\n// \t\t\t)\r\n// \t\t\t{\r\n// \t\t\t\t_._spawnMapWorker(startedOps, callback, done, env);\r\n// \t\t\t}\r\n// \t\t}, true);\r\n// \t\treturn this;\r\n// \t}\r\n//\r\n//\r\n// \treduce<N>(cb:(data:N[]) => N, env?:any):Parallel<T>\r\n// \t{\r\n// \t\tenv = extend(this.options.env, env || {});\r\n//\r\n// \t\tvar runningWorkers = 0;\r\n// \t\tconst _ = this;\r\n//\r\n//\r\n// \t\t_._operation = new Promise<any>((resolve, reject)=>\r\n// \t\t{\r\n//\r\n// \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\r\n// \t\t\t{\r\n// \t\t\t\t--runningWorkers;\r\n// \t\t\t\tif(err)\r\n// \t\t\t\t{\r\n// \t\t\t\t\treject(err);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length===1 && runningWorkers===0)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tresolve(_.data = _.data[0]);\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length>1)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[0], _.data[1]], cb, done, env, wrk);\r\n// \t\t\t\t\t_.data.splice(0, 2);\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n//\r\n// \t\t\tif(_.data.length===1)\r\n// \t\t\t{\r\n// \t\t\t\tresolve(_.data[0]);\r\n// \t\t\t}\r\n// \t\t\telse\r\n// \t\t\t{\r\n// \t\t\t\tfor(var i = 0; i<_.options.maxConcurrency && i<Math.floor(_.data.length/2); ++i)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[i*2], _.data[i*2 + 1]], cb, done, env);\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\t_.data.splice(0, i*2);\r\n// \t\t\t}\r\n// \t\t}, true);\r\n// \t\treturn this;\r\n//\r\n// \t}\r\n//\r\n//\r\n// }\r\n\r\nexport default Parallel;\r\n"]}