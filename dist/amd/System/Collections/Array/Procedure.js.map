{"version":3,"sources":["System/Collections/Array/Procedure.js","System/Collections/Array/Procedure.ts"],"names":["define","require","exports","sum","source","ignoreNaN","average","product","ifSet","start","predicate","min","max"],"mappings":"AAAAA,QAAQ,UAAW,WAAY,SAAUC,EAASC,GCMlD,QAAAC,GAAoBC,EAAiBC,GAEpCF,GAFoCA,SAAAA,IAAAA,GAAAA,IAEhCA,IAAWA,EAAOA,OACrBA,MAAOA,EAERA,IAAIA,GAASA,CAabA,OAZGA,GACFA,EAAOA,QAAQA,SAAAA,GAEVA,MAAMA,KAAIA,GAAUA,KAGzBA,EAAOA,MAAMA,SAAAA,GAGZA,MADAA,IAAUA,GACFA,MAAMA,KAGTA,EAGR,QAAAG,GAAwBF,EAAiBC,GAExCC,GAFwCA,SAAAA,IAAAA,GAAAA,IAEpCA,IAAWA,EAAOA,OACrBA,MAAOA,IAERA,IAAgBA,GAAZA,EAASA,CAyBbA,OAxBGA,IAEFA,EAAQA,EACRA,EAAOA,QAAQA,SAAAA,GAEVA,MAAMA,KAETA,GAAUA,EACVA,SAOFA,EAAQA,EAAOA,OACfA,EAAOA,MAAMA,SAAAA,GAGZA,MADAA,IAAUA,GACFA,MAAMA,OAKPA,GAASA,MAAMA,GAAWA,IAAOA,EAAOA,EAGlD,QAAAC,GAAwBH,EAAiBC,GAExCE,GAFwCA,SAAAA,IAAAA,GAAAA,IAEpCA,IAAWA,EAAOA,OACrBA,MAAOA,IAERA,IAAIA,GAASA,CACbA,IAAGA,EACHA,CACCA,GAAIA,IAAQA,CACZA,GAAOA,QAAQA,SAAAA,GAEVA,MAAMA,KAETA,GAAUA,EACNA,IAAOA,GAAQA,MAIjBA,IACHA,EAASA,SAIVA,GAAOA,MAAMA,SAAAA,GAEZA,MAAGA,OAAMA,IAERA,EAASA,KACFA,IAGRA,GAAUA,GAEHA,IAITA,OAAOA,GAGR,QAAAC,GACCJ,EACAK,EACAJ,EACAK,GAEAF,IAAIA,IAAWA,EAAOA,OACrBA,MAAOA,IAERA,IAAIA,GAASA,CACbA,IAAGA,EACHA,CACCA,GAAIA,IAAQA,CACZA,GAAOA,QAAQA,SAAAA,GAEVA,MAAMA,KAENA,EAAUA,EAAGA,KACfA,EAASA,GACNA,IAAOA,GAAQA,MAIjBA,IACHA,EAASA,SAIVA,GAAOA,MAAMA,SAAAA,GAEZA,MAAGA,OAAMA,IAERA,EAASA,KACFA,IAGLA,EAAUA,EAAGA,KACfA,EAASA,IAEHA,IAGTA,OAAOA,GAIR,QAAAG,GAAoBP,EAAiBC,GAEpCM,MAFoCA,UAAAA,IAAAA,GAAAA,GAE7BA,EAAMA,IAASA,EAAAA,GAAUA,EAAWA,SAACA,EAAGA,GAAWA,MAAEA,GAAFA,IAG3D,QAAAC,GAAoBR,EAAiBC,GAEpCO,MAFoCA,UAAAA,IAAAA,GAAAA,GAE7BA,EAAMA,IAASA,EAAAA,GAAUA,EAAWA,SAACA,EAAGA,GAAWA,MAAAA,GAAEA,IAnJ7CV,EAAAC,IAAGA,EAqBHD,EAAAI,QAAOA,EAiCPJ,EAAAK,QAAOA,EAsFPL,EAAAS,IAAGA,EAKHT,EAAAU,IAAGA","file":"System/Collections/Array/Procedure.js","sourcesContent":["define([\"require\", \"exports\"], function (require, exports) {\n    function sum(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        if (!source || !source.length)\n            return 0;\n        var result = 0;\n        if (ignoreNaN)\n            source.forEach(function (n) {\n                if (!isNaN(n))\n                    result += n;\n            });\n        else\n            source.every(function (n) {\n                result += n;\n                return !isNaN(result);\n            });\n        return result;\n    }\n    exports.sum = sum;\n    function average(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        if (!source || !source.length)\n            return NaN;\n        var result = 0, count;\n        if (ignoreNaN) {\n            count = 0;\n            source.forEach(function (n) {\n                if (!isNaN(n)) {\n                    result += n;\n                    count++;\n                }\n            });\n        }\n        else {\n            count = source.length;\n            source.every(function (n) {\n                result += n;\n                return !isNaN(result);\n            });\n        }\n        return (!count || isNaN(result)) ? NaN : (result / count);\n    }\n    exports.average = average;\n    function product(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        if (!source || !source.length)\n            return NaN;\n        var result = 1;\n        if (ignoreNaN) {\n            var found = false;\n            source.forEach(function (n) {\n                if (!isNaN(n)) {\n                    result *= n;\n                    if (!found)\n                        found = true;\n                }\n            });\n            if (!found)\n                result = NaN;\n        }\n        else {\n            source.every(function (n) {\n                if (isNaN(n)) {\n                    result = NaN;\n                    return false;\n                }\n                result *= n;\n                return true;\n            });\n        }\n        return result;\n    }\n    exports.product = product;\n    function ifSet(source, start, ignoreNaN, predicate) {\n        if (!source || !source.length)\n            return NaN;\n        var result = start;\n        if (ignoreNaN) {\n            var found = false;\n            source.forEach(function (n) {\n                if (!isNaN(n)) {\n                    if (predicate(n, result))\n                        result = n;\n                    if (!found)\n                        found = true;\n                }\n            });\n            if (!found)\n                result = NaN;\n        }\n        else {\n            source.every(function (n) {\n                if (isNaN(n)) {\n                    result = NaN;\n                    return false;\n                }\n                if (predicate(n, result))\n                    result = n;\n                return true;\n            });\n        }\n        return result;\n    }\n    function min(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        return ifSet(source, +Infinity, ignoreNaN, function (n, result) { return n < result; });\n    }\n    exports.min = min;\n    function max(source, ignoreNaN) {\n        if (ignoreNaN === void 0) { ignoreNaN = false; }\n        return ifSet(source, -Infinity, ignoreNaN, function (n, result) { return n > result; });\n    }\n    exports.max = max;\n});\n","/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nexport function sum(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn 0;\r\n\r\n\tvar result = 0;\r\n\tif(ignoreNaN)\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n)) result += n;\r\n\t\t});\r\n\telse\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tresult += n;\r\n\t\t\treturn !isNaN(result);\r\n\t\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nexport function average(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tvar result = 0, count:number;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tcount = 0;\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult += n;\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcount = source.length;\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tresult += n;\r\n\t\t\treturn !isNaN(result);\r\n\t\t});\r\n\r\n\t}\r\n\r\n\treturn (!count || isNaN(result)) ? NaN : (result/count);\r\n}\r\n\r\nexport function product(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tvar result = 1;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tvar found = false;\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult *= n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif(!found)\r\n\t\t\tresult = NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tif(isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult = NaN;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tresult *= n;\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction ifSet(\r\n\tsource:number[],\r\n\tstart:number,\r\n\tignoreNaN:boolean,\r\n\tpredicate:(n:number, result:number) => boolean)\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tvar result = start;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tvar found = false;\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tif(predicate(n, result))\r\n\t\t\t\t\tresult = n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif(!found)\r\n\t\t\tresult = NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tif(isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult = NaN;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif(predicate(n, result))\r\n\t\t\t\tresult = n;\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function min(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, +Infinity, ignoreNaN, (n, result) => n<result);\r\n}\r\n\r\nexport function max(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, -Infinity, ignoreNaN, (n, result) => n>result);\r\n}\r\n"]}