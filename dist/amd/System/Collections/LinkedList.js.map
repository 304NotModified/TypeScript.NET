{"version":3,"sources":["System/Collections/LinkedList.js","System/Collections/LinkedList.ts"],"names":["define","require","exports","Values","TextUtility","ArrayUtility","Enumerator","EnumeratorBase_1","InvalidOperationException_1","ArgumentException_1","ArgumentNullException_1","ArgumentOutOfRangeException_1","ensureExternal","node","list","external","LinkedListNode","getInternal","n","_node","Node","value","prev","next","this","prototype","assertDetached","LinkedList","source","_","c","first","last","e","from","moveNext","current","_first","_last","_count","_addFirst","entry","_addLast","_addNodeBefore","inserting","_addNodeAfter","_findFirst","equals","areEqual","_findLast","forEach","action","useCopy","array","toArray","length","index","getEnumerator","yielder","yieldReturn","yieldBreak","Object","defineProperty","get","enumerable","configurable","add","clear","count","contains","found","copyTo","i","initialize","removeOnce","remove","removedCount","_getNodeAt","getValueAt","getNodeAt","find","findLast","addFirst","addLast","removeFirst","removeLast","removeNode","a","b","format","addBefore","addAfter","addNodeBefore","before","addNodeAfter","after","_list","set","v"],"mappings":"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","file":"System/Collections/LinkedList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n(function (factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define([\"require\", \"exports\", '../Compare', '../Text/Utility', '../Collections/Array/Utility', './Enumeration/Enumerator', './Enumeration/EnumeratorBase', '../Exceptions/InvalidOperationException', '../Exceptions/ArgumentException', '../Exceptions/ArgumentNullException', '../Exceptions/ArgumentOutOfRangeException'], factory);\r\n    }\r\n})(function (require, exports) {\r\n    'use strict';\r\n    var Values = require('../Compare');\r\n    var TextUtility = require('../Text/Utility');\r\n    var ArrayUtility = require('../Collections/Array/Utility');\r\n    var Enumerator = require('./Enumeration/Enumerator');\r\n    var EnumeratorBase_1 = require('./Enumeration/EnumeratorBase');\r\n    var InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\r\n    var ArgumentException_1 = require('../Exceptions/ArgumentException');\r\n    var ArgumentNullException_1 = require('../Exceptions/ArgumentNullException');\r\n    var ArgumentOutOfRangeException_1 = require('../Exceptions/ArgumentOutOfRangeException');\r\n    var Node = (function () {\r\n        function Node(value, prev, next) {\r\n            this.value = value;\r\n            this.prev = prev;\r\n            this.next = next;\r\n        }\r\n        Node.prototype.assertDetached = function () {\r\n            if (this.next || this.prev)\r\n                throw new InvalidOperationException_1.default(\"Adding a node that is already placed.\");\r\n        };\r\n        return Node;\r\n    }());\r\n    function ensureExternal(node, list) {\r\n        if (!node)\r\n            return null;\r\n        var external = node.external;\r\n        if (!external)\r\n            node.external = external = new LinkedListNode(list, node);\r\n        return external;\r\n    }\r\n    function getInternal(node, list) {\r\n        if (!node)\r\n            throw new ArgumentNullException_1.default(\"Cannot be null.\");\r\n        if (node.list != list)\r\n            throw new InvalidOperationException_1.default(\"Provided node does not belong to this list.\");\r\n        var n = node._node;\r\n        if (!n)\r\n            throw new InvalidOperationException_1.default(\"Provided node is not valid.\");\r\n        return n;\r\n    }\r\n    var LinkedList = (function () {\r\n        function LinkedList(source) {\r\n            var _ = this, c = 0, first = null, last = null;\r\n            var e = Enumerator.from(source);\r\n            if (e.moveNext()) {\r\n                first = last = new Node(e.current);\r\n                ++c;\r\n            }\r\n            while (e.moveNext()) {\r\n                last = last.next = new Node(e.current, last);\r\n                ++c;\r\n            }\r\n            _._first = first;\r\n            _._last = last;\r\n            _._count = c;\r\n        }\r\n        LinkedList.prototype._addFirst = function (entry) {\r\n            var _ = this, first = _._first;\r\n            var prev = new Node(entry, null, first);\r\n            if (first)\r\n                first.prev = prev;\r\n            else\r\n                _._last = prev;\r\n            _._first = prev;\r\n            _._count += 1;\r\n            return prev;\r\n        };\r\n        LinkedList.prototype._addLast = function (entry) {\r\n            var _ = this, last = _._last;\r\n            var next = new Node(entry, last);\r\n            if (last)\r\n                last.next = next;\r\n            else\r\n                _._first = next;\r\n            _._last = next;\r\n            _._count += 1;\r\n            return next;\r\n        };\r\n        LinkedList.prototype._addNodeBefore = function (n, inserting) {\r\n            inserting.assertDetached();\r\n            inserting.next = n;\r\n            inserting.prev = n.prev;\r\n            n.prev.next = inserting;\r\n            n.prev = inserting;\r\n            this._count += 1;\r\n        };\r\n        LinkedList.prototype._addNodeAfter = function (n, inserting) {\r\n            inserting.assertDetached();\r\n            inserting.prev = n;\r\n            inserting.next = n.next;\r\n            n.next.prev = inserting;\r\n            n.next = inserting;\r\n            this._count += 1;\r\n        };\r\n        LinkedList.prototype._findFirst = function (entry) {\r\n            var equals = Values.areEqual, next = this._first;\r\n            while (next) {\r\n                if (equals(entry, next.value))\r\n                    return next;\r\n                next = next.next;\r\n            }\r\n            return null;\r\n        };\r\n        LinkedList.prototype._findLast = function (entry) {\r\n            var equals = Values.areEqual, prev = this._last;\r\n            while (prev) {\r\n                if (equals(entry, prev.value))\r\n                    return prev;\r\n                prev = prev.prev;\r\n            }\r\n            return null;\r\n        };\r\n        LinkedList.prototype.forEach = function (action, useCopy) {\r\n            if (useCopy === void 0) { useCopy = false; }\r\n            if (useCopy) {\r\n                var array = this.toArray();\r\n                ArrayUtility.forEach(array, action);\r\n                array.length = 0;\r\n            }\r\n            else {\r\n                var next = this._first, index = 0;\r\n                while (next && action(next.value, index++) !== false) {\r\n                    next = next.next;\r\n                }\r\n            }\r\n        };\r\n        LinkedList.prototype.getEnumerator = function () {\r\n            var _ = this, current;\r\n            return new EnumeratorBase_1.default(function () {\r\n                current = new Node(null, null, _._first);\r\n            }, function (yielder) {\r\n                return (current = current.next)\r\n                    ? yielder.yieldReturn(current.value)\r\n                    : yielder.yieldBreak();\r\n            });\r\n        };\r\n        Object.defineProperty(LinkedList.prototype, \"count\", {\r\n            get: function () {\r\n                return this._count;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LinkedList.prototype, \"isReadOnly\", {\r\n            get: function () {\r\n                return false;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        LinkedList.prototype.add = function (entry) {\r\n            this._addLast(entry);\r\n        };\r\n        LinkedList.prototype.clear = function () {\r\n            var _ = this;\r\n            _._first = null;\r\n            _._last = null;\r\n            var count = _._count;\r\n            _._count = 0;\r\n            return count;\r\n        };\r\n        LinkedList.prototype.contains = function (entry) {\r\n            var found = false, equals = Values.areEqual;\r\n            this.forEach(function (e) { return !(found = equals(entry, e)); });\r\n            return found;\r\n        };\r\n        LinkedList.prototype.copyTo = function (array, index) {\r\n            if (index === void 0) { index = 0; }\r\n            this.forEach(function (entry, i) {\r\n                array[index + i] = entry;\r\n            });\r\n            return array;\r\n        };\r\n        LinkedList.prototype.toArray = function () {\r\n            var array = ArrayUtility.initialize(this._count);\r\n            return this.copyTo(array);\r\n        };\r\n        LinkedList.prototype.removeOnce = function (entry) {\r\n            var _ = this;\r\n            var node = _._findFirst(entry);\r\n            if (node) {\r\n                var prev = node.prev, next = node.next;\r\n                if (prev)\r\n                    prev.next = next;\r\n                else\r\n                    _._first = next;\r\n                if (next)\r\n                    next.prev = prev;\r\n                else\r\n                    _._last = prev;\r\n                _._count -= 1;\r\n            }\r\n            return node != null;\r\n        };\r\n        LinkedList.prototype.remove = function (entry) {\r\n            var _ = this, removedCount = 0;\r\n            while (_.removeOnce(entry)) {\r\n                ++removedCount;\r\n            }\r\n            return removedCount;\r\n        };\r\n        Object.defineProperty(LinkedList.prototype, \"first\", {\r\n            get: function () {\r\n                return ensureExternal(this._first, this);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LinkedList.prototype, \"last\", {\r\n            get: function () {\r\n                return ensureExternal(this._last, this);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        LinkedList.prototype._getNodeAt = function (index) {\r\n            if (index < 0)\r\n                throw new ArgumentOutOfRangeException_1.default('index', index, 'Is less than zero.');\r\n            if (index >= this._count)\r\n                throw new ArgumentOutOfRangeException_1.default('index', index, 'Is greater than count.');\r\n            var next = this._first, i = 0;\r\n            while (next && index < i++) {\r\n                next = next.next;\r\n            }\r\n            return next;\r\n        };\r\n        LinkedList.prototype.getValueAt = function (index) {\r\n            return this._getNodeAt(index).value;\r\n        };\r\n        LinkedList.prototype.getNodeAt = function (index) {\r\n            return ensureExternal(this._getNodeAt(index), this);\r\n        };\r\n        LinkedList.prototype.find = function (entry) {\r\n            return ensureExternal(this._findFirst(entry), this);\r\n        };\r\n        LinkedList.prototype.findLast = function (entry) {\r\n            return ensureExternal(this._findLast(entry), this);\r\n        };\r\n        LinkedList.prototype.addFirst = function (entry) {\r\n            this._addFirst(entry);\r\n        };\r\n        LinkedList.prototype.addLast = function (entry) {\r\n            this._addLast(entry);\r\n        };\r\n        LinkedList.prototype.removeFirst = function () {\r\n            var _ = this, first = _._first;\r\n            if (first) {\r\n                var next = first.next;\r\n                _._first = next;\r\n                if (next)\r\n                    next.prev = null;\r\n                _._count -= 1;\r\n            }\r\n        };\r\n        LinkedList.prototype.removeLast = function () {\r\n            var _ = this, last = _._last;\r\n            if (last) {\r\n                var prev = last.prev;\r\n                _._last = prev;\r\n                if (prev)\r\n                    prev.next = null;\r\n                _._count -= 1;\r\n            }\r\n        };\r\n        LinkedList.prototype.removeNode = function (node) {\r\n            var _ = this;\r\n            var n = getInternal(node, _);\r\n            var prev = n.prev, next = n.next, a = false, b = false;\r\n            if (prev)\r\n                prev.next = next;\r\n            else if (_._first == n)\r\n                _._first = next;\r\n            else\r\n                a = true;\r\n            if (next)\r\n                next.prev = prev;\r\n            else if (_._last == n)\r\n                _._last = prev;\r\n            else\r\n                b = true;\r\n            if (a !== b) {\r\n                throw new ArgumentException_1.default('node', TextUtility.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\r\n            }\r\n            return !a && !b;\r\n        };\r\n        LinkedList.prototype.addBefore = function (node, entry) {\r\n            this._addNodeBefore(getInternal(node, this), new Node(entry));\r\n        };\r\n        LinkedList.prototype.addAfter = function (node, entry) {\r\n            this._addNodeAfter(getInternal(node, this), new Node(entry));\r\n        };\r\n        LinkedList.prototype.addNodeBefore = function (node, before) {\r\n            this._addNodeBefore(getInternal(node, this), getInternal(before, this));\r\n        };\r\n        LinkedList.prototype.addNodeAfter = function (node, after) {\r\n            this._addNodeAfter(getInternal(node, this), getInternal(after, this));\r\n        };\r\n        return LinkedList;\r\n    }());\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = LinkedList;\r\n    var LinkedListNode = (function () {\r\n        function LinkedListNode(_list, _node) {\r\n            this._list = _list;\r\n            this._node = _node;\r\n        }\r\n        Object.defineProperty(LinkedListNode.prototype, \"list\", {\r\n            get: function () {\r\n                return this._list;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LinkedListNode.prototype, \"previous\", {\r\n            get: function () {\r\n                return ensureExternal(this._node.prev, this._list);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LinkedListNode.prototype, \"next\", {\r\n            get: function () {\r\n                return ensureExternal(this._node.next, this._list);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(LinkedListNode.prototype, \"value\", {\r\n            get: function () {\r\n                return this._node.value;\r\n            },\r\n            set: function (v) {\r\n                this._node.value = v;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        LinkedListNode.prototype.addBefore = function (entry) {\r\n            this._list.addBefore(this, entry);\r\n        };\r\n        LinkedListNode.prototype.addAfter = function (entry) {\r\n            this._list.addAfter(this, entry);\r\n        };\r\n        LinkedListNode.prototype.addNodeBefore = function (before) {\r\n            this._list.addNodeBefore(this, before);\r\n        };\r\n        LinkedListNode.prototype.addNodeAfter = function (after) {\r\n            this._list.addNodeAfter(this, after);\r\n        };\r\n        LinkedListNode.prototype.remove = function () {\r\n            this._list.removeNode(this);\r\n        };\r\n        return LinkedListNode;\r\n    }());\r\n});\r\n//# sourceMappingURL=LinkedList.js.map","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n///<reference path=\"ILinkedList.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from '../Compare';\r\nimport * as TextUtility from '../Text/Utility';\r\nimport * as ArrayUtility from '../Collections/Array/Utility';\r\nimport * as Enumerator from './Enumeration/Enumerator';\r\nimport EnumeratorBase from './Enumeration/EnumeratorBase';\r\n\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\n\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n\r\nclass Node<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value?:T,\r\n\t\tpublic prev?:Node<T>,\r\n\t\tpublic next?:Node<T>)\r\n\t{\r\n\t}\r\n\r\n\texternal:ILinkedListNode<T>;\r\n\r\n\tassertDetached():void\r\n\t{\r\n\t\tif(this.next || this.prev)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(node:Node<T>, list:LinkedList<T>):ILinkedListNode<T>\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\r\n\tvar external:ILinkedListNode<T> = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):Node<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\r\n\t\t\t\"Cannot be null.\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tvar n:Node<T> = (<any>node)._node;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nexport default\r\nclass LinkedList<T>\r\nimplements ILinkedList<T>\r\n{\r\n\tprivate _first:Node<T>;\r\n\tprivate _last:Node<T>;\r\n\tprivate _count:number;\r\n\r\n\tconstructor(source?:IEnumerable<T>);\r\n\tconstructor(source?:IArray<T>);\r\n\tconstructor(source:any)\r\n\t{\r\n\t\tvar _ = this, c = 0, first:Node<T> = null, last:Node<T> = null;\r\n\t\tvar e = Enumerator.from<T>(source);\r\n\r\n\t\tif(e.moveNext())\r\n\t\t{\r\n\t\t\tfirst = last = new Node<T>(e.current);\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tlast = last.next = new Node<T>(e.current, last);\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\t_._first = first;\r\n\t\t_._last = last;\r\n\t\t_._count = c;\r\n\t}\r\n\r\n\t// #region Internals.\r\n\r\n\tprivate _addFirst(entry:T):Node<T>\r\n\t{\r\n\t\tvar _ = this, first = _._first;\r\n\t\tvar prev = new Node(entry, null, first);\r\n\t\tif(first)\r\n\t\t\tfirst.prev = prev;\r\n\t\telse\r\n\t\t\t_._last = prev;\r\n\r\n\t\t_._first = prev;\r\n\r\n\t\t_._count += 1;\r\n\r\n\t\treturn prev;\r\n\t}\r\n\r\n\tprivate _addLast(entry:T):Node<T>\r\n\t{\r\n\t\tvar _ = this, last = _._last;\r\n\t\tvar next = new Node(entry, last);\r\n\t\tif(last)\r\n\t\t\tlast.next = next;\r\n\t\telse\r\n\t\t\t_._first = next;\r\n\r\n\t\t_._last = next;\r\n\t\t_._count += 1;\r\n\r\n\t\treturn next;\r\n\t}\r\n\r\n\tprivate _addNodeBefore(n:Node<T>, inserting:Node<T>):void\r\n\t{\r\n\t\tinserting.assertDetached();\r\n\r\n\t\tinserting.next = n;\r\n\t\tinserting.prev = n.prev;\r\n\r\n\t\tn.prev.next = inserting;\r\n\t\tn.prev = inserting;\r\n\r\n\t\tthis._count += 1;\r\n\t}\r\n\r\n\r\n\tprivate _addNodeAfter(n:Node<T>, inserting:Node<T>):void\r\n\t{\r\n\t\tinserting.assertDetached();\r\n\r\n\t\tinserting.prev = n;\r\n\t\tinserting.next = n.next;\r\n\r\n\t\tn.next.prev = inserting;\r\n\t\tn.next = inserting;\r\n\r\n\t\tthis._count += 1;\r\n\t}\r\n\r\n\tprivate _findFirst(entry:T):Node<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    next   = this._first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):Node<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    prev   = this._last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.prev;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\t// #region IEnumerateEach<T>\r\n\tforEach(\r\n\t\taction:Predicate<T> | Action<T>,\r\n\t\tuseCopy:boolean = false):void\r\n\t{\r\n\t\tif(useCopy)\r\n\t\t{\r\n\t\t\tvar array = this.toArray();\r\n\t\t\tArrayUtility.forEach(array, action);\r\n\t\t\tarray.length = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar next = this._first, index:number = 0;\r\n\t\t\twhile(next && <any>action(next.value, index++)!==false)\r\n\t\t\t{\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this, current:Node<T>;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tcurrent = new Node(null, null, _._first);\r\n\t\t\t}, // Initialize anchor...\r\n\t\t\t(yielder)=>\r\n\t\t\t\t(current = current.next)\r\n\t\t\t\t\t? yielder.yieldReturn(current.value)\r\n\t\t\t\t\t: yielder.yieldBreak()\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region ICollection<T>\r\n\tget count():number\r\n\t{\r\n\t\treturn this._count;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(entry:T):void\r\n\t{\r\n\t\tthis._addLast(entry);\r\n\t}\r\n\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._first = null;\r\n\t\t_._last = null;\r\n\t\tvar count = _._count;\r\n\t\t_._count = 0;\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\tcontains(entry:T):boolean\r\n\t{\r\n\t\tvar found:boolean = false, equals = Values.areEqual;\r\n\t\tthis.forEach(e => !(found = equals(entry, e)));\r\n\t\treturn found;\r\n\t}\r\n\r\n\tcopyTo(array:T[], index:number = 0):T[]\r\n\t{\r\n\t\tthis.forEach(\r\n\t\t\t(entry, i) =>\r\n\t\t\t{\r\n\t\t\t\tarray[index + i] = entry;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar array = ArrayUtility.initialize<T>(this._count);\r\n\t\treturn this.copyTo(array);\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar node:Node<T> = _._findFirst(entry);\r\n\t\tif(node)\r\n\t\t{\r\n\t\t\tvar prev = node.prev, next = node.next;\r\n\t\t\tif(prev) prev.next = next;\r\n\t\t\telse _._first = next;\r\n\t\t\tif(next) next.prev = prev;\r\n\t\t\telse _._last = prev;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\r\n\t\treturn node!=null;\r\n\r\n\t}\r\n\r\n\tremove(entry:T):number\r\n\t{\r\n\t\tvar _ = this, removedCount:number = 0;\r\n\t\twhile(_.removeOnce(entry))\r\n\t\t{\r\n\t\t\t++removedCount;\r\n\t\t}\r\n\t\treturn removedCount;\r\n\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\tget first():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._first, this);\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._last, this);\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\tprivate _getNodeAt(index:number):Node<T>\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\r\n\t\t\t\t'index', index, 'Is less than zero.');\r\n\r\n\t\tif(index>=this._count)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\r\n\t\t\t\t'index', index, 'Is greater than count.');\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && index<i++)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tgetValueAt(index:number):T\r\n\t{\r\n\t\treturn this._getNodeAt(index).value;\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):void\r\n\t{\r\n\t\tthis._addFirst(entry);\r\n\t}\r\n\r\n\taddLast(entry:T):void\r\n\t{\r\n\t\tthis._addLast(entry);\r\n\t}\r\n\r\n\tremoveFirst():void\r\n\t{\r\n\t\tvar _ = this, first = _._first;\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tvar next = first.next;\r\n\t\t\t_._first = next;\r\n\t\t\tif(next) // Might have been the last.\r\n\t\t\t\tnext.prev = null;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveLast():void\r\n\t{\r\n\t\tvar _ = this, last = _._last;\r\n\t\tif(last)\r\n\t\t{\r\n\t\t\tvar prev = last.prev;\r\n\t\t\t_._last = prev;\r\n\t\t\tif(prev) // Might have been the first.\r\n\t\t\t\tprev.next = null;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar n:Node<T> = getInternal(node, _);\r\n\t\tvar prev = n.prev, next = n.next, a:boolean = false, b:boolean = false;\r\n\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==n) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.prev = prev;\r\n\t\telse if(_._last==n) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn !a && !b;\r\n\r\n\t}\r\n\r\n\taddBefore(node:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._addNodeBefore(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tnew Node(entry)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\taddAfter(node:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._addNodeAfter(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tnew Node(entry)\r\n\t\t);\r\n\t}\r\n\r\n\taddNodeBefore(node:ILinkedListNode<T>, before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._addNodeBefore(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tgetInternal(before, this)\r\n\t\t);\r\n\t}\r\n\r\n\taddNodeAfter(node:ILinkedListNode<T>, after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._addNodeAfter(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tgetInternal(after, this)\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _node:Node<T>)\r\n\t{\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._node.prev, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._node.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this._node.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis._node.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):void\r\n\t{\r\n\t\tthis._list.addBefore(this, entry);\r\n\t}\r\n\r\n\taddAfter(entry:T):void\r\n\t{\r\n\t\tthis._list.addAfter(this, entry);\r\n\t}\r\n\r\n\taddNodeBefore(before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeBefore(this, before);\r\n\t}\r\n\r\n\taddNodeAfter(after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeAfter(this, after);\r\n\t}\r\n\r\n\tremove():void\r\n\t{\r\n\t\tthis._list.removeNode(this);\r\n\t}\r\n\r\n}\r\n\r\n"]}