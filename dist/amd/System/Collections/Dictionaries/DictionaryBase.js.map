{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.js","System/Collections/Dictionaries/DictionaryBase.ts"],"names":["define","require","exports","Compare_1","EnumeratorBase_1","ArgumentNullException_1","InvalidOperationException_1","KeyValueExtract_1","Enumerator_1","VOID0","DictionaryBase","this","_updateRecursion","Object","defineProperty","prototype","get","enumerable","configurable","_onValueUpdate","key","value","old","areEqual","_","onValueChanged","_onUpdated","onUpdated","handleUpdate","closure","result","getCount","add","item","_this","addByKeyValue","clear","keys","count","length","forEach","removeByKey","console","warn","contains","v","getValue","copyTo","array","index","e","getEnumerator","moveNext","current","toArray","remove","getKeys","getValues","containsKey","ex","data","setValue","containsValue","equal","dispose","undefined","removeByValue","importPairs","pairs","changed","pair","len","i","yielder","yieldReturn","yieldBreak"],"mappings":"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","file":"System/Collections/Dictionaries/DictionaryBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n(function (factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define([\"require\", \"exports\", '../../Compare', '../Enumeration/EnumeratorBase', '../../Exceptions/ArgumentNullException', '../../Exceptions/InvalidOperationException', '../../KeyValueExtract', '../Enumeration/Enumerator'], factory);\r\n    }\r\n})(function (require, exports) {\r\n    'use strict';\r\n    var Compare_1 = require('../../Compare');\r\n    var EnumeratorBase_1 = require('../Enumeration/EnumeratorBase');\r\n    var ArgumentNullException_1 = require('../../Exceptions/ArgumentNullException');\r\n    var InvalidOperationException_1 = require('../../Exceptions/InvalidOperationException');\r\n    var KeyValueExtract_1 = require('../../KeyValueExtract');\r\n    var Enumerator_1 = require('../Enumeration/Enumerator');\r\n    var VOID0 = void (0);\r\n    var DictionaryBase = (function () {\r\n        function DictionaryBase() {\r\n            this._updateRecursion = 0;\r\n        }\r\n        Object.defineProperty(DictionaryBase.prototype, \"isUpdating\", {\r\n            get: function () { return this._updateRecursion != 0; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DictionaryBase.prototype._onValueUpdate = function (key, value, old) {\r\n            if (!Compare_1.areEqual(value, old, true)) {\r\n                var _ = this;\r\n                if (_.onValueChanged)\r\n                    _.onValueChanged(key, value, old);\r\n                if (_._updateRecursion == 0)\r\n                    _._onUpdated();\r\n            }\r\n        };\r\n        DictionaryBase.prototype._onUpdated = function () {\r\n            var _ = this;\r\n            if (_.onUpdated)\r\n                _.onUpdated();\r\n        };\r\n        DictionaryBase.prototype.handleUpdate = function (closure) {\r\n            var _ = this, result;\r\n            if (closure) {\r\n                _._updateRecursion++;\r\n                try {\r\n                    result = closure();\r\n                }\r\n                finally {\r\n                    _._updateRecursion--;\r\n                }\r\n            }\r\n            else\r\n                result = _._updateRecursion == 0;\r\n            if (result && _._updateRecursion == 0)\r\n                _._onUpdated();\r\n            return result;\r\n        };\r\n        Object.defineProperty(DictionaryBase.prototype, \"isReadOnly\", {\r\n            get: function () { return false; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DictionaryBase.prototype, \"count\", {\r\n            get: function () { return this.getCount(); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DictionaryBase.prototype.add = function (item) {\r\n            var _this = this;\r\n            if (!item)\r\n                throw new ArgumentNullException_1.default('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\r\n            KeyValueExtract_1.default(item, function (key, value) { return _this.addByKeyValue(key, value); });\r\n        };\r\n        DictionaryBase.prototype.clear = function () {\r\n            var _ = this, keys = _.keys, count = keys.length;\r\n            if (count)\r\n                _.handleUpdate(function () {\r\n                    keys.forEach(function (key) { _.removeByKey(key); });\r\n                    return true;\r\n                });\r\n            if (_.count != 0)\r\n                console.warn(\"Dictionary clear() results in mismatched count.\");\r\n            return count;\r\n        };\r\n        DictionaryBase.prototype.contains = function (item) {\r\n            var _this = this;\r\n            if (!item)\r\n                return false;\r\n            return KeyValueExtract_1.default(item, function (key, value) {\r\n                var v = _this.getValue(key);\r\n                return Compare_1.areEqual(value, v);\r\n            });\r\n        };\r\n        DictionaryBase.prototype.copyTo = function (array, index) {\r\n            if (index === void 0) { index = 0; }\r\n            if (!array)\r\n                throw new ArgumentNullException_1.default('array');\r\n            var e = this.getEnumerator();\r\n            while (e.moveNext()) {\r\n                array[index++] = e.current;\r\n            }\r\n            return array;\r\n        };\r\n        DictionaryBase.prototype.toArray = function () {\r\n            return this.copyTo([], 0);\r\n        };\r\n        DictionaryBase.prototype.remove = function (item) {\r\n            var _this = this;\r\n            if (!item)\r\n                return 0;\r\n            return KeyValueExtract_1.default(item, function (key, value) {\r\n                var v = _this.getValue(key);\r\n                return (Compare_1.areEqual(value, v) && _this.removeByKey(key))\r\n                    ? 1 : 0;\r\n            });\r\n        };\r\n        Object.defineProperty(DictionaryBase.prototype, \"keys\", {\r\n            get: function () { return this.getKeys(); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DictionaryBase.prototype, \"values\", {\r\n            get: function () { return this.getValues(); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DictionaryBase.prototype.addByKeyValue = function (key, value) {\r\n            var _ = this;\r\n            if (_.containsKey(key)) {\r\n                var ex = new InvalidOperationException_1.default(\"Adding a key/value when the key already exists.\");\r\n                ex.data['key'] = key;\r\n                ex.data['value'] = value;\r\n                throw ex;\r\n            }\r\n            _.setValue(key, value);\r\n        };\r\n        DictionaryBase.prototype.containsKey = function (key) {\r\n            var value = this.getValue(key);\r\n            return value !== VOID0;\r\n        };\r\n        DictionaryBase.prototype.containsValue = function (value) {\r\n            var e = this.getEnumerator(), equal = Compare_1.areEqual;\r\n            while (e.moveNext()) {\r\n                if (equal(e.current, value, true)) {\r\n                    e.dispose();\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        DictionaryBase.prototype.removeByKey = function (key) {\r\n            return this.setValue(key, undefined);\r\n        };\r\n        DictionaryBase.prototype.removeByValue = function (value) {\r\n            var _ = this, count = 0, equal = Compare_1.areEqual;\r\n            _.keys.forEach(function (key) {\r\n                if (equal(_.getValue(key), value, true)) {\r\n                    _.removeByKey(key);\r\n                    ++count;\r\n                }\r\n            });\r\n            return count;\r\n        };\r\n        DictionaryBase.prototype.importPairs = function (pairs) {\r\n            var _ = this;\r\n            if (!pairs)\r\n                return false;\r\n            return _.handleUpdate(function () {\r\n                var changed = false;\r\n                Enumerator_1.forEach(pairs, function (pair) { return KeyValueExtract_1.default(pair, function (key, value) {\r\n                    _.setValue(key, value);\r\n                    changed = true;\r\n                }); });\r\n                return changed;\r\n            });\r\n        };\r\n        DictionaryBase.prototype.getEnumerator = function () {\r\n            var _ = this;\r\n            var keys, len, i = 0;\r\n            return new EnumeratorBase_1.default(function () {\r\n                keys = _.keys;\r\n                len = keys.length;\r\n            }, function (yielder) {\r\n                while (i < len) {\r\n                    var key = keys[i++], value = _.getValue(key);\r\n                    if (value !== VOID0)\r\n                        return yielder.yieldReturn({ key: key, value: value });\r\n                }\r\n                return yielder.yieldBreak();\r\n            });\r\n        };\r\n        return DictionaryBase;\r\n    }());\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = DictionaryBase;\r\n});\r\n//# sourceMappingURL=DictionaryBase.js.map","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDictionary.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport {areEqual} from '../../Compare';\r\nimport EnumeratorBase from '../Enumeration/EnumeratorBase';\r\nimport ArgumentException from '../../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../../Exceptions/ArgumentNullException';\r\nimport InvalidOperationException from '../../Exceptions/InvalidOperationException';\r\nimport extractKeyValue from '../../KeyValueExtract';\r\nimport {forEach} from '../Enumeration/Enumerator';\r\n\r\nconst VOID0:any = void(0);\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nabstract class DictionaryBase<TKey, TValue>\r\nimplements IDictionary<TKey, TValue>\r\n{\r\n\t// This allows for batch updates in order to improve the efficiency of responsive systems.\r\n\tprivate _updateRecursion:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._updateRecursion = 0;\r\n\t}\r\n\r\n\tget isUpdating():boolean { return this._updateRecursion!=0; }\r\n\r\n\t// Could implement an event dispatcher pattern here easily...\r\n\tonValueChanged:(key:TKey, value:TValue, old:TValue) => void;\r\n\r\n\tprotected _onValueUpdate(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t\tif(!areEqual(value, old, true))\r\n\t\t{\r\n\r\n\t\t\tvar _ = this;\r\n\t\t\tif(_.onValueChanged)\r\n\t\t\t\t_.onValueChanged(key, value, old);\r\n\r\n\t\t\t// If the update recursion is zero, then we are finished with updates.\r\n\t\t\tif(_._updateRecursion==0)\r\n\t\t\t\t_._onUpdated();\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// Listening to every value update can get noisy.  Here we allow for batch update signaling.\r\n\t// The consumer of this class can also wire up their own event system.\r\n\tonUpdated:() => void;\r\n\r\n\tprivate _onUpdated():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.onUpdated)\r\n\t\t\t_.onUpdated();\r\n\t}\r\n\r\n\t// Takes a closure that if returning true will propagate an update signal.\r\n\thandleUpdate(closure?:() => boolean):boolean\r\n\t{\r\n\t\tvar _ = this, result:boolean;\r\n\t\tif(closure)\r\n\t\t{\r\n\t\t\t_._updateRecursion++;\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tresult = closure();\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._updateRecursion--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = _._updateRecursion==0;\r\n\r\n\t\tif(result && _._updateRecursion==0)\r\n\t\t\t_._onUpdated();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// ICollection<T>\r\n\t/////////////////////////////////////////\r\n\tget isReadOnly():boolean { return false; }\r\n\r\n\tprotected abstract getCount():number;\r\n\r\n\tget count():number { return this.getCount(); }\r\n\r\n\tadd(item:KeyValuePair<TKey, TValue>):void\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\textractKeyValue(item,\r\n\t\t\t(key, value)=>this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, keys = _.keys, count = keys.length;\r\n\r\n\t\tif(count)\r\n\t\t\t_.handleUpdate(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys.forEach(key=> { _.removeByKey(key); });\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\tif(_.count!=0) // After they've all been removed, then should be zero.\r\n\t\t\tconsole.warn(\"Dictionary clear() results in mismatched count.\");\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tcopyTo(array:IKeyValuePair<TKey, TValue>[], index:number = 0):IKeyValuePair<TKey, TValue>[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t// This is a generic implementation that will work for all derived classes.\r\n\t\t// It can be overridden and optimized.\r\n\t\tvar e = this.getEnumerator();\r\n\t\twhile(e.moveNext()) // Disposes when finished.\r\n\t\t{\r\n\t\t\tarray[index++] = e.current;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\ttoArray():IKeyValuePair<TKey,TValue>[]\r\n\t{\r\n\t\treturn this.copyTo([], 0);\r\n\t}\r\n\r\n\tremove(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\r\n\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\t_.setValue(key, value);\r\n\t}\r\n\r\n\tabstract getValue(key:TKey):TValue;\r\n\r\n\tabstract setValue(key:TKey, value:TValue):boolean;\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\tvar value = this.getValue(key);\r\n\t\treturn value!==VOID0;\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, undefined);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\t_.keys.forEach(key=>\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportPairs(pairs:KeyValuePair<TKey, TValue>[]|IEnumerable<KeyValuePair<TKey, TValue>>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(!pairs) return false;\r\n\t\treturn _.handleUpdate(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet changed:boolean = false;\r\n\t\t\t\tforEach(pairs,\r\n\t\t\t\t\tpair=>extractKeyValue(pair, (key, value)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_.setValue(key, value);\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t\treturn changed;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tkeys = _.keys;\r\n\t\t\t\tlen = keys.length\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}