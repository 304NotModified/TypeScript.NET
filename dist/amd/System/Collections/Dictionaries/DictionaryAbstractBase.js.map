{"version":3,"sources":["System/Collections/Dictionaries/DictionaryAbstractBase.js","System/Collections/Dictionaries/DictionaryAbstractBase.ts"],"names":["define","require","exports","Compare_1","EnumeratorBase_1","NotImplementedException_1","ArgumentException_1","ArgumentNullException_1","InvalidOperationException_1","notImplemented","name","log","DictionaryAbstractBase","DictionaryAbstractBase.constructor","get","DictionaryAbstractBase.isUpdating","enumerable","configurable","DictionaryAbstractBase._onValueUpdate","DictionaryAbstractBase._onUpdated","DictionaryAbstractBase.handleUpdate","DictionaryAbstractBase.isReadOnly","DictionaryAbstractBase.count","DictionaryAbstractBase.add","DictionaryAbstractBase.clear","DictionaryAbstractBase.contains","DictionaryAbstractBase.copyTo","DictionaryAbstractBase.toArray","DictionaryAbstractBase.remove","DictionaryAbstractBase.keys","DictionaryAbstractBase.values","DictionaryAbstractBase.addByKeyValue","DictionaryAbstractBase.getValue","DictionaryAbstractBase.setValue","DictionaryAbstractBase.containsKey","DictionaryAbstractBase.containsValue","DictionaryAbstractBase.removeByKey","DictionaryAbstractBase.removeByValue","DictionaryAbstractBase.importPairs","DictionaryAbstractBase.getEnumerator","Object","defineProperty","value"],"mappings":"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","file":"System/Collections/Dictionaries/DictionaryAbstractBase.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\ndefine([\"require\", \"exports\", '../../Compare', '../Enumeration/EnumeratorBase', '../../Exceptions/NotImplementedException', '../../Exceptions/ArgumentException', '../../Exceptions/ArgumentNullException', '../../Exceptions/InvalidOperationException'], function (require, exports, Compare_1, EnumeratorBase_1, NotImplementedException_1, ArgumentException_1, ArgumentNullException_1, InvalidOperationException_1) {\r\n    var DictionaryAbstractBase = (function () {\r\n        function DictionaryAbstractBase() {\r\n            this._updateRecursion = 0;\r\n        }\r\n        Object.defineProperty(DictionaryAbstractBase.prototype, \"isUpdating\", {\r\n            get: function () { return this._updateRecursion != 0; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DictionaryAbstractBase.prototype._onValueUpdate = function (key, value, old) {\r\n            if (!Compare_1.areEqual(value, old, true)) {\r\n                var _ = this;\r\n                if (_.onValueChanged)\r\n                    _.onValueChanged(key, value, old);\r\n                if (_._updateRecursion == 0)\r\n                    _._onUpdated();\r\n            }\r\n        };\r\n        DictionaryAbstractBase.prototype._onUpdated = function () {\r\n            var _ = this;\r\n            if (_.onUpdated)\r\n                _.onUpdated();\r\n        };\r\n        DictionaryAbstractBase.prototype.handleUpdate = function (closure) {\r\n            var _ = this, result;\r\n            if (closure) {\r\n                _._updateRecursion++;\r\n                try {\r\n                    result = closure();\r\n                }\r\n                finally {\r\n                    _._updateRecursion--;\r\n                }\r\n            }\r\n            else\r\n                result = _._updateRecursion == 0;\r\n            if (result && _._updateRecursion == 0)\r\n                _._onUpdated();\r\n            return result;\r\n        };\r\n        Object.defineProperty(DictionaryAbstractBase.prototype, \"isReadOnly\", {\r\n            get: function () { return false; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DictionaryAbstractBase.prototype, \"count\", {\r\n            get: function () {\r\n                throw notImplemented(\"count\");\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DictionaryAbstractBase.prototype.add = function (item) {\r\n            if (!item)\r\n                throw new ArgumentException_1.default('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\r\n            this.addByKeyValue(item.key, item.value);\r\n        };\r\n        DictionaryAbstractBase.prototype.clear = function () {\r\n            var _ = this, keys = _.keys, count = keys.length;\r\n            if (count)\r\n                _.handleUpdate(function () {\r\n                    keys.forEach(function (key) { _.removeByKey(key); });\r\n                    return true;\r\n                });\r\n            if (_.count != 0)\r\n                console.warn(\"Dictionary clear() results in mismatched count.\");\r\n            return count;\r\n        };\r\n        DictionaryAbstractBase.prototype.contains = function (item) {\r\n            if (!item)\r\n                return false;\r\n            var value = this.getValue(item.key);\r\n            return Compare_1.areEqual(value, item.value);\r\n        };\r\n        DictionaryAbstractBase.prototype.copyTo = function (array, index) {\r\n            if (index === void 0) { index = 0; }\r\n            if (!array)\r\n                throw new ArgumentNullException_1.default('array');\r\n            var e = this.getEnumerator();\r\n            while (e.moveNext()) {\r\n                array[index++] = e.current;\r\n            }\r\n            return array;\r\n        };\r\n        DictionaryAbstractBase.prototype.toArray = function () {\r\n            return this.copyTo([], 0);\r\n        };\r\n        DictionaryAbstractBase.prototype.remove = function (item) {\r\n            if (!item)\r\n                return 0;\r\n            var key = item.key, value = this.getValue(key);\r\n            return (Compare_1.areEqual(value, item.value) && this.removeByKey(key))\r\n                ? 1 : 0;\r\n        };\r\n        Object.defineProperty(DictionaryAbstractBase.prototype, \"keys\", {\r\n            get: function () { throw notImplemented(\"keys\"); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(DictionaryAbstractBase.prototype, \"values\", {\r\n            get: function () { throw notImplemented(\"values\"); },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        DictionaryAbstractBase.prototype.addByKeyValue = function (key, value) {\r\n            var _ = this;\r\n            if (_.containsKey(key)) {\r\n                var ex = new InvalidOperationException_1.default(\"Adding a key/value when the key already exists.\");\r\n                ex.data['key'] = key;\r\n                ex.data['value'] = value;\r\n                throw ex;\r\n            }\r\n            _.setValue(key, value);\r\n        };\r\n        DictionaryAbstractBase.prototype.getValue = function (key) {\r\n            throw notImplemented(\"getValue(key: TKey): TValue\", \"When calling for key: \" + key);\r\n        };\r\n        DictionaryAbstractBase.prototype.setValue = function (key, value) {\r\n            throw notImplemented(\"setValue(key: TKey, value: TValue): boolean\", \"When setting \" + key + \":\" + value + \".\");\r\n        };\r\n        DictionaryAbstractBase.prototype.containsKey = function (key) {\r\n            var value = this.getValue(key);\r\n            return value !== undefined;\r\n        };\r\n        DictionaryAbstractBase.prototype.containsValue = function (value) {\r\n            var e = this.getEnumerator(), equal = Compare_1.areEqual;\r\n            while (e.moveNext()) {\r\n                if (equal(e.current, value, true)) {\r\n                    e.dispose();\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        DictionaryAbstractBase.prototype.removeByKey = function (key) {\r\n            return this.setValue(key, undefined);\r\n        };\r\n        DictionaryAbstractBase.prototype.removeByValue = function (value) {\r\n            var _ = this, count = 0, equal = Compare_1.areEqual;\r\n            _.keys.forEach(function (key) {\r\n                if (equal(_.getValue(key), value, true)) {\r\n                    _.removeByKey(key);\r\n                    ++count;\r\n                }\r\n            });\r\n            return count;\r\n        };\r\n        DictionaryAbstractBase.prototype.importPairs = function (pairs) {\r\n            var _ = this;\r\n            return _.handleUpdate(function () {\r\n                var changed = false;\r\n                pairs.forEach(function (pair) {\r\n                    _.setValue(pair.key, pair.value);\r\n                    changed = true;\r\n                });\r\n                return changed;\r\n            });\r\n        };\r\n        DictionaryAbstractBase.prototype.getEnumerator = function () {\r\n            var _ = this;\r\n            var keys, len, i = 0;\r\n            return new EnumeratorBase_1.default(function () {\r\n                keys = _.keys;\r\n                len = keys.length;\r\n            }, function (yielder) {\r\n                while (i < len) {\r\n                    var key = keys[i++], value = _.getValue(key);\r\n                    if (value !== undefined)\r\n                        return yielder.yieldReturn({ key: key, value: value });\r\n                }\r\n                return yielder.yieldBreak();\r\n            });\r\n        };\r\n        return DictionaryAbstractBase;\r\n    })();\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = DictionaryAbstractBase;\r\n    function notImplemented(name, log) {\r\n        if (log === void 0) { log = \"\"; }\r\n        console.log(\"DictionaryAbstractBase sub-class has not overridden \" + name + \". \" + log);\r\n        return new NotImplementedException_1.default(\"DictionaryAbstractBase.\" + name + \": Not implemented.\");\r\n    }\r\n});\r\n//# sourceMappingURL=DictionaryAbstractBase.js.map","/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDictionary.d.ts\"/>\r\nimport {areEqual} from '../../Compare';\r\nimport EnumeratorBase from '../Enumeration/EnumeratorBase';\r\nimport NotImplementedException from '../../Exceptions/NotImplementedException';\r\nimport ArgumentException from '../../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../../Exceptions/ArgumentNullException';\r\nimport InvalidOperationException from '../../Exceptions/InvalidOperationException';\r\n\r\n\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nexport default\r\nclass DictionaryAbstractBase<TKey, TValue> implements IDictionary<TKey, TValue>\r\n{\r\n\t// This allows for batch updates in order to improve the efficiency of responsive systems.\r\n\tprivate _updateRecursion:number = 0;\r\n\r\n\tget isUpdating():boolean { return this._updateRecursion!=0; }\r\n\r\n\t// Could implement an event dispatcher pattern here easily...\r\n\tpublic onValueChanged:(key:TKey, value:TValue, old:TValue) => void;\r\n\r\n\t// Pseudo-protected.\r\n\tpublic _onValueUpdate(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t\tif(!areEqual(value, old, true))\r\n\t\t{\r\n\r\n\t\t\tvar _ = this;\r\n\t\t\tif(_.onValueChanged)\r\n\t\t\t\t_.onValueChanged(key, value, old);\r\n\r\n\t\t\t// If the update recursion is zero, then we are finished with updates.\r\n\t\t\tif(_._updateRecursion==0)\r\n\t\t\t\t_._onUpdated();\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// Listening to every value update can get noisy.  Here we allow for batch update signaling.\r\n\t// The consumer of this class can also wire up their own event system.\r\n\tpublic onUpdated:() => void;\r\n\r\n\tprivate _onUpdated():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.onUpdated)\r\n\t\t\t_.onUpdated();\r\n\t}\r\n\r\n\t// Takes a closure that if returning true will propagate an update signal.\r\n\tpublic handleUpdate(closure?:() => boolean):boolean\r\n\t{\r\n\t\tvar _ = this, result:boolean;\r\n\t\tif(closure)\r\n\t\t{\r\n\t\t\t_._updateRecursion++;\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tresult = closure();\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._updateRecursion--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = _._updateRecursion==0;\r\n\r\n\t\tif(result && _._updateRecursion==0)\r\n\t\t\t_._onUpdated();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// ICollection<T>\r\n\t/////////////////////////////////////////\r\n\tget isReadOnly():boolean { return false; }\r\n\r\n\tget count():number {\r\n\t\tthrow notImplemented(\"count\");\r\n\t}\r\n\r\n\tadd(item:IKeyValuePair<TKey, TValue>):void\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'item',\r\n\t\t\t\t'Dictionaries must use a valid key/value pair. \\''+item+'\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\tthis.addByKeyValue(item.key, item.value);\r\n\t}\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, keys = _.keys, count = keys.length;\r\n\r\n\t\tif(count)\r\n\t\t\t_.handleUpdate(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys.forEach(key=> { _.removeByKey(key); });\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\tif(_.count!=0) // After they've all been removed, then should be zero.\r\n\t\t\tconsole.warn(\"Dictionary clear() results in mismatched count.\");\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:IKeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item) return false;\r\n\r\n\t\tvar value = this.getValue(item.key);\r\n\t\treturn areEqual(value, item.value);\r\n\t}\r\n\r\n\tcopyTo(array:IKeyValuePair<TKey, TValue>[], index:number = 0):IKeyValuePair<TKey, TValue>[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t// This is a generic implementation that will work for all derived classes.\r\n\t\t// It can be overridden and optimized.\r\n\t\tvar e = this.getEnumerator();\r\n\t\twhile(e.moveNext()) // Disposes when finished.\r\n\t\t{\r\n\t\t\tarray[index++] = e.current;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\ttoArray():IKeyValuePair<TKey,TValue>[] {\r\n\t\treturn this.copyTo([],0);\r\n\t}\r\n\r\n\tremove(item:IKeyValuePair<TKey, TValue>):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\tvar key = item.key, value = this.getValue(key);\r\n\t\treturn (areEqual(value, item.value) && this.removeByKey(key))\r\n\t\t\t? 1 : 0;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\tget keys():TKey[] { throw notImplemented(\"keys\"); }\r\n\r\n\tget values():TValue[] { throw notImplemented(\"values\"); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key)) {\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\t_.setValue(key, value);\r\n\t}\r\n\r\n\tgetValue(key:TKey):TValue\r\n\t{\r\n\t\tthrow notImplemented(\r\n\t\t\t\"getValue(key: TKey): TValue\", \"When calling for key: \" + key\r\n\t\t);\r\n\t}\r\n\r\n\tsetValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tthrow notImplemented(\r\n\t\t\t\"setValue(key: TKey, value: TValue): boolean\", \"When setting \" + key + \":\" + value + \".\"\r\n\t\t);\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\tvar value = this.getValue(key);\r\n\t\treturn value!==undefined;\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, undefined);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\t_.keys.forEach(key=>\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportPairs(pairs:IKeyValuePair<TKey, TValue>[]):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\treturn _.handleUpdate(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar changed:boolean = false;\r\n\t\t\t\tpairs.forEach(\r\n\t\t\t\t\t\tpair=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_.setValue(pair.key, pair.value);\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\treturn changed;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tkeys = _.keys;\r\n\t\t\t\tlen = keys.length\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==undefined) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\nfunction notImplemented<T>(name:string, log:string = \"\"):any\r\n{\r\n\tconsole.log(\"DictionaryAbstractBase sub-class has not overridden \" + name + \". \" + log);\r\n\treturn new NotImplementedException(\"DictionaryAbstractBase.\" + name + \": Not implemented.\");\r\n}\r\n"]}