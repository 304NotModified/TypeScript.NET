{"version":3,"sources":["System/Collections/Queue.js","System/Collections/Queue.ts"],"names":["define","require","exports","Values","AU","Types_1","Integer_1","EnumeratorBase_1","forEach_1","NotImplementedException_1","InvalidOperationException_1","ArgumentOutOfRangeException_1","assertZeroOrGreater","value","property","assertIntegerZeroOrGreater","MINIMUM_GROW","GROW_FACTOR_HALF","DEFAULT_CAPACITY","emptyArray","Queue","Queue.constructor","get","Queue.count","enumerable","configurable","Queue.isReadOnly","Queue.add","Queue.clear","Queue.contains","Queue.copyTo","Queue.toArray","Queue.remove","Queue.dispose","Queue.forEach","Queue.setCapacity","Queue.enqueue","Queue.dequeue","Queue._getElement","Queue.peek","Queue.trimExcess","Queue.getEnumerator","Object","defineProperty"],"mappings":"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","file":"System/Collections/Queue.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n(function (deps, factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define(deps, factory);\r\n    }\r\n})([\"require\", \"exports\", '../Compare', './Array/Utility', '../Types', '../Integer', './Enumeration/EnumeratorBase', './Enumeration/forEach', '../Exceptions/NotImplementedException', '../Exceptions/InvalidOperationException', '../Exceptions/ArgumentOutOfRangeException'], function (require, exports) {\r\n    ///<reference path=\"ICollection.d.ts\"/>\r\n    ///<reference path=\"IList.d.ts\"/>\r\n    ///<reference path=\"Enumeration/IEnumerateEach.d.ts\"/>\r\n    ///<reference path=\"../FunctionTypes.d.ts\"/>\r\n    var Values = require('../Compare');\r\n    var AU = require('./Array/Utility');\r\n    var Types_1 = require('../Types');\r\n    var Integer_1 = require('../Integer');\r\n    var EnumeratorBase_1 = require('./Enumeration/EnumeratorBase');\r\n    var forEach_1 = require('./Enumeration/forEach');\r\n    var NotImplementedException_1 = require('../Exceptions/NotImplementedException');\r\n    var InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\r\n    var ArgumentOutOfRangeException_1 = require('../Exceptions/ArgumentOutOfRangeException');\r\n    var MINIMUM_GROW = 4;\r\n    var GROW_FACTOR_HALF = 100;\r\n    var DEFAULT_CAPACITY = MINIMUM_GROW;\r\n    var emptyArray = [];\r\n    var Queue = (function () {\r\n        function Queue(source) {\r\n            var _ = this;\r\n            _._head = 0;\r\n            _._tail = 0;\r\n            _._size = 0;\r\n            _._version = 0;\r\n            if (!source)\r\n                _._array = emptyArray;\r\n            else {\r\n                if (Types_1.default.isNumber(source)) {\r\n                    var capacity = source;\r\n                    assertIntegerZeroOrGreater(capacity, \"capacity\");\r\n                    _._array = capacity\r\n                        ? AU.initialize(capacity)\r\n                        : emptyArray;\r\n                }\r\n                else {\r\n                    var se = source;\r\n                    _._array = AU.initialize((se instanceof Array || Types_1.default.hasMember(se, \"length\"))\r\n                        ? se.length\r\n                        : DEFAULT_CAPACITY);\r\n                    forEach_1.default(se, function (e) { return _.enqueue(e); });\r\n                    _._version = 0;\r\n                }\r\n            }\r\n            _._capacity = _._array.length;\r\n        }\r\n        Object.defineProperty(Queue.prototype, \"count\", {\r\n            get: function () {\r\n                return this._size;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Queue.prototype, \"isReadOnly\", {\r\n            get: function () {\r\n                return false;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Queue.prototype.add = function (item) {\r\n            this.enqueue(item);\r\n        };\r\n        Queue.prototype.clear = function () {\r\n            var _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\r\n            if (head < tail)\r\n                AU.clear(array, head, size);\r\n            else {\r\n                AU.clear(array, head, array.length - head);\r\n                AU.clear(array, 0, tail);\r\n            }\r\n            _._head = 0;\r\n            _._tail = 0;\r\n            _._size = 0;\r\n            _._version++;\r\n            return size;\r\n        };\r\n        Queue.prototype.contains = function (item) {\r\n            var _ = this;\r\n            var array = _._array, index = _._head, count = _._size, len = _._capacity;\r\n            while (count-- > 0) {\r\n                if (Values.areEqual(array[index], item))\r\n                    return true;\r\n                index = (index + 1) % len;\r\n            }\r\n            return false;\r\n        };\r\n        Queue.prototype.copyTo = function (target, arrayIndex) {\r\n            if (arrayIndex === void 0) { arrayIndex = 0; }\r\n            if (target == null)\r\n                throw new Error(\"ArgumentNullException: array cannot be null.\");\r\n            assertIntegerZeroOrGreater(arrayIndex, \"arrayIndex\");\r\n            var _ = this, size = _._size;\r\n            if (!size)\r\n                return;\r\n            var numToCopy = size, source = _._array, len = _._capacity, head = _._head, lh = len - head, firstPart = (lh < size)\r\n                ? lh\r\n                : size;\r\n            AU.copyTo(source, target, head, arrayIndex, firstPart);\r\n            numToCopy -= firstPart;\r\n            if (numToCopy > 0)\r\n                AU.copyTo(source, target, 0, arrayIndex + len - head, numToCopy);\r\n            return target;\r\n        };\r\n        Queue.prototype.toArray = function () {\r\n            var _ = this, size = _._size;\r\n            var arr = AU.initialize(size);\r\n            return size ? _.copyTo(arr) : arr;\r\n        };\r\n        Queue.prototype.remove = function (item) {\r\n            throw new NotImplementedException_1.default(\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\r\n                \" since it would require destroying the underlying array to remove the item.\");\r\n        };\r\n        Queue.prototype.dispose = function () {\r\n            var _ = this;\r\n            _.clear();\r\n            if (_._array != emptyArray) {\r\n                _._array.length = _._capacity = 0;\r\n                _._array = emptyArray;\r\n            }\r\n            _._version = 0;\r\n        };\r\n        Queue.prototype.forEach = function (action) {\r\n            var _ = this, copy = _.toArray(), len = _._size;\r\n            for (var i = 0; i < len; i++) {\r\n                if (action(copy[i], i) === false)\r\n                    break;\r\n            }\r\n        };\r\n        Queue.prototype.setCapacity = function (capacity) {\r\n            assertIntegerZeroOrGreater(capacity, \"capacity\");\r\n            var _ = this, array = _._array, len = _._capacity;\r\n            if (capacity == len)\r\n                return;\r\n            var head = _._head, tail = _._tail, size = _._size;\r\n            if (array != emptyArray && capacity > len && head < tail) {\r\n                array.length = _._capacity = capacity;\r\n                _._version++;\r\n                return;\r\n            }\r\n            var newArray = AU.initialize(capacity);\r\n            if (size > 0) {\r\n                if (head < tail) {\r\n                    AU.copyTo(array, newArray, head, 0, size);\r\n                }\r\n                else {\r\n                    AU.copyTo(array, newArray, head, 0, len - head);\r\n                    AU.copyTo(array, newArray, 0, len - head, tail);\r\n                }\r\n            }\r\n            _._array = newArray;\r\n            _._capacity = capacity;\r\n            _._head = 0;\r\n            _._tail = (size == capacity) ? 0 : size;\r\n            _._version++;\r\n        };\r\n        Queue.prototype.enqueue = function (item) {\r\n            var _ = this, array = _._array, size = _._size, len = _._capacity;\r\n            if (size == len) {\r\n                var newCapacity = len * GROW_FACTOR_HALF;\r\n                if (newCapacity < len + MINIMUM_GROW)\r\n                    newCapacity = len + MINIMUM_GROW;\r\n                _.setCapacity(newCapacity);\r\n                array = _._array;\r\n                len = _._capacity;\r\n            }\r\n            var tail = _._tail;\r\n            array[tail] = item;\r\n            _._tail = (tail + 1) % len;\r\n            _._size = size + 1;\r\n            _._version++;\r\n        };\r\n        Queue.prototype.dequeue = function () {\r\n            var _ = this;\r\n            if (_._size == 0)\r\n                throw new InvalidOperationException_1.default(\"Cannot dequeue an empty queue.\");\r\n            var array = _._array, head = _._head;\r\n            var removed = _._array[head];\r\n            array[head] = null;\r\n            _._head = (head + 1) % _._capacity;\r\n            _._size--;\r\n            _._version++;\r\n            return removed;\r\n        };\r\n        Queue.prototype._getElement = function (index) {\r\n            assertIntegerZeroOrGreater(index, \"index\");\r\n            var _ = this;\r\n            return _._array[(_._head + index) % _._capacity];\r\n        };\r\n        Queue.prototype.peek = function () {\r\n            if (this._size == 0)\r\n                throw new InvalidOperationException_1.default(\"Cannot call peek on an empty queue.\");\r\n            return this._array[this._head];\r\n        };\r\n        Queue.prototype.trimExcess = function () {\r\n            var _ = this;\r\n            var size = _._size;\r\n            if (size < Math.floor(_._capacity * 0.9))\r\n                _.setCapacity(size);\r\n        };\r\n        Queue.prototype.getEnumerator = function () {\r\n            var _ = this;\r\n            var index;\r\n            var version;\r\n            return new EnumeratorBase_1.default(function () {\r\n                version = _._version;\r\n                index = 0;\r\n            }, function (yielder) {\r\n                if (version != _._version)\r\n                    throw new InvalidOperationException_1.default(\"Collection was changed during enumeration.\");\r\n                if (index == _._size)\r\n                    return yielder.yieldBreak();\r\n                return yielder.yieldReturn(_._getElement(index++));\r\n            });\r\n        };\r\n        return Queue;\r\n    })();\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = Queue;\r\n    function assertZeroOrGreater(value, property) {\r\n        if (value < 0)\r\n            throw new ArgumentOutOfRangeException_1.default(property, value, \"Must be greater than zero\");\r\n    }\r\n    function assertIntegerZeroOrGreater(value, property) {\r\n        Integer_1.default.assert(value, property);\r\n        assertZeroOrGreater(value, property);\r\n    }\r\n});\r\n//# sourceMappingURL=Queue.js.map","/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\n///<reference path=\"ICollection.d.ts\"/>\r\n///<reference path=\"IList.d.ts\"/>\r\n///<reference path=\"Enumeration/IEnumerateEach.d.ts\"/>\r\n///<reference path=\"../FunctionTypes.d.ts\"/>\r\nimport * as Values from '../Compare';\r\nimport * as AU from './Array/Utility';\r\nimport Type from '../Types';\r\nimport Integer from '../Integer';\r\nimport EnumeratorBase from './Enumeration/EnumeratorBase';\r\nimport forEach from './Enumeration/forEach';\r\nimport NotImplementedException from '../Exceptions/NotImplementedException';\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\nconst MINIMUM_GROW:number = 4;\r\n// var SHRINK_THRESHOLD: number = 32; // Unused?\r\n// var GROW_FACTOR: number = 200;  // double each time\r\nconst GROW_FACTOR_HALF:number = 100;\r\nconst DEFAULT_CAPACITY:number = MINIMUM_GROW;\r\nvar emptyArray:any[] = [];\r\n\r\nexport default\r\nclass Queue<T> implements ICollection<T>, IEnumerateEach<T>, IDisposable\r\n{\r\n\r\n\tprivate _array:T[];\r\n\tprivate _head:number;       // First valid element in the queue\r\n\tprivate _tail:number;       // Last valid element in the queue\r\n\tprivate _size:number;       // Number of elements.\r\n\tprivate _capacity:number;   // Maps to _array.length;\r\n\tprivate _version:number;\r\n\r\n\r\n\tconstructor(source?:IEnumerable<T> | IArray<T> | number)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\t\t_._version = 0;\r\n\r\n\t\tif(!source)\r\n\t\t\t_._array = emptyArray;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(Type.isNumber(source))\r\n\t\t\t{\r\n\t\t\t\tvar capacity = <number>source;\r\n\t\t\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\t\t\t_._array = capacity\r\n\t\t\t\t\t? AU.initialize<T>(capacity)\r\n\t\t\t\t\t: emptyArray;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar se = <IEnumerable<T> | IArray<T>> source;\r\n\t\t\t\t_._array = AU.initialize<T>(\r\n\t\t\t\t\t(se instanceof Array || Type.hasMember(se, \"length\"))\r\n\t\t\t\t\t\t? (<IArray<T>>se).length\r\n\t\t\t\t\t\t: DEFAULT_CAPACITY\r\n\t\t\t\t);\r\n\r\n\t\t\t\tforEach<T>(se, (e:T)=> _.enqueue(e));\r\n\r\n\t\t\t\t_._version = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._capacity = _._array.length;\r\n\t}\r\n\r\n\t// #region ICollection<T> implementation\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(item:T):void\r\n\t{\r\n\t\tthis.enqueue(item);\r\n\t}\r\n\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\r\n\t\tif(head<tail)\r\n\t\t\tAU.clear(array, head, size);\r\n\t\telse\r\n\t\t{\r\n\t\t\tAU.clear(array, head, array.length - head);\r\n\t\t\tAU.clear(array, 0, tail);\r\n\t\t}\r\n\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\t\t_._version++;\r\n\r\n\t\treturn size;\r\n\t}\r\n\r\n\tcontains(item:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar array = _._array, index = _._head, count = _._size, len = _._capacity;\r\n\r\n\t\twhile(count-->0)\r\n\t\t{\r\n\t\t\tif(Values.areEqual(array[index], item)) // May need a equality compare here.\r\n\t\t\t\treturn true;\r\n\r\n\t\t\tindex = (index + 1)%len;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tcopyTo(target:T[], arrayIndex:number = 0):T[]\r\n\t{\r\n\t\tif(target==null)\r\n\t\t\tthrow new Error(\"ArgumentNullException: array cannot be null.\");\r\n\r\n\t\tassertIntegerZeroOrGreater(arrayIndex, \"arrayIndex\");\r\n\r\n\t\tvar _ = this, size = _._size;\r\n\r\n\t\tif(!size) return;\r\n\r\n\t\tvar numToCopy = size,\r\n\t\t    source    = _._array,\r\n\t\t    len       = _._capacity,\r\n\t\t    head      = _._head,\r\n\t\t    lh        = len - head,\r\n\t\t    firstPart\r\n\t\t              = (lh<size)\r\n\t\t\t    ? lh\r\n\t\t\t    : size;\r\n\r\n\t\tAU.copyTo(source, target, head, arrayIndex, firstPart);\r\n\t\tnumToCopy -= firstPart;\r\n\r\n\t\tif(numToCopy>0)\r\n\t\t\tAU.copyTo(source, target, 0, arrayIndex + len - head, numToCopy);\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar _ = this, size = _._size;\r\n\t\tvar arr:T[] = AU.initialize<T>(size);\r\n\t\treturn size ? _.copyTo(arr) : arr;\r\n\t}\r\n\r\n\tremove(item:T):number\r\n\t{\r\n\t\tthrow new NotImplementedException(\r\n\t\t\t\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\r\n\t\t\t\" since it would require destroying the underlying array to remove the item.\"\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t// #endregion\r\n\r\n\t// Results in a complete reset.  Allows for easy cleanup elsewhere.\r\n\tdispose():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.clear();\r\n\t\tif(_._array!=emptyArray)\r\n\t\t{\r\n\t\t\t_._array.length = _._capacity = 0;\r\n\t\t\t_._array = emptyArray;\r\n\t\t}\r\n\t\t_._version = 0;\r\n\t}\r\n\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void\r\n\t{\r\n\t\t// Until implementing a changed enumeration mechanism, a copy needs to be used.\r\n\t\tvar _ = this, copy = _.toArray(), len = _._size;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tif(<any>action(copy[i], i)===false)\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\tsetCapacity(capacity:number):void\r\n\t{\r\n\r\n\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\tvar _ = this, array = _._array, len = _._capacity;\r\n\r\n\t\tif(capacity==len)\r\n\t\t\treturn;\r\n\r\n\t\tvar head = _._head, tail = _._tail, size = _._size;\r\n\r\n\t\t// Special case where we can simply extend the length of the array. (JavaScript only)\r\n\t\tif(array!=emptyArray && capacity>len && head<tail)\r\n\t\t{\r\n\t\t\tarray.length = _._capacity = capacity;\r\n\t\t\t_._version++;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We create a new array because modifying an existing one could be slow.\r\n\t\tvar newArray:T[] = AU.initialize<T>(capacity);\r\n\t\tif(size>0)\r\n\t\t{\r\n\t\t\tif(head<tail)\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, size);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, len - head);\r\n\t\t\t\tAU.copyTo(array, newArray, 0, len - head, tail);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._array = newArray;\r\n\t\t_._capacity = capacity;\r\n\t\t_._head = 0;\r\n\t\t_._tail = (size==capacity) ? 0 : size;\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tenqueue(item:T):void\r\n\t{\r\n\t\tvar _ = this, array = _._array, size = _._size, len = _._capacity;\r\n\t\tif(size==len)\r\n\t\t{\r\n\t\t\tvar newCapacity = len*GROW_FACTOR_HALF;\r\n\t\t\tif(newCapacity<len + MINIMUM_GROW)\r\n\t\t\t\tnewCapacity = len + MINIMUM_GROW;\r\n\r\n\t\t\t_.setCapacity(newCapacity);\r\n\t\t\tarray = _._array;\r\n\t\t\tlen = _._capacity;\r\n\t\t}\r\n\r\n\t\tvar tail = _._tail;\r\n\t\tarray[tail] = item;\r\n\t\t_._tail = (tail + 1)%len;\r\n\t\t_._size = size + 1;\r\n\t\t_._version++;\r\n\t}\r\n\r\n\tdequeue():T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_._size==0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot dequeue an empty queue.\");\r\n\r\n\t\tvar array = _._array, head = _._head;\r\n\r\n\t\tvar removed = _._array[head];\r\n\t\tarray[head] = null;\r\n\t\t_._head = (head + 1)%_._capacity;\r\n\r\n\t\t_._size--;\r\n\r\n\r\n\t\t/* Need a scheme for shrinking\r\n\t\t if (_._size < _._capacity / 2)\r\n\t\t {\r\n\t\t }*/\r\n\r\n\t\t_._version++;\r\n\t\treturn removed;\r\n\t}\r\n\r\n\tprivate _getElement(index:number):T\r\n\t{\r\n\t\tassertIntegerZeroOrGreater(index, \"index\");\r\n\r\n\t\tvar _ = this;\r\n\t\treturn _._array[(_._head + index)%_._capacity];\r\n\t}\r\n\r\n\tpeek():T\r\n\t{\r\n\t\tif(this._size==0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot call peek on an empty queue.\");\r\n\r\n\t\treturn this._array[this._head];\r\n\t}\r\n\r\n\ttrimExcess():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar size = _._size;\r\n\t\tif(size<Math.floor(_._capacity*0.9))\r\n\t\t\t_.setCapacity(size);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar index:number;\r\n\t\tvar version:number;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tversion = _._version;\r\n\t\t\t\tindex = 0;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\tif(version!=_._version)\r\n\t\t\t\t\tthrow new InvalidOperationException(\"Collection was changed during enumeration.\");\r\n\r\n\t\t\t\tif(index==_._size)\r\n\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\treturn yielder.yieldReturn(_._getElement(index++));\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction assertZeroOrGreater(value:number, property:string):void\r\n{\r\n\tif(value<0)\r\n\t\tthrow new ArgumentOutOfRangeException(property, value, \"Must be greater than zero\");\r\n\r\n}\r\n\r\nfunction assertIntegerZeroOrGreater(value:number, property:string):void\r\n{\r\n\tInteger.assert(value, property);\r\n\tassertZeroOrGreater(value, property);\r\n}\r\n"]}