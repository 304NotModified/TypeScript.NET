{"version":3,"sources":["System/Uri/Uri.js","System/Uri/Uri.ts"],"names":["define","require","exports","Types_1","QueryParams","Utility_1","Scheme_1","ArgumentException_1","ArgumentOutOfRangeException_1","copyUri","from","to","getScheme","scheme","getAuthority","uri","formatQuery","query","formatFragment","fragment","getPathAndQuery","uriToString","tryParse","url","out","Uri","Uri.constructor","Uri.equals","Uri.from","Uri.parse","Uri.tryParse","Uri.copyOf","Uri.copyTo","Uri.getAbsoluteUri","Uri.getAuthority","Uri.getPathAndQuery","get","Uri.pathSegments","enumerable","configurable","Uri.toMap","Uri.toString","Uri.Fields","SLASH","SLASH2","QM","HASH","EMPTY","AT","Object","defineProperty","value"],"mappings":";;;;;AAKAA,QAAQ,UAAW,UAAW,WAAY,qBAAsB,kBAAmB,gBAAiB,kCAAmC,6CAA8C,SAAUC,EAASC,EAASC,EAASC,EAAaC,EAAWC,EAAUC,EAAqBC,GC6PjR,QAAAC,GAAiBC,EAAWC,GAAAF,SAAAA,IAAAA,KAE3BA,KADAA,GAAWA,GAAPA,EAAIA,EACFA,EAAQA,EAAIA,OAAOA,MAAMA,CAC9BA,GAAIA,GAAcA,EAAMA,EACrBA,KAAaA,EAAIA,GAASA,GAE9BA,MAAOA,GAKR,QAAAG,GAAmBC,GAElBD,GAAIA,GAAQA,CACZA,IAAGA,EAAAA,WAAKA,SAASA,GACjBA,CACCA,IAAIA,EAAGA,MAAOA,OAIdA,IAFAA,EAAIA,EAAAA,WAAeA,EAAAA,KAAKA,GAAGA,cAAcA,QAAQA,kBAAmBA,IAEjEA,MAAMA,GACRA,KAAMA,IAAIA,GAAAA,WAA4BA,SAAUA,EAAQA,mBAG1DA,GAAGA,EAAAA,WAAKA,SAASA,GAAGA,GACpBA,CAECA,GADAA,EAAIA,EAAAA,WAAkBA,IAClBA,EACHA,KAAMA,IAAIA,GAAAA,WAA4BA,SAAUA,EAAQA,kBAEzDA,OAAOA,GAGRA,MAAOA,QAGR,QAAAE,GAAsBC,GAGrBD,IAAIA,EAAIA,KACRA,CACCA,GAAGA,EAAIA,SACNA,KAAMA,IAAIA,GAAAA,WAAkBA,OAAQA,kDAErCA,IAAGA,EAAAA,WAAKA,SAASA,EAAIA,MAAKA,GACzBA,KAAMA,IAAIA,GAAAA,WAAkBA,OAAQA,gDAOtCA,GAAIA,GAASA,EAAIA,MAAQA,CASzBA,OAPGA,KAECA,EAAIA,WAAUA,EAASA,EAAIA,SAAWA,EAAKA,GAC1CA,MAAMA,EAAIA,QAAOA,GAAUA,IAAMA,EAAIA,MACzCA,EAASA,EAASA,GAGZA,EAGR,QAAAE,GAAqBC,GAEpBD,MAAOA,KAA+BA,IAApBA,EAAMA,QAAQA,GAAWA,EAAKA,GAASA,EAG1D,QAAAE,GAAwBC,GAEvBD,MAAOA,KAAuCA,IAAzBA,EAASA,QAAQA,GAAaA,EAAOA,GAASA,EAGpE,QAAAE,GAAyBL,GAGxBK,GAAIA,GAAQA,EAAIA,KACZA,EAAQA,EAAIA,KAEhBA,OAAOA,IACHA,IAAgCA,IAAtBA,EAAKA,QAAQA,GAAcA,EAAQA,GAASA,GAASA,IAC/DA,EAAYA,IAAUA,GAI3B,QAAAC,GAAqBN,GAKpBM,GAAIA,GAAeA,EAAUA,EAAIA,QAC7BA,EAAeA,EAAaA,GAC5BA,EAAeA,EAAgBA,GAC/BA,EAAeA,EAAeA,EAAIA,SAEtCA,OAAOA,IACFA,GAAWA,EAASA,KAASA,IAC9BA,GAAaA,IACbA,GAAgBA,IAChBA,GAAYA,GAMjB,QAAAC,GAAkBC,EAAYC,GAE7BF,IAAIA,EACHA,MAAOA,IAAIA,GAAAA,WAAkBA,MAAOA,oBAOrCA,IAAIA,GAAUA,IAoBdA,IAjBAA,EAAIA,EAAIA,QAAQA,GACTA,IAAJA,IAEFA,EAAOA,SAAWA,EAAIA,UAAUA,GAChCA,EAAMA,EAAIA,UAAUA,EAAGA,IAIxBA,EAAIA,EAAIA,QAAQA,GACTA,IAAJA,IAEFA,EAAOA,MAAQA,EAAIA,UAAUA,GAC7BA,EAAMA,EAAIA,UAAUA,EAAGA,IAIxBA,EAAIA,EAAIA,QAAQA,GACTA,IAAJA,EACHA,CACCA,GAAIA,GAASA,EAAAA,KAAKA,EAAIA,UAAUA,EAAGA,IAAKA,EAAIA,IAC5CA,KAAIA,EAAEA,KAAKA,GACVA,MAAOA,IAAIA,GAAAA,WAAkBA,MAAMA,kCAEpCA,GAASA,EAAAA,KAAKA,EAAOA,QAAQA,EAAEA,IAC/BA,EAAOA,OAASA,GAAUA,OAE1BA,EAAMA,EAAIA,UAAUA,EAAIA,GAqBzBA,GAjBAA,EAAIA,EAAIA,QAAQA,GACTA,IAAJA,IAEFA,EAAOA,KAAOA,EAAIA,UAAUA,IAAMA,OAClCA,EAAMA,EAAIA,UAAUA,EAAGA,IAIxBA,EAAIA,EAAIA,QAAQA,GACTA,IAAJA,IAEFA,EAAOA,SAAWA,EAAIA,UAAUA,EAAGA,IAAMA,OACzCA,EAAMA,EAAIA,UAAUA,EAAIA,IAIzBA,EAAIA,EAAIA,QAAQA,KACTA,IAAJA,EACHA,CACCA,GAAIA,GAAOA,SAASA,EAAAA,KAAKA,EAAIA,UAAUA,EAAIA,IAC3CA,IAAGA,MAAMA,GACRA,MAAOA,IAAIA,GAAAA,WAAkBA,MAAMA,oBAEpCA,GAAOA,KAAOA,EACdA,EAAMA,EAAIA,UAAUA,EAAGA,GAUxBA,MAPAA,GAAMA,EAAAA,KAAKA,GACRA,IACFA,EAAOA,KAAOA,GAEfA,EAAIA,EAAQA,IAGLA,KAlaR,GA8NOG,GA9NPA,EAAA,WAsBCA,QAAAA,GACCA,EACAA,EACAA,EACAA,EACAA,EACAA,EACAA,GAEAC,GAAIA,GAAIA,IACRA,GAAEA,OAASA,EAAUA,IAAWA,KAChCA,EAAEA,SAAWA,GAAYA,KACzBA,EAAEA,KAAOA,GAAQA,KACjBA,EAAEA,KAAOA,GAAQA,KAEjBA,EAAEA,UAAYA,EAAEA,gBAAkBA,KAElCA,EAAEA,KAAOA,GAAQA,KAGbA,EAAAA,WAAKA,SAASA,KACjBA,EAAQA,EAAYA,OAA2DA,IAEhFA,EAAEA,MAAQA,EAAoBA,IAAUA,KACxCA,OAAOA,OAAOA,EAAEA,YACbA,EAAEA,MACFA,EAAYA,WAAWA,EAAEA,WAG5BA,EAAEA,aAAeA,EAAEA,mBAAqBA,KAExCA,EAAEA,SAAWA,EAAeA,IAAaA,KAGzCA,EAAEA,YAAcA,EAAEA,iBAGlBA,OAAOA,OAAOA,GAiKhBD,MAzJCA,GAAAA,UAAAA,OAAAA,SAAOA,GAENE,MAAOA,MAAKA,aAAaA,EAAIA,SAASA,IAShCF,EAAAA,KAAPA,SAAYA,GAEXG,GAAIA,IAAQA,GAAOA,EAAAA,WAAKA,SAASA,GAC9BA,EAAIA,MAAcA,GAAaA,CAElCA,OAAOA,IAAIA,GACVA,EAAIA,OACJA,EAAIA,SACJA,EAAIA,KACJA,EAAIA,KACJA,EAAIA,KACJA,EAAIA,MACJA,EAAIA,WAUCH,EAAAA,MAAPA,SAAaA,EAAYA,GAAAI,SAAAA,IAAAA,GAAAA,EAExBA,IAAIA,GAAcA,KACdA,EAAKA,EAASA,EAAIA,SAACA,GAAOA,EAASA,GACvCA,IAAGA,GAAkBA,EAAIA,KAAMA,EAC/BA,OAAOA,IASDJ,EAAAA,SAAPA,SAAgBA,EAAWA,GAC1BK,OAAQA,EAASA,EAAIA,IAGfL,EAAAA,OAAPA,SAAcA,GACbM,MAAOA,GAAQA,IAGhBN,EAAAA,UAAAA,OAAAA,SAAOA,GAENO,MAAOA,GAAQA,KAAKA,IAMXP,EAAAA,UAAAA,eAAVA,WAECQ,MAAOA,GAAYA,OAMVR,EAAAA,UAAAA,aAAVA,WAECS,MAAOA,GAAaA,OAMXT,EAAAA,UAAAA,gBAAVA,WAECU,MAAOA,GAAgBA,OA2BxBV,OAAAA,eAAIA,EAAAA,UAAAA,gBDxIOW,ICwIXX,WAECY,MAAOA,MAAKA,KAAKA,MAAMA,8BDvIbC,YAAY,EACZC,cAAc,IC6IzBd,EAAAA,UAAAA,MAAAA,WAECe,MAAOA,MAAKA,YAMbf,EAAAA,UAAAA,SAAAA,WAECgB,MAAOA,MAAKA,aAQNhB,EAAAA,SAAPA,SAAgBA,GAEfgB,MAAOA,aAAeA,GACbA,EAAKA,YACXA,EAAYA,IAQThB,EAAAA,aAAPA,SAAoBA,GAEnBS,MAAOA,GAAaA,IAItBT,MAEA,SAAOA,IACNA,SAAYA,GACXiB,EAAAA,EAAAA,OAAAA,GAAAA,SACAA,EAAAA,EAAAA,SAAAA,GAAAA,WACAA,EAAAA,EAAAA,KAAAA,GAAAA,OACAA,EAAAA,EAAAA,KAAAA,GAAAA,OACAA,EAAAA,EAAAA,KAAAA,GAAAA,OACAA,EAAAA,EAAAA,MAAAA,GAAAA,QACAA,EAAAA,EAAAA,SAAAA,GAAAA,YAPWjB,EAAAA,SAAAA,EAAAA,WAAZA,IAAYA,GAAAA,EAAAA,MASZA,QAAOA,OAAOA,IAVRA,IAAAA,MAsBP,IAAMkB,GAAQ,IAAKC,EAAS,KAAMC,EAAK,IAAKC,EAAO,IAAKC,EAAQ,GAAIC,EAAK,GAkLzEC,QAAAC,eAAAhD,EAAA,cAAAiD,OAAA,IDxOIjD,EAAAA,WCwOWuB","file":"System/Uri/Uri.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\r\n */\r\nimport Type from '../Types';\r\nimport * as QueryParams from '../Uri/QueryParams';\r\nimport { trim } from '../Text/Utility';\r\nimport UriScheme from '../Uri/Scheme';\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\nclass Uri {\r\n    constructor(scheme, userInfo, host, port, path, query, fragment) {\r\n        var _ = this;\r\n        _.scheme = getScheme(scheme) || null;\r\n        _.userInfo = userInfo || null;\r\n        _.host = host || null;\r\n        _.port = port || null;\r\n        _.authority = _.getAuthority() || null;\r\n        _.path = path || null;\r\n        if (!Type.isString(query))\r\n            query = QueryParams.encode(query);\r\n        _.query = formatQuery(query) || null;\r\n        Object.freeze(_.queryParams\r\n            = _.query\r\n                ? QueryParams.parseToMap(_.query)\r\n                : {});\r\n        _.pathAndQuery = _.getPathAndQuery() || null;\r\n        _.fragment = formatFragment(fragment) || null;\r\n        _.absoluteUri = _.getAbsoluteUri();\r\n        Object.freeze(_);\r\n    }\r\n    equals(other) {\r\n        return this.absoluteUri == Uri.toString(other);\r\n    }\r\n    static from(url) {\r\n        var uri = (!url || Type.isString(url))\r\n            ? Uri.parse(url) : url;\r\n        return new Uri(uri.scheme, uri.userInfo, uri.host, uri.port, uri.path, uri.query, uri.fragment);\r\n    }\r\n    static parse(url, throwIfInvalid = true) {\r\n        var result = null;\r\n        var ex = tryParse(url, (out) => { result = out; });\r\n        if (throwIfInvalid && ex)\r\n            throw ex;\r\n        return result;\r\n    }\r\n    static tryParse(url, out) {\r\n        return !tryParse(url, out);\r\n    }\r\n    static copyOf(map) {\r\n        return copyUri(map);\r\n    }\r\n    copyTo(map) {\r\n        return copyUri(this, map);\r\n    }\r\n    getAbsoluteUri() {\r\n        return uriToString(this);\r\n    }\r\n    getAuthority() {\r\n        return getAuthority(this);\r\n    }\r\n    getPathAndQuery() {\r\n        return getPathAndQuery(this);\r\n    }\r\n    get pathSegments() {\r\n        return this.path.match(/^[/]|[^/]*[/]|[^/]+$/g);\r\n    }\r\n    toMap() {\r\n        return this.copyTo({});\r\n    }\r\n    toString() {\r\n        return this.absoluteUri;\r\n    }\r\n    static toString(uri) {\r\n        return uri instanceof Uri\r\n            ? uri.absoluteUri\r\n            : uriToString(uri);\r\n    }\r\n    static getAuthority(uri) {\r\n        return getAuthority(uri);\r\n    }\r\n}\r\n(function (Uri) {\r\n    (function (Fields) {\r\n        Fields[Fields[\"scheme\"] = 0] = \"scheme\";\r\n        Fields[Fields[\"userInfo\"] = 1] = \"userInfo\";\r\n        Fields[Fields[\"host\"] = 2] = \"host\";\r\n        Fields[Fields[\"port\"] = 3] = \"port\";\r\n        Fields[Fields[\"path\"] = 4] = \"path\";\r\n        Fields[Fields[\"query\"] = 5] = \"query\";\r\n        Fields[Fields[\"fragment\"] = 6] = \"fragment\";\r\n    })(Uri.Fields || (Uri.Fields = {}));\r\n    var Fields = Uri.Fields;\r\n    Object.freeze(Fields);\r\n})(Uri || (Uri = {}));\r\nfunction copyUri(from, to = {}) {\r\n    var i = 0, field;\r\n    while (field = Uri.Fields[i++]) {\r\n        var value = from[field];\r\n        if (value)\r\n            to[field] = value;\r\n    }\r\n    return to;\r\n}\r\nconst SLASH = '/', SLASH2 = '//', QM = '?', HASH = '#', EMPTY = '', AT = '@';\r\nfunction getScheme(scheme) {\r\n    var s = scheme;\r\n    if (Type.isString(s)) {\r\n        if (!s)\r\n            return undefined;\r\n        s = UriScheme[trim(s).toLowerCase().replace(/[^a-z0-9+.-]+$/g, EMPTY)];\r\n        if (isNaN(s))\r\n            throw new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n    }\r\n    if (Type.isNumber(s, false)) {\r\n        s = UriScheme[s];\r\n        if (!s)\r\n            throw new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n        return s;\r\n    }\r\n    return undefined;\r\n}\r\nfunction getAuthority(uri) {\r\n    if (!uri.host) {\r\n        if (uri.userInfo)\r\n            throw new ArgumentException('host', 'Cannot include user info when there is no host.');\r\n        if (Type.isNumber(uri.port, false))\r\n            throw new ArgumentException('host', 'Cannot include a port when there is no host.');\r\n    }\r\n    var result = uri.host || EMPTY;\r\n    if (result) {\r\n        if (uri.userInfo)\r\n            result = uri.userInfo + AT + result;\r\n        if (!isNaN(uri.port))\r\n            result += ':' + uri.port;\r\n        result = SLASH2 + result;\r\n    }\r\n    return result;\r\n}\r\nfunction formatQuery(query) {\r\n    return query && ((query.indexOf(QM) == -1 ? QM : EMPTY) + query);\r\n}\r\nfunction formatFragment(fragment) {\r\n    return fragment && ((fragment.indexOf(HASH) == -1 ? HASH : EMPTY) + fragment);\r\n}\r\nfunction getPathAndQuery(uri) {\r\n    var path = uri.path, query = uri.query;\r\n    return EMPTY\r\n        + (path && ((path.indexOf(SLASH) == -1 ? SLASH : EMPTY) + path) || EMPTY)\r\n        + (formatQuery(query) || EMPTY);\r\n}\r\nfunction uriToString(uri) {\r\n    // scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n    // {scheme}{authority}{path}{query}{fragment}\r\n    var scheme = getScheme(uri.scheme), authority = getAuthority(uri), pathAndQuery = getPathAndQuery(uri), fragment = formatFragment(uri.fragment);\r\n    return EMPTY\r\n        + ((scheme && (scheme + ':')) || EMPTY)\r\n        + (authority || EMPTY)\r\n        + (pathAndQuery || EMPTY)\r\n        + (fragment || EMPTY);\r\n}\r\nfunction tryParse(url, out) {\r\n    if (!url)\r\n        return new ArgumentException('url', 'Nothing to parse.');\r\n    var i, result = {};\r\n    i = url.indexOf(HASH);\r\n    if (i != -1) {\r\n        result.fragment = url.substring(i);\r\n        url = url.substring(0, i);\r\n    }\r\n    i = url.indexOf(QM);\r\n    if (i != -1) {\r\n        result.query = url.substring(i);\r\n        url = url.substring(0, i);\r\n    }\r\n    i = url.indexOf(SLASH2);\r\n    if (i != -1) {\r\n        var scheme = trim(url.substring(0, i)), c = /:$/;\r\n        if (!c.test(scheme))\r\n            return new ArgumentException('url', 'Scheme was improperly formatted');\r\n        scheme = trim(scheme.replace(c, EMPTY));\r\n        result.scheme = scheme || undefined;\r\n        url = url.substring(i + 2);\r\n    }\r\n    i = url.indexOf(SLASH);\r\n    if (i != -1) {\r\n        result.path = url.substring(i) || undefined;\r\n        url = url.substring(0, i);\r\n    }\r\n    i = url.indexOf(AT);\r\n    if (i != -1) {\r\n        result.userInfo = url.substring(0, i) || undefined;\r\n        url = url.substring(i + 1);\r\n    }\r\n    i = url.indexOf(':');\r\n    if (i != -1) {\r\n        var port = parseInt(trim(url.substring(i + 1)));\r\n        if (isNaN(port))\r\n            return new ArgumentException('url', 'Port was invalid.');\r\n        result.port = port;\r\n        url = url.substring(0, i);\r\n    }\r\n    url = trim(url);\r\n    if (url)\r\n        result.host = url;\r\n    out(copyUri(result));\r\n    return null;\r\n}\r\nexport default Uri;\r\n//# sourceMappingURL=Uri.js.map","/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\r\n */\r\n\r\n///<reference path=\"IUri.d.ts\"/>\r\n///<reference path=\"../IEquatable.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\nimport Type from '../Types';\r\nimport * as QueryParams from '../Uri/QueryParams';\r\nimport {trim} from '../Text/Utility';\r\nimport UriScheme from '../Uri/Scheme';\r\nimport Exception from '../Exception';\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\n/**\r\n * Provides an read-only model representation of a uniform resource identifier (URI) and easy access to the parts of the URI.\r\n *\r\n * The read-only model (frozen) is easier for debugging than exposing accessors for each property.\r\n */\r\nclass Uri implements IUri, IEquatable<IUri>\r\n{\r\n\r\n\tscheme:string;\r\n\tuserInfo:string;\r\n\thost:string;\r\n\tport:number;\r\n\tpath:string;\r\n\tquery:string;\r\n\tfragment:string;\r\n\r\n\tqueryParams:IMap<Primitive|Primitive[]>;\r\n\r\n\t/**\r\n\t * @param scheme The user name, password, or other user-specific information associated with the specified URI.\r\n\t * @param userInfo The host component of this instance.\r\n\t * @param host The port number of this URI.\r\n\t * @param port The absolute path of the URI.\r\n\t * @param path The absolute path of the URI.\r\n\t * @param query Any query information included in the specified URI.\r\n\t * @param fragment The escaped URI fragment.\r\n\t */\r\n\tconstructor(\r\n\t\tscheme:UriScheme|string,\r\n\t\tuserInfo:string,\r\n\t\thost:string,\r\n\t\tport:number,\r\n\t\tpath:string,\r\n\t\tquery:string|IUriComponentMap|IKeyValuePair<string,Primitive>[],\r\n\t\tfragment:string)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.scheme = getScheme(scheme) || null;\r\n\t\t_.userInfo = userInfo || null;\r\n\t\t_.host = host || null;\r\n\t\t_.port = port || null;\r\n\r\n\t\t_.authority = _.getAuthority() || null;\r\n\r\n\t\t_.path = path || null;\r\n\r\n\r\n\t\tif(!Type.isString(query))\r\n\t\t\tquery = QueryParams.encode(<IUriComponentMap|IKeyValuePair<string,Primitive>[]>query);\r\n\r\n\t\t_.query = formatQuery(<string>query) || null;\r\n\t\tObject.freeze(_.queryParams\r\n\t\t\t= _.query\r\n\t\t\t? QueryParams.parseToMap(_.query)\r\n\t\t\t: {});\r\n\r\n\t\t_.pathAndQuery = _.getPathAndQuery() || null;\r\n\r\n\t\t_.fragment = formatFragment(fragment) || null;\r\n\r\n\t\t// This should validate the uri...\r\n\t\t_.absoluteUri = _.getAbsoluteUri();\r\n\r\n\t\t// Intended to be read-only.  Call .toMap() to get a writable copy.\r\n\t\tObject.freeze(_);\r\n\t}\r\n\r\n\t/**\r\n\t *  Compares the values of another IUri via toString comparison.\r\n \t * @param other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other:IUri):boolean\r\n\t{\r\n\t\treturn this.absoluteUri==Uri.toString(other);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Parses or clones values from existing Uri values.\r\n\t * @param url\r\n\t * @returns {Uri} An validated Uri object with the values.\r\n\t */\r\n\tstatic from(url:string|IUri):Uri\r\n\t{\r\n\t\tvar uri = (!url || Type.isString(url))\r\n\t\t\t? Uri.parse(<string>url) : <IUri>url;\r\n\r\n\t\treturn new Uri(\r\n\t\t\turi.scheme,\r\n\t\t\turi.userInfo,\r\n\t\t\turi.host,\r\n\t\t\turi.port,\r\n\t\t\turi.path,\r\n\t\t\turi.query,\r\n\t\t\turi.fragment\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param throwIfInvalid\r\n\t * @returns {IUri} Returns a map of the values or *null* if invalid and *throwIfInvalid* is <b>false</b>.\r\n\t */\r\n\tstatic parse(url:string, throwIfInvalid:boolean = true):IUri\r\n\t{\r\n\t\tvar result:IUri = null;\r\n\t\tvar ex = tryParse(url,(out)=>{result = out;});\r\n\t\tif(throwIfInvalid && ex) throw ex;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param out A delegate to capture the value.\r\n\t * @returns {boolean} True if valid.  False if invalid.\r\n\t */\r\n\tstatic tryParse(url:string,out:(result:IUri)=>void):boolean {\r\n\t\treturn !tryParse(url,out); // return type is Exception.\r\n\t}\r\n\r\n\tstatic copyOf(map:IUri):IUri {\r\n\t\treturn copyUri(map);\r\n\t}\r\n\r\n\tcopyTo(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(this,map);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAbsoluteUri():string\r\n\t{\r\n\t\treturn uriToString(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAuthority():string\r\n\t{\r\n\t\treturn getAuthority(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getPathAndQuery():string\r\n\t{\r\n\t\treturn getPathAndQuery(this);\r\n\t}\r\n\r\n\t/**\r\n\t * The absolute URI.\r\n\t */\r\n\tabsoluteUri:string;\r\n\r\n\t/**\r\n\t * Gets the Domain Name System (DNS) host name or IP address and the port number for a server.\r\n\t */\r\n\tauthority:string;\r\n\r\n\t/**\r\n\t * Gets the path and Query properties separated by a question mark (?).\r\n\t */\r\n\tpathAndQuery:string;\r\n\r\n\t/**\r\n\t * The segments that represent a path.<br/>\r\n\t * https://msdn.microsoft.com/en-us/library/system.uri.segments%28v=vs.110%29.aspx\r\n\t *\r\n\t * <h5><b>Example:</b></h5>\r\n\t * If the path value equals: ```/tree/node/index.html```<br/>\r\n\t * The result will be: ```['/','tree/','node/','index.html']```\r\n\t * @returns {string[]}\r\n\t */\r\n\tget pathSegments():string[]\r\n\t{\r\n\t\treturn this.path.match(/^[/]|[^/]*[/]|[^/]+$/g);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a writable copy.\r\n\t * @returns {IUri}\r\n\t */\r\n\ttoMap():IUri\r\n\t{\r\n\t\treturn this.copyTo({});\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {string} The full absolute uri.\r\n\t */\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.absoluteUri;\r\n\t}\r\n\r\n\t/**\r\n\t * Properly converts an existing URI to a string.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic toString(uri:IUri):string\r\n\t{\r\n\t\treturn uri instanceof Uri\r\n\t\t\t? (<Uri>uri).absoluteUri\r\n\t\t\t: uriToString(uri);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the authority segment of an URI.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic getAuthority(uri:IUri):string\r\n\t{\r\n\t\treturn getAuthority(uri);\r\n\t}\r\n\r\n\r\n}\r\n\r\nmodule Uri {\r\n\texport enum Fields {\r\n\t\tscheme,\r\n\t\tuserInfo,\r\n\t\thost,\r\n\t\tport,\r\n\t\tpath,\r\n\t\tquery,\r\n\t\tfragment\r\n\t}\r\n\tObject.freeze(Fields);\r\n}\r\n\r\nfunction copyUri(from:IUri, to:IUri = {}) {\r\n\tvar i = 0, field:string;\r\n\twhile(field = Uri.Fields[i++]) {\r\n\t\tvar value = (<any>from)[field];\r\n\t\tif(value) (<any>to)[field] = value;\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nconst SLASH = '/', SLASH2 = '//', QM = '?', HASH = '#', EMPTY = '', AT = '@';\r\n\r\nfunction getScheme(scheme:UriScheme|string):string\r\n{\r\n\tvar s:any = scheme;\r\n\tif(Type.isString(s))\r\n\t{\r\n\t\tif(!s) return undefined;\r\n\r\n\t\ts = UriScheme[<any>trim(s).toLowerCase().replace(/[^a-z0-9+.-]+$/g, EMPTY)];\r\n\r\n\t\tif(isNaN(s))\r\n\t\t\tthrow new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n\t}\r\n\r\n\tif(Type.isNumber(s, false))\r\n\t{\r\n\t\ts = UriScheme[<number>s];\r\n\t\tif(!s)\r\n\t\t\tthrow new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n\r\n\t\treturn s;\r\n\t}\r\n\r\n\treturn undefined;\r\n}\r\n\r\nfunction getAuthority(uri:IUri):string\r\n{\r\n\r\n\tif(!uri.host)\r\n\t{\r\n\t\tif(uri.userInfo)\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include user info when there is no host.');\r\n\r\n\t\tif(Type.isNumber(uri.port,false))\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include a port when there is no host.');\r\n\t}\r\n\r\n\t/*\r\n\t * [//[user:password@]host[:port]]\r\n\t */\r\n\r\n\tvar result = uri.host || EMPTY;\r\n\r\n\tif(result)\r\n\t{\r\n\t\tif(uri.userInfo) result = uri.userInfo + AT + result;\r\n\t\tif(!isNaN(uri.port)) result += ':' + uri.port;\r\n\t\tresult = SLASH2 + result;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction formatQuery(query:string):string\r\n{\r\n\treturn query && ((query.indexOf(QM)== -1 ? QM : EMPTY) + query);\r\n}\r\n\r\nfunction formatFragment(fragment:string):string\r\n{\r\n\treturn fragment && ((fragment.indexOf(HASH)== -1 ? HASH : EMPTY) + fragment);\r\n}\r\n\r\nfunction getPathAndQuery(uri:IUri):string\r\n{\r\n\r\n\tvar path  = uri.path,\r\n\t    query = uri.query;\r\n\r\n\treturn EMPTY\r\n\t\t+ (path && ((path.indexOf(SLASH)== -1 ? SLASH : EMPTY) + path) || EMPTY)\r\n\t\t+ (formatQuery(query) || EMPTY);\r\n\r\n}\r\n\r\nfunction uriToString(uri:IUri):string\r\n{\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\t// {scheme}{authority}{path}{query}{fragment}\r\n\r\n\tvar scheme       = getScheme(uri.scheme),\r\n\t    authority    = getAuthority(uri),\r\n\t    pathAndQuery = getPathAndQuery(uri),\r\n\t    fragment     = formatFragment(uri.fragment);\r\n\r\n\treturn EMPTY\r\n\t\t+ ((scheme && (scheme + ':')) || EMPTY)\r\n\t\t+ (authority || EMPTY)\r\n\t\t+ (pathAndQuery || EMPTY)\r\n\t\t+ (fragment || EMPTY)\r\n\r\n}\r\n\r\n\r\n\r\nfunction tryParse(url:string, out:(result:IUri)=>void):Exception\r\n{\r\n\tif(!url)\r\n\t\treturn new ArgumentException('url', 'Nothing to parse.');\r\n\r\n\r\n\t// Could use a regex here, but well follow some rules instead.\r\n\t// The intention is to 'gather' the pieces.  This isn't validation (yet).\r\n\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\tvar i:number, result:IUri = {};\r\n\r\n\t// Anything after the first # is the fragment.\r\n\ti = url.indexOf(HASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.fragment = url.substring(i);\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Anything after the first ? is the query.\r\n\ti = url.indexOf(QM);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.query = url.substring(i);\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Guarantees a separation.\r\n\ti = url.indexOf(SLASH2);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tvar scheme = trim(url.substring(0, i)), c = /:$/;\r\n\t\tif(!c.test(scheme))\r\n\t\t\treturn new ArgumentException('url','Scheme was improperly formatted');\r\n\r\n\t\tscheme = trim(scheme.replace(c,EMPTY));\r\n\t\tresult.scheme = scheme || undefined;\r\n\r\n\t\turl = url.substring(i + 2);\r\n\t}\r\n\r\n\t// Find any path information.\r\n\ti = url.indexOf(SLASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.path = url.substring(i) || undefined;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Separate user info.\r\n\ti = url.indexOf(AT);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.userInfo = url.substring(0, i) || undefined;\r\n\t\turl = url.substring(i + 1);\r\n\t}\r\n\r\n\t// Remaining is host and port.\r\n\ti = url.indexOf(':');\r\n\tif(i!= -1)\r\n\t{\r\n\t\tvar port = parseInt(trim(url.substring(i + 1)));\r\n\t\tif(isNaN(port))\r\n\t\t\treturn new ArgumentException('url','Port was invalid.');\r\n\r\n\t\tresult.port = port;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\turl = trim(url);\r\n\tif(url)\r\n\t\tresult.host = url;\r\n\r\n\tout(copyUri(result));\r\n\r\n\t// null is good! (here)\r\n\treturn null;\r\n\r\n}\r\n\r\nexport default Uri;\r\n"]}