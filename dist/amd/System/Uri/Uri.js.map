{"version":3,"sources":["System/Uri/Uri.js","System/Uri/Uri.ts"],"names":["define","require","exports","Types_1","QueryParams","Utility_1","Scheme_1","ArgumentException_1","ArgumentOutOfRangeException_1","copyUri","from","to","field","i","Fields","value","getScheme","scheme","s","isString","undefined","trim","toLowerCase","replace","EMPTY","isNaN","isNumber","getAuthority","uri","host","userInfo","port","result","AT","SLASH2","formatQuery","query","indexOf","QM","formatFragment","fragment","HASH","getPathAndQuery","path","SLASH","uriToString","authority","pathAndQuery","tryParse","url","out","substring","c","test","ex","parseInt","Uri","_","this","encode","Object","freeze","queryParams","parseToMap","absoluteUri","getAbsoluteUri","prototype","equals","other","toString","defaults","u","parse","throwIfInvalid","copyOf","map","copyTo","updateQuery","toMap","defineProperty","get","match","enumerable","configurable"],"mappings":";;;;;AAKAA,QAAQ,UAAW,UAAW,WAAY,qBAAsB,kBAAmB,gBAAiB,kCAAmC,6CAA8C,SAAUC,EAASC,EAASC,EAASC,EAAaC,EAAWC,EAAUC,EAAqBC,GCIjR,YAqQA,SAAAC,GAAiBC,EAAWC,GAE3B,GAAWC,GAAPC,EAAI,CAER,KADIF,IAAIA,MACFC,EAAQE,EAAOD,MACrB,CACC,GAAIE,GAAcL,EAAME,EACrBG,KAAaJ,EAAIC,GAASG,GAE9B,MAAOJ,GAKR,QAAAK,GAAmBC,GAElB,GAAIC,GAAQD,CACZ,IAAGd,EAAAA,WAAKgB,SAASD,GACjB,CACC,IAAIA,EAAG,MAAOE,OAId,IAFAF,EAAIZ,EAAAA,WAAeD,EAAAgB,KAAKH,GAAGI,cAAcC,QAAQ,kBAAmBC,IAEjEC,MAAMP,GACR,KAAM,IAAIV,GAAAA,WAA4B,SAAUS,EAAQ,mBAG1D,GAAGd,EAAAA,WAAKuB,SAASR,GAAG,GACpB,CAEC,GADAA,EAAIZ,EAAAA,WAAkBY,IAClBA,EACH,KAAM,IAAIV,GAAAA,WAA4B,SAAUS,EAAQ,kBAEzD,OAAOC,GAGR,MAAOE,QAGR,QAAAO,GAAsBC,GAGrB,IAAIA,EAAIC,KACR,CACC,GAAGD,EAAIE,SACN,KAAM,IAAIvB,GAAAA,WAAkB,OAAQ,kDAErC,IAAGJ,EAAAA,WAAKuB,SAASE,EAAIG,MAAM,GAC1B,KAAM,IAAIxB,GAAAA,WAAkB,OAAQ,gDAOtC,GAAIyB,GAASJ,EAAIC,MAAQL,CASzB,OAPGQ,KAECJ,EAAIE,WAAUE,EAASJ,EAAIE,SAAWG,EAAKD,GAC1CP,MAAMG,EAAIG,QAAOC,GAAU,IAAMJ,EAAIG,MACzCC,EAASE,EAASF,GAGZA,EAGR,QAAAG,GAAqBC,GAEpB,MAAOA,KAA+B,IAApBA,EAAMC,QAAQC,GAAWA,EAAKd,GAASY,EAG1D,QAAAG,GAAwBC,GAEvB,MAAOA,KAAuC,IAAzBA,EAASH,QAAQI,GAAaA,EAAOjB,GAASgB,EAGpE,QAAAE,GAAyBd,GAGxB,GAAIe,GAAOf,EAAIe,KACdP,EAAQR,EAAIQ,KAEb,OAAOZ,IACHmB,IAAgC,IAAtBA,EAAKN,QAAQO,GAAcA,EAAQpB,GAASmB,GAASnB,IAC/DW,EAAYC,IAAUZ,GAI3B,QAAAqB,GAAqBjB,GAKpB,GAAIX,GAASD,EAAUY,EAAIX,QAC1B6B,EAAYnB,EAAaC,GACzBmB,EAAeL,EAAgBd,GAC/BY,EAAWD,EAAeX,EAAIY,SAE/B,OAAOhB,IACFP,GAAWA,EAAS,KAASO,IAC9BsB,GAAatB,IACbuB,GAAgBvB,IAChBgB,GAAYhB,GAKjB,QAAAwB,GAAkBC,EAAYC,GAE7B,IAAID,EACH,MAAO,IAAI1C,GAAAA,WAAkB,MAAO,oBAOrC,IAAIM,GAAUmB,IAoBd,IAjBAnB,EAAIoC,EAAIZ,QAAQI,GACT,IAAJ5B,IAEFmB,EAAOQ,SAAWS,EAAIE,UAAUtC,GAChCoC,EAAMA,EAAIE,UAAU,EAAGtC,IAIxBA,EAAIoC,EAAIZ,QAAQC,GACT,IAAJzB,IAEFmB,EAAOI,MAAQa,EAAIE,UAAUtC,GAC7BoC,EAAMA,EAAIE,UAAU,EAAGtC,IAIxBA,EAAIoC,EAAIZ,QAAQH,GACT,IAAJrB,EACH,CACC,GAAII,GAASZ,EAAAgB,KAAK4B,EAAIE,UAAU,EAAGtC,IAAKuC,EAAI,IAC5C,KAAIA,EAAEC,KAAKpC,GACV,MAAO,IAAIV,GAAAA,WAAkB,MAAO,kCAErCU,GAASZ,EAAAgB,KAAKJ,EAAOM,QAAQ6B,EAAG5B,GAChC,KAECQ,EAAOf,OAASD,EAAUC,IAAWG,OAEtC,MAAMkC,GAEL,MAAOA,GAGRL,EAAMA,EAAIE,UAAUtC,EAAI,GAqBzB,GAjBAA,EAAIoC,EAAIZ,QAAQO,GACT,IAAJ/B,IAEFmB,EAAOW,KAAOM,EAAIE,UAAUtC,IAAMO,OAClC6B,EAAMA,EAAIE,UAAU,EAAGtC,IAIxBA,EAAIoC,EAAIZ,QAAQJ,GACT,IAAJpB,IAEFmB,EAAOF,SAAWmB,EAAIE,UAAU,EAAGtC,IAAMO,OACzC6B,EAAMA,EAAIE,UAAUtC,EAAI,IAIzBA,EAAIoC,EAAIZ,QAAQ,KACT,IAAJxB,EACH,CACC,GAAIkB,GAAOwB,SAASlD,EAAAgB,KAAK4B,EAAIE,UAAUtC,EAAI,IAC3C,IAAGY,MAAMM,GACR,MAAO,IAAIxB,GAAAA,WAAkB,MAAO,oBAErCyB,GAAOD,KAAOA,EACdkB,EAAMA,EAAIE,UAAU,EAAGtC,GAUxB,MAPAoC,GAAM5C,EAAAgB,KAAK4B,GACRA,IACFjB,EAAOH,KAAOoB,GAEfC,EAAIzC,EAAQuB,IAGL,KApbR,GAAAwB,GAAA,WAsBC,QAAAA,GACCvC,EACAa,EACAD,EACAE,EACAY,EACAP,EACAI,GAEA,GAAIiB,GAAIC,IACRD,GAAExC,OAASD,EAAUC,IAAW,KAChCwC,EAAE3B,SAAWA,GAAY,KACzB2B,EAAE5B,KAAOA,GAAQ,KACjB4B,EAAE1B,KAAOA,GAAQ,KAEjB0B,EAAEX,UAAYW,EAAE9B,gBAAkB,KAElC8B,EAAEd,KAAOA,GAAQ,KAGbxC,EAAAA,WAAKgB,SAASiB,KACjBA,EAAQhC,EAAYuD,OAAyDvB,IAE9EqB,EAAErB,MAAQD,EAAoBC,IAAU,KACxCwB,OAAOC,OAAOJ,EAAEK,YACbL,EAAErB,MACFhC,EAAY2D,WAAWN,EAAErB,WAG5BqB,EAAEV,aAAeU,EAAEf,mBAAqB,KAExCe,EAAEjB,SAAWD,EAAeC,IAAa,KAGzCiB,EAAEO,YAAcP,EAAEQ,iBAGlBL,OAAOC,OAAOJ,GA4KhB,MApKCD,GAAAU,UAAAC,OAAA,SAAOC,GAEN,MAAOV,QAAOU,GAASV,KAAKM,aAAaR,EAAIa,SAASD,IAUhDZ,EAAA9C,KAAP,SAAYkB,EAAiB0C,GAE5B,GAAIC,IAAM3C,GAAOzB,EAAAA,WAAKgB,SAASS,GAC5B4B,EAAIgB,MAAc5C,GAAaA,CAElC,OAAO,IAAI4B,GACVe,EAAEtD,QAAUqD,GAAYA,EAASrD,OACjCsD,EAAEzC,UAAYwC,GAAYA,EAASxC,SACnCyC,EAAE1C,MAAQyC,GAAYA,EAASzC,KAC/BJ,MAAM8C,EAAExC,MAAQuC,GAAYA,EAASvC,KAAOwC,EAAExC,KAC9CwC,EAAE5B,MAAQ2B,GAAYA,EAAS3B,KAC/B4B,EAAEnC,OAASkC,GAAYA,EAASlC,MAChCmC,EAAE/B,UAAY8B,GAAYA,EAAS9B,WAU9BgB,EAAAgB,MAAP,SAAavB,EAAYwB,GAAA,SAAAA,IAAAA,GAAA,EAExB,IAAIzC,GAAc,KACdsB,EAAKN,EAASC,EAAK,SAACC,GAAQlB,EAASkB,GACzC,IAAGuB,GAAkBnB,EAAI,KAAMA,EAC/B,OAAOtB,IASDwB,EAAAR,SAAP,SAAgBC,EAAYC,GAE3B,OAAQF,EAASC,EAAKC,IAGhBM,EAAAkB,OAAP,SAAcC,GAEb,MAAOlE,GAAQkE,IAGhBnB,EAAAU,UAAAU,OAAA,SAAOD,GAEN,MAAOlE,GAAQiD,KAAMiB,IAGtBnB,EAAAU,UAAAW,YAAA,SAAYzC,GAEX,GAAIuC,GAAMjB,KAAKoB,OAEf,OADAH,GAAIvC,MAAaA,EACVoB,EAAI9C,KAAKiE,IAOPnB,EAAAU,UAAAD,eAAV,WAEC,MAAOpB,GAAYa,OAMVF,EAAAU,UAAAvC,aAAV,WAEC,MAAOA,GAAa+B,OAMXF,EAAAU,UAAAxB,gBAAV,WAEC,MAAOA,GAAgBgB,OA2BxBE,OAAAmB,eAAIvB,EAAAU,UAAA,gBDhJOc,ICgJX,WAEC,MAAOtB,MAAKf,KAAKsC,MAAM,0BD/IbC,YAAY,EACZC,cAAc,ICqJzB3B,EAAAU,UAAAY,MAAA,WAEC,MAAOpB,MAAKkB,YAMbpB,EAAAU,UAAAG,SAAA,WAEC,MAAOX,MAAKM,aAQNR,EAAAa,SAAP,SAAgBzC,GAEf,MAAOA,aAAe4B,GACb5B,EAAKoC,YACXnB,EAAYjB,IAQT4B,EAAA7B,aAAP,SAAoBC,GAEnB,MAAOD,GAAaC,IAItB4B,IAvOAI,QAAAmB,eAAA7E,EAAA,cAAAa,OAAA,IDiEIb,EAAAA,WAAkBsD,ECwKtB,SAAY1C,GACXA,EAAAA,EAAA,OAAA,GAAA,SACAA,EAAAA,EAAA,SAAA,GAAA,WACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,MAAA,GAAA,QACAA,EAAAA,EAAA,SAAA,GAAA,YAPWZ,EAAAY,SAAAZ,EAAAY,WAAZ,IAAYA,GAAAZ,EAAAY,MASZ8C,QAAOC,OAAO/C,EAcd,IAAM8B,GAAQ,IAAKV,EAAS,KAAMI,EAAK,IAAKG,EAAO,IAAKjB,EAAQ,GAAIS,EAAK","file":"System/Uri/Uri.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\r\n */\r\n(function (factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define([\"require\", \"exports\", '../Types', '../Uri/QueryParams', '../Text/Utility', '../Uri/Scheme', '../Exceptions/ArgumentException', '../Exceptions/ArgumentOutOfRangeException'], factory);\r\n    }\r\n})(function (require, exports) {\r\n    'use strict';\r\n    var Types_1 = require('../Types');\r\n    var QueryParams = require('../Uri/QueryParams');\r\n    var Utility_1 = require('../Text/Utility');\r\n    var Scheme_1 = require('../Uri/Scheme');\r\n    var ArgumentException_1 = require('../Exceptions/ArgumentException');\r\n    var ArgumentOutOfRangeException_1 = require('../Exceptions/ArgumentOutOfRangeException');\r\n    var Uri = (function () {\r\n        function Uri(scheme, userInfo, host, port, path, query, fragment) {\r\n            var _ = this;\r\n            _.scheme = getScheme(scheme) || null;\r\n            _.userInfo = userInfo || null;\r\n            _.host = host || null;\r\n            _.port = port || null;\r\n            _.authority = _.getAuthority() || null;\r\n            _.path = path || null;\r\n            if (!Types_1.default.isString(query))\r\n                query = QueryParams.encode(query);\r\n            _.query = formatQuery(query) || null;\r\n            Object.freeze(_.queryParams\r\n                = _.query\r\n                    ? QueryParams.parseToMap(_.query)\r\n                    : {});\r\n            _.pathAndQuery = _.getPathAndQuery() || null;\r\n            _.fragment = formatFragment(fragment) || null;\r\n            _.absoluteUri = _.getAbsoluteUri();\r\n            Object.freeze(_);\r\n        }\r\n        Uri.prototype.equals = function (other) {\r\n            return this === other || this.absoluteUri == Uri.toString(other);\r\n        };\r\n        Uri.from = function (uri, defaults) {\r\n            var u = (!uri || Types_1.default.isString(uri))\r\n                ? Uri.parse(uri) : uri;\r\n            return new Uri(u.scheme || defaults && defaults.scheme, u.userInfo || defaults && defaults.userInfo, u.host || defaults && defaults.host, isNaN(u.port) ? defaults && defaults.port : u.port, u.path || defaults && defaults.path, u.query || defaults && defaults.query, u.fragment || defaults && defaults.fragment);\r\n        };\r\n        Uri.parse = function (url, throwIfInvalid) {\r\n            if (throwIfInvalid === void 0) { throwIfInvalid = true; }\r\n            var result = null;\r\n            var ex = tryParse(url, function (out) { result = out; });\r\n            if (throwIfInvalid && ex)\r\n                throw ex;\r\n            return result;\r\n        };\r\n        Uri.tryParse = function (url, out) {\r\n            return !tryParse(url, out);\r\n        };\r\n        Uri.copyOf = function (map) {\r\n            return copyUri(map);\r\n        };\r\n        Uri.prototype.copyTo = function (map) {\r\n            return copyUri(this, map);\r\n        };\r\n        Uri.prototype.updateQuery = function (query) {\r\n            var map = this.toMap();\r\n            map.query = query;\r\n            return Uri.from(map);\r\n        };\r\n        Uri.prototype.getAbsoluteUri = function () {\r\n            return uriToString(this);\r\n        };\r\n        Uri.prototype.getAuthority = function () {\r\n            return getAuthority(this);\r\n        };\r\n        Uri.prototype.getPathAndQuery = function () {\r\n            return getPathAndQuery(this);\r\n        };\r\n        Object.defineProperty(Uri.prototype, \"pathSegments\", {\r\n            get: function () {\r\n                return this.path.match(/^[/]|[^/]*[/]|[^/]+$/g);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Uri.prototype.toMap = function () {\r\n            return this.copyTo({});\r\n        };\r\n        Uri.prototype.toString = function () {\r\n            return this.absoluteUri;\r\n        };\r\n        Uri.toString = function (uri) {\r\n            return uri instanceof Uri\r\n                ? uri.absoluteUri\r\n                : uriToString(uri);\r\n        };\r\n        Uri.getAuthority = function (uri) {\r\n            return getAuthority(uri);\r\n        };\r\n        return Uri;\r\n    }());\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = Uri;\r\n    (function (Fields) {\r\n        Fields[Fields[\"scheme\"] = 0] = \"scheme\";\r\n        Fields[Fields[\"userInfo\"] = 1] = \"userInfo\";\r\n        Fields[Fields[\"host\"] = 2] = \"host\";\r\n        Fields[Fields[\"port\"] = 3] = \"port\";\r\n        Fields[Fields[\"path\"] = 4] = \"path\";\r\n        Fields[Fields[\"query\"] = 5] = \"query\";\r\n        Fields[Fields[\"fragment\"] = 6] = \"fragment\";\r\n    })(exports.Fields || (exports.Fields = {}));\r\n    var Fields = exports.Fields;\r\n    Object.freeze(Fields);\r\n    function copyUri(from, to) {\r\n        var i = 0, field;\r\n        if (!to)\r\n            to = {};\r\n        while (field = Fields[i++]) {\r\n            var value = from[field];\r\n            if (value)\r\n                to[field] = value;\r\n        }\r\n        return to;\r\n    }\r\n    var SLASH = '/', SLASH2 = '//', QM = '?', HASH = '#', EMPTY = '', AT = '@';\r\n    function getScheme(scheme) {\r\n        var s = scheme;\r\n        if (Types_1.default.isString(s)) {\r\n            if (!s)\r\n                return undefined;\r\n            s = Scheme_1.default[Utility_1.trim(s).toLowerCase().replace(/[^a-z0-9+.-]+$/g, EMPTY)];\r\n            if (isNaN(s))\r\n                throw new ArgumentOutOfRangeException_1.default('scheme', scheme, 'Invalid scheme.');\r\n        }\r\n        if (Types_1.default.isNumber(s, false)) {\r\n            s = Scheme_1.default[s];\r\n            if (!s)\r\n                throw new ArgumentOutOfRangeException_1.default('scheme', scheme, 'Invalid scheme.');\r\n            return s;\r\n        }\r\n        return undefined;\r\n    }\r\n    function getAuthority(uri) {\r\n        if (!uri.host) {\r\n            if (uri.userInfo)\r\n                throw new ArgumentException_1.default('host', 'Cannot include user info when there is no host.');\r\n            if (Types_1.default.isNumber(uri.port, false))\r\n                throw new ArgumentException_1.default('host', 'Cannot include a port when there is no host.');\r\n        }\r\n        var result = uri.host || EMPTY;\r\n        if (result) {\r\n            if (uri.userInfo)\r\n                result = uri.userInfo + AT + result;\r\n            if (!isNaN(uri.port))\r\n                result += ':' + uri.port;\r\n            result = SLASH2 + result;\r\n        }\r\n        return result;\r\n    }\r\n    function formatQuery(query) {\r\n        return query && ((query.indexOf(QM) == -1 ? QM : EMPTY) + query);\r\n    }\r\n    function formatFragment(fragment) {\r\n        return fragment && ((fragment.indexOf(HASH) == -1 ? HASH : EMPTY) + fragment);\r\n    }\r\n    function getPathAndQuery(uri) {\r\n        var path = uri.path, query = uri.query;\r\n        return EMPTY\r\n            + (path && ((path.indexOf(SLASH) == -1 ? SLASH : EMPTY) + path) || EMPTY)\r\n            + (formatQuery(query) || EMPTY);\r\n    }\r\n    function uriToString(uri) {\r\n        var scheme = getScheme(uri.scheme), authority = getAuthority(uri), pathAndQuery = getPathAndQuery(uri), fragment = formatFragment(uri.fragment);\r\n        return EMPTY\r\n            + ((scheme && (scheme + ':')) || EMPTY)\r\n            + (authority || EMPTY)\r\n            + (pathAndQuery || EMPTY)\r\n            + (fragment || EMPTY);\r\n    }\r\n    function tryParse(url, out) {\r\n        if (!url)\r\n            return new ArgumentException_1.default('url', 'Nothing to parse.');\r\n        var i, result = {};\r\n        i = url.indexOf(HASH);\r\n        if (i != -1) {\r\n            result.fragment = url.substring(i);\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.indexOf(QM);\r\n        if (i != -1) {\r\n            result.query = url.substring(i);\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.indexOf(SLASH2);\r\n        if (i != -1) {\r\n            var scheme = Utility_1.trim(url.substring(0, i)), c = /:$/;\r\n            if (!c.test(scheme))\r\n                return new ArgumentException_1.default('url', 'Scheme was improperly formatted');\r\n            scheme = Utility_1.trim(scheme.replace(c, EMPTY));\r\n            try {\r\n                result.scheme = getScheme(scheme) || undefined;\r\n            }\r\n            catch (ex) {\r\n                return ex;\r\n            }\r\n            url = url.substring(i + 2);\r\n        }\r\n        i = url.indexOf(SLASH);\r\n        if (i != -1) {\r\n            result.path = url.substring(i) || undefined;\r\n            url = url.substring(0, i);\r\n        }\r\n        i = url.indexOf(AT);\r\n        if (i != -1) {\r\n            result.userInfo = url.substring(0, i) || undefined;\r\n            url = url.substring(i + 1);\r\n        }\r\n        i = url.indexOf(':');\r\n        if (i != -1) {\r\n            var port = parseInt(Utility_1.trim(url.substring(i + 1)));\r\n            if (isNaN(port))\r\n                return new ArgumentException_1.default('url', 'Port was invalid.');\r\n            result.port = port;\r\n            url = url.substring(0, i);\r\n        }\r\n        url = Utility_1.trim(url);\r\n        if (url)\r\n            result.host = url;\r\n        out(copyUri(result));\r\n        return null;\r\n    }\r\n});\r\n//# sourceMappingURL=Uri.js.map","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on: https://en.wikipedia.org/wiki/Uniform_Resource_Identifier\r\n */\r\n\r\n///<reference path=\"IUri.d.ts\"/>\r\n///<reference path=\"../IEquatable.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport Type from '../Types';\r\nimport * as QueryParams from '../Uri/QueryParams';\r\nimport {trim} from '../Text/Utility';\r\nimport UriScheme from '../Uri/Scheme';\r\nimport Exception from '../Exception';\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\n/**\r\n * Provides an read-only model representation of a uniform resource identifier (URI) and easy access to the parts of the URI.\r\n *\r\n * The read-only model (frozen) is easier for debugging than exposing accessors for each property.\r\n * ICloneable&lt;Uri&gt; is not used to prevent unnecessary copying of values that won't change.\r\n */\r\nexport default class Uri implements IUri, IEquatable<IUri>\r\n{\r\n\r\n\tscheme:SchemeValue;\r\n\tuserInfo:string;\r\n\thost:string;\r\n\tport:number;\r\n\tpath:string;\r\n\tquery:string;\r\n\tfragment:string;\r\n\r\n\tqueryParams:IMap<Primitive|Primitive[]>;\r\n\r\n\t/**\r\n\t * @param scheme The user name, password, or other user-specific information associated with the specified URI.\r\n\t * @param userInfo The host component of this instance.\r\n\t * @param host The port number of this URI.\r\n\t * @param port The absolute path of the URI.\r\n\t * @param path The absolute path of the URI.\r\n\t * @param query Any query information included in the specified URI.\r\n\t * @param fragment The escaped URI fragment.\r\n\t */\r\n\tconstructor(\r\n\t\tscheme:UriScheme|SchemeValue,\r\n\t\tuserInfo:string,\r\n\t\thost:string,\r\n\t\tport:number,\r\n\t\tpath:string,\r\n\t\tquery?:QueryParamsConvertible,\r\n\t\tfragment?:string)\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.scheme = getScheme(scheme) || null;\r\n\t\t_.userInfo = userInfo || null;\r\n\t\t_.host = host || null;\r\n\t\t_.port = port || null;\r\n\r\n\t\t_.authority = _.getAuthority() || null;\r\n\r\n\t\t_.path = path || null;\r\n\r\n\r\n\t\tif(!Type.isString(query))\r\n\t\t\tquery = QueryParams.encode(<IUriComponentMap|StringKeyValuePair<Primitive>[]>query);\r\n\r\n\t\t_.query = formatQuery(<string>query) || null;\r\n\t\tObject.freeze(_.queryParams\r\n\t\t\t= _.query\r\n\t\t\t? QueryParams.parseToMap(_.query)\r\n\t\t\t: {});\r\n\r\n\t\t_.pathAndQuery = _.getPathAndQuery() || null;\r\n\r\n\t\t_.fragment = formatFragment(fragment) || null;\r\n\r\n\t\t// This should validate the uri...\r\n\t\t_.absoluteUri = _.getAbsoluteUri();\r\n\r\n\t\t// Intended to be read-only.  Call .toMap() to get a writable copy.\r\n\t\tObject.freeze(_);\r\n\t}\r\n\r\n\t/**\r\n\t *  Compares the values of another IUri via toString comparison.\r\n\t * @param other\r\n\t * @returns {boolean}\r\n\t */\r\n\tequals(other:IUri):boolean\r\n\t{\r\n\t\treturn this===other || this.absoluteUri==Uri.toString(other);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Parses or clones values from existing Uri values.\r\n\t * @param uri\r\n\t * @param defaults\r\n\t * @returns {Uri}\r\n\t */\r\n\tstatic from(uri:string|IUri, defaults?:IUri):Uri\r\n\t{\r\n\t\tvar u = (!uri || Type.isString(uri))\r\n\t\t\t? Uri.parse(<string>uri) : <IUri>uri;\r\n\r\n\t\treturn new Uri(\r\n\t\t\tu.scheme || defaults && defaults.scheme,\r\n\t\t\tu.userInfo || defaults && defaults.userInfo,\r\n\t\t\tu.host || defaults && defaults.host,\r\n\t\t\tisNaN(u.port) ? defaults && defaults.port : u.port,\r\n\t\t\tu.path || defaults && defaults.path,\r\n\t\t\tu.query || defaults && defaults.query,\r\n\t\t\tu.fragment || defaults && defaults.fragment\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param throwIfInvalid Defaults to true.\r\n\t * @returns {IUri} Returns a map of the values or *null* if invalid and *throwIfInvalid* is <b>false</b>.\r\n\t */\r\n\tstatic parse(url:string, throwIfInvalid:boolean = true):IUri\r\n\t{\r\n\t\tvar result:IUri = null;\r\n\t\tvar ex = tryParse(url, (out)=> {result = out;});\r\n\t\tif(throwIfInvalid && ex) throw ex;\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a URL into it's components.\r\n\t * @param url The url to parse.\r\n\t * @param out A delegate to capture the value.\r\n\t * @returns {boolean} True if valid.  False if invalid.\r\n\t */\r\n\tstatic tryParse(url:string, out:(result:IUri)=>void):boolean\r\n\t{\r\n\t\treturn !tryParse(url, out); // return type is Exception.\r\n\t}\r\n\r\n\tstatic copyOf(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(map);\r\n\t}\r\n\r\n\tcopyTo(map:IUri):IUri\r\n\t{\r\n\t\treturn copyUri(this, map);\r\n\t}\r\n\r\n\tupdateQuery(query:QueryParamsConvertible):Uri\r\n\t{\r\n\t\tvar map = this.toMap();\r\n\t\tmap.query = <any>query;\r\n\t\treturn Uri.from(map);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAbsoluteUri():string\r\n\t{\r\n\t\treturn uriToString(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getAuthority():string\r\n\t{\r\n\t\treturn getAuthority(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Is provided for sub classes to override this value.\r\n\t */\r\n\tprotected getPathAndQuery():string\r\n\t{\r\n\t\treturn getPathAndQuery(this);\r\n\t}\r\n\r\n\t/**\r\n\t * The absolute URI.\r\n\t */\r\n\tabsoluteUri:string;\r\n\r\n\t/**\r\n\t * Gets the Domain Name System (DNS) host name or IP address and the port number for a server.\r\n\t */\r\n\tauthority:string;\r\n\r\n\t/**\r\n\t * Gets the path and Query properties separated by a question mark (?).\r\n\t */\r\n\tpathAndQuery:string;\r\n\r\n\t/**\r\n\t * The segments that represent a path.<br/>\r\n\t * https://msdn.microsoft.com/en-us/library/system.uri.segments%28v=vs.110%29.aspx\r\n\t *\r\n\t * <h5><b>Example:</b></h5>\r\n\t * If the path value equals: ```/tree/node/index.html```<br/>\r\n\t * The result will be: ```['/','tree/','node/','index.html']```\r\n\t * @returns {string[]}\r\n\t */\r\n\tget pathSegments():string[]\r\n\t{\r\n\t\treturn this.path.match(/^[/]|[^/]*[/]|[^/]+$/g);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a writable copy.\r\n\t * @returns {IUri}\r\n\t */\r\n\ttoMap():IUri\r\n\t{\r\n\t\treturn this.copyTo({});\r\n\t}\r\n\r\n\t/**\r\n\t * @returns {string} The full absolute uri.\r\n\t */\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.absoluteUri;\r\n\t}\r\n\r\n\t/**\r\n\t * Properly converts an existing URI to a string.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic toString(uri:IUri):string\r\n\t{\r\n\t\treturn uri instanceof Uri\r\n\t\t\t? (<Uri>uri).absoluteUri\r\n\t\t\t: uriToString(uri);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the authority segment of an URI.\r\n\t * @param uri\r\n\t * @returns {string}\r\n\t */\r\n\tstatic getAuthority(uri:IUri):string\r\n\t{\r\n\t\treturn getAuthority(uri);\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport enum Fields {\r\n\tscheme,\r\n\tuserInfo,\r\n\thost,\r\n\tport,\r\n\tpath,\r\n\tquery,\r\n\tfragment\r\n}\r\nObject.freeze(Fields);\r\n\r\nfunction copyUri(from:IUri, to?:IUri)\r\n{\r\n\tvar i = 0, field:string;\r\n\tif(!to) to = {};\r\n\twhile(field = Fields[i++])\r\n\t{\r\n\t\tvar value = (<any>from)[field];\r\n\t\tif(value) (<any>to)[field] = value;\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nconst SLASH = '/', SLASH2 = '//', QM = '?', HASH = '#', EMPTY = '', AT = '@';\r\n\r\nfunction getScheme(scheme:UriScheme|string):SchemeValue\r\n{\r\n\tvar s:any = scheme;\r\n\tif(Type.isString(s))\r\n\t{\r\n\t\tif(!s) return undefined;\r\n\r\n\t\ts = UriScheme[<any>trim(s).toLowerCase().replace(/[^a-z0-9+.-]+$/g, EMPTY)];\r\n\r\n\t\tif(isNaN(s))\r\n\t\t\tthrow new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n\t}\r\n\r\n\tif(Type.isNumber(s, false))\r\n\t{\r\n\t\ts = UriScheme[<number>s];\r\n\t\tif(!s)\r\n\t\t\tthrow new ArgumentOutOfRangeException('scheme', scheme, 'Invalid scheme.');\r\n\r\n\t\treturn s;\r\n\t}\r\n\r\n\treturn undefined;\r\n}\r\n\r\nfunction getAuthority(uri:IUri):string\r\n{\r\n\r\n\tif(!uri.host)\r\n\t{\r\n\t\tif(uri.userInfo)\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include user info when there is no host.');\r\n\r\n\t\tif(Type.isNumber(uri.port, false))\r\n\t\t\tthrow new ArgumentException('host', 'Cannot include a port when there is no host.');\r\n\t}\r\n\r\n\t/*\r\n\t * [//[user:password@]host[:port]]\r\n\t */\r\n\r\n\tvar result = uri.host || EMPTY;\r\n\r\n\tif(result)\r\n\t{\r\n\t\tif(uri.userInfo) result = uri.userInfo + AT + result;\r\n\t\tif(!isNaN(uri.port)) result += ':' + uri.port;\r\n\t\tresult = SLASH2 + result;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nfunction formatQuery(query:string):string\r\n{\r\n\treturn query && ((query.indexOf(QM)== -1 ? QM : EMPTY) + query);\r\n}\r\n\r\nfunction formatFragment(fragment:string):string\r\n{\r\n\treturn fragment && ((fragment.indexOf(HASH)== -1 ? HASH : EMPTY) + fragment);\r\n}\r\n\r\nfunction getPathAndQuery(uri:IUri):string\r\n{\r\n\r\n\tvar path = uri.path,\r\n\t\tquery = uri.query;\r\n\r\n\treturn EMPTY\r\n\t\t+ (path && ((path.indexOf(SLASH)== -1 ? SLASH : EMPTY) + path) || EMPTY)\r\n\t\t+ (formatQuery(query) || EMPTY);\r\n\r\n}\r\n\r\nfunction uriToString(uri:IUri):string\r\n{\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\t// {scheme}{authority}{path}{query}{fragment}\r\n\r\n\tvar scheme = getScheme(uri.scheme),\r\n\t\tauthority = getAuthority(uri),\r\n\t\tpathAndQuery = getPathAndQuery(uri),\r\n\t\tfragment = formatFragment(uri.fragment);\r\n\r\n\treturn EMPTY\r\n\t\t+ ((scheme && (scheme + ':')) || EMPTY)\r\n\t\t+ (authority || EMPTY)\r\n\t\t+ (pathAndQuery || EMPTY)\r\n\t\t+ (fragment || EMPTY)\r\n\r\n}\r\n\r\n\r\nfunction tryParse(url:string, out:(result:IUri)=>void):Exception\r\n{\r\n\tif(!url)\r\n\t\treturn new ArgumentException('url', 'Nothing to parse.');\r\n\r\n\r\n\t// Could use a regex here, but well follow some rules instead.\r\n\t// The intention is to 'gather' the pieces.  This isn't validation (yet).\r\n\r\n\t// scheme:[//[user:password@]domain[:port]][/]path[?query][#fragment]\r\n\tvar i:number, result:IUri = {};\r\n\r\n\t// Anything after the first # is the fragment.\r\n\ti = url.indexOf(HASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.fragment = url.substring(i);\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Anything after the first ? is the query.\r\n\ti = url.indexOf(QM);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.query = url.substring(i);\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Guarantees a separation.\r\n\ti = url.indexOf(SLASH2);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tvar scheme = trim(url.substring(0, i)), c = /:$/;\r\n\t\tif(!c.test(scheme))\r\n\t\t\treturn new ArgumentException('url', 'Scheme was improperly formatted');\r\n\r\n\t\tscheme = trim(scheme.replace(c, EMPTY));\r\n\t\ttry\r\n\t\t{\r\n\t\t\tresult.scheme = getScheme(scheme) || undefined;\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn ex;\r\n\t\t}\r\n\r\n\t\turl = url.substring(i + 2);\r\n\t}\r\n\r\n\t// Find any path information.\r\n\ti = url.indexOf(SLASH);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.path = url.substring(i) || undefined;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\t// Separate user info.\r\n\ti = url.indexOf(AT);\r\n\tif(i!= -1)\r\n\t{\r\n\t\tresult.userInfo = url.substring(0, i) || undefined;\r\n\t\turl = url.substring(i + 1);\r\n\t}\r\n\r\n\t// Remaining is host and port.\r\n\ti = url.indexOf(':');\r\n\tif(i!= -1)\r\n\t{\r\n\t\tvar port = parseInt(trim(url.substring(i + 1)));\r\n\t\tif(isNaN(port))\r\n\t\t\treturn new ArgumentException('url', 'Port was invalid.');\r\n\r\n\t\tresult.port = port;\r\n\t\turl = url.substring(0, i);\r\n\t}\r\n\r\n\turl = trim(url);\r\n\tif(url)\r\n\t\tresult.host = url;\r\n\r\n\tout(copyUri(result));\r\n\r\n\t// null is good! (here)\r\n\treturn null;\r\n\r\n}\r\n"]}