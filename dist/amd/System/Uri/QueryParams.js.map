{"version":3,"sources":["System/Uri/QueryParams.ts","System/Uri/QueryParams.js"],"names":["define","require","exports","Types_1","Serialization","KeyValueExtract_1","encode","values","prefixIfNotEmpty","encodeValue","value","isUriComponentFormattable","instance","parse","query","entryHandler","deserialize","decodeValues","parseToMap","parseToArray","ENTRY_SEPARATOR","KEY_VALUE_SEPARATOR","Separator","Object","freeze"],"mappings":";;;AAOA,YCHAA,SAAQ,UAAW,UAAW,WAAY,2BAA4B,sBAAuB,SAAUC,EAASC,EAASC,EAASC,EAAeC,GDqBjJ,QAAAC,GACCC,EACAC,GAEAF,IAAIA,EAAQA,MAAOA,EACnBA,IAAIA,EAiBJA,OAbCA,GAFEA,MAAMA,QAAQA,GAENA,EAAOA,IAChBA,SAAAA,GAAKA,MAAAA,GAAAA,WAAgBA,EACpBA,SAACA,EAAKA,GAAQA,MAAAA,GAAMA,EAAsBA,EAAYA,OAM9CA,OAAOA,KAAKA,GAAQA,IAC7BA,SAAAA,GAAMA,MAAAA,GAAMA,EAAsBA,EAAkBA,EAAQA,OAItDA,EAAQA,QAAUA,EAAmBA,IAAMA,IAChDA,EAAQA,KAAKA,GAQjB,QAAAG,GAA4BC,GAE3BD,GAAIA,GAAWA,IACfA,IAAGA,EAA0BA,IAG5BA,GADAA,EAAIA,EAAMA,iBACPA,GAAqBA,GAAhBA,EAAEA,QAAQA,KACjBA,KAAMA,kDAIPA,GAAIA,mBAAmBA,EAAcA,SAASA,GAE/CA,OAAOA,GAQR,QAAAE,GAA0CC,GAEzCD,MAAOA,GAAAA,WAAKA,gBAA0CA,EAAUA,iBAAkBA,EAAAA,WAAKA,UAUxF,QAAAE,GACCC,EACAC,EACAC,EACAC,GAEAJ,GAHAA,SAAAA,IAAAA,GAAAA,GACAA,SAAAA,IAAAA,GAAAA,GAEGA,IAAUA,EAAQA,EAAMA,QAAQA,UAAWA,KAG7CA,IAAiBA,GADbA,GAAUA,EAAMA,MAAMA,GACTA,EAAAA,EAAbA,EAAAA,EAAAA,OAAAA,IAAqBA,CAArBA,GAAIA,GAASA,EAAOA,GAMnBA,EAAKA,EAAMA,QAAQA,EACvBA,IAAQA,IAALA,EACHA,CACCA,GAAIA,GAAMA,EAAMA,UAAUA,EAAGA,GACzBA,EAAaA,EAAMA,UAAUA,EAAKA,EACnCA,KAAcA,EAAQA,mBAAmBA,IACzCA,IAAaA,EAAQA,EAAcA,YAAYA,IAClDA,EAAaA,EAAKA,KAatB,QAAAK,GACCJ,EACAE,EACAC,GADAC,SAAAA,IAAAA,GAAAA,GACAA,SAAAA,IAAAA,GAAAA,EAEAA,IAAIA,KAgBJA,OAfAA,GAAMA,EACLA,SAACA,EAAKA,GAELA,GAAGA,IAAOA,GACVA,CACCA,GAAIA,GAAWA,EAAOA,EACjBA,OAAMA,QAAQA,KAClBA,EAAOA,GAAOA,GAAQA,IACvBA,EAAKA,KAAKA,OAGVA,GAAOA,GAAOA,GAEhBA,EACAA,GACMA,EAUR,QAAAC,GACCL,EACAE,EACAC,GADAE,SAAAA,IAAAA,GAAAA,GACAA,SAAAA,IAAAA,GAAAA,EAEAA,IAAIA,KAMJA,OALAA,GAAMA,EACLA,SAACA,EAAKA,GAAUA,EAAOA,MAAMA,IAAKA,EAAKA,MAAOA,KAC9CA,EACAA,GAEMA,EApJR,GACCC,GAAsB,IACtBC,EAAsB,GAKPnB,GAAAI,OAAMA,EA+BNJ,EAAAO,YAAWA,EAqBXP,EAAAS,0BAAyBA,EAYzBT,EAAAW,MAAKA,EAmCLX,EAAAgB,WAAUA,EA+BVhB,EAAAiB,aAAYA,CAe5B,IAAcG,IAAd,SAAcA,GAEAA,EAAAA,MAAeA,EACfA,EAAAA,SAAkBA,GAHlBA,EAAApB,EAAAoB,YAAApB,EAAAoB,eAKdC,OAAOC,OAAOF","file":"System/Uri/QueryParams.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n///<reference path=\"IUriComponentFormattable.d.ts\"/>\r\n///<reference path=\"../Collections/Dictionaries/IDictionary.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport Type from '../Types';\r\nimport * as Serialization from '../Serialization/Utility';\r\nimport extractKeyValue from '../KeyValueExtract';\r\n\r\n/*\r\n * This module is provided as a lighter weight utility for acquiring query params.\r\n * If more detailed operations are necessary, consider importing QueryBuilder.\r\n */\r\n\r\nconst\r\n\tENTRY_SEPARATOR     = \"&\",\r\n\tKEY_VALUE_SEPARATOR = \"=\";\r\n\r\n/**\r\n * Returns the encoded URI string\r\n */\r\nexport function encode(\r\n\tvalues:IUriComponentMap|StringKeyValuePair<Primitive>[],\r\n\tprefixIfNotEmpty?:boolean):string\r\n{\r\n\tif(!values) return '';\r\n\tvar entries:string[];\r\n\r\n\tif(Array.isArray(values))\r\n\t{\r\n\t\tentries = values.map(\r\n\t\t\tkvp=>extractKeyValue(kvp,\r\n\t\t\t\t(key, value)=>key + KEY_VALUE_SEPARATOR + encodeValue(value)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tentries = Object.keys(values).map(\r\n\t\t\tkey=> key + KEY_VALUE_SEPARATOR + encodeValue((<any>values)[key])\r\n\t\t);\r\n\t}\r\n\r\n\treturn (entries.length && prefixIfNotEmpty ? '?' : '')\r\n\t\t+ entries.join(ENTRY_SEPARATOR);\r\n}\r\n\r\n/**\r\n * Converts any primitive, serializable or uri-component object to an encoded string.\r\n * @param value\r\n * @returns {string}\r\n */\r\nexport function encodeValue(value:Primitive|ISerializable|IUriComponentFormattable):string\r\n{\r\n\tvar v:string = null;\r\n\tif(isUriComponentFormattable(value))\r\n\t{\r\n\t\tv = value.toUriComponent();\r\n\t\tif(v && v.indexOf('&')!=1)\r\n\t\t\tthrow '.toUriComponent() did not encode the value.';\r\n\t}\r\n\telse\r\n\t{\r\n\t\tv = encodeURIComponent(Serialization.toString(v));\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n/**\r\n * A shortcut for identifying an IUriComponentFormattable object.\r\n * @param instance\r\n * @returns {boolean}\r\n */\r\nexport function isUriComponentFormattable(instance:any):instance is IUriComponentFormattable\r\n{\r\n\treturn Type.hasMemberOfType<IUriComponentFormattable>(instance, \"toUriComponent\", Type.FUNCTION);\r\n}\r\n\r\n/**\r\n * Parses a string for valid query param entries and pipes them through a handler.\r\n * @param query\r\n * @param entryHandler\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n */\r\nexport function parse(\r\n\tquery:string,\r\n\tentryHandler:(key:string, value:Primitive)=>void,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):void\r\n{\r\n\tif(query && (query = query.replace(/^\\s*\\?+/, '')))\r\n\t{\r\n\t\tvar entries = query.split(ENTRY_SEPARATOR);\r\n\t\tfor(let entry of entries)\r\n\t\t{\r\n\t\t\t/*\r\n\t\t\t * Since it is technically possible to have multiple '=' we need to identify the first one.\r\n\t\t\t * And if there is no '=' then the entry is ignored.\r\n\t\t\t */\r\n\t\t\tvar si = entry.indexOf(KEY_VALUE_SEPARATOR);\r\n\t\t\tif(si!= -1)\r\n\t\t\t{\r\n\t\t\t\tvar key = entry.substring(0, si);\r\n\t\t\t\tvar value = <any>entry.substring(si + 1);\r\n\t\t\t\tif(decodeValues) value = decodeURIComponent(value);\r\n\t\t\t\tif(deserialize) value = Serialization.toPrimitive(value);\r\n\t\t\t\tentryHandler(key, value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value map of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IMap<Primitive>}\r\n */\r\nexport function parseToMap(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IMap<Primitive|Primitive[]>\r\n{\r\n\tvar result:IMap<Primitive|Primitive[]> = {};\r\n\tparse(query,\r\n\t\t(key, value)=>\r\n\t\t{\r\n\t\t\tif((key)in(result))\r\n\t\t\t{\r\n\t\t\t\tvar prev:any = result[key];\r\n\t\t\t\tif(!(Array.isArray(prev)))\r\n\t\t\t\t\tresult[key] = prev = [prev];\r\n\t\t\t\tprev.push(value);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tresult[key] = value;\r\n\t\t},\r\n\t\tdeserialize,\r\n\t\tdecodeValues);\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Parses a string for valid query params and returns a key-value pair array of the entries.\r\n * @param query\r\n * @param deserialize Default is true.\r\n * @param decodeValues Default is true.\r\n * @returns {IKeyValuePair<string, Primitive>[]}\r\n */\r\nexport function parseToArray(\r\n\tquery:string,\r\n\tdeserialize:boolean = true,\r\n\tdecodeValues:boolean = true):IStringKeyValuePair<Primitive>[]\r\n{\r\n\tvar result:IStringKeyValuePair<Primitive>[] = [];\r\n\tparse(query,\r\n\t\t(key, value)=> {result.push({key: key, value: value});},\r\n\t\tdeserialize,\r\n\t\tdecodeValues\r\n\t);\r\n\treturn result;\r\n}\r\n\r\n\r\nexport module Separator\r\n{\r\n\texport const Entry:string = ENTRY_SEPARATOR;\r\n\texport const KeyValue:string = KEY_VALUE_SEPARATOR;\r\n}\r\nObject.freeze(Separator);\r\n\r\n","///<reference path=\"IUriComponentFormattable.d.ts\"/>\r\n///<reference path=\"../Collections/Dictionaries/IDictionary.d.ts\"/>\r\n///<reference path=\"../Primitive.d.ts\"/>\r\n'use strict';\r\n(function (deps, factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define(deps, factory);\r\n    }\r\n})([\"require\", \"exports\", '../Types', '../Serialization/Utility', '../KeyValueExtract'], function (require, exports) {\r\n    var Types_1 = require('../Types');\r\n    var Serialization = require('../Serialization/Utility');\r\n    var KeyValueExtract_1 = require('../KeyValueExtract');\r\n    var ENTRY_SEPARATOR = \"&\", KEY_VALUE_SEPARATOR = \"=\";\r\n    function encode(values, prefixIfNotEmpty) {\r\n        if (!values)\r\n            return '';\r\n        var entries;\r\n        if (Array.isArray(values)) {\r\n            entries = values.map(function (kvp) { return KeyValueExtract_1.default(kvp, function (key, value) { return key + KEY_VALUE_SEPARATOR + encodeValue(value); }); });\r\n        }\r\n        else {\r\n            entries = Object.keys(values).map(function (key) { return key + KEY_VALUE_SEPARATOR + encodeValue(values[key]); });\r\n        }\r\n        return (entries.length && prefixIfNotEmpty ? '?' : '')\r\n            + entries.join(ENTRY_SEPARATOR);\r\n    }\r\n    exports.encode = encode;\r\n    function encodeValue(value) {\r\n        var v = null;\r\n        if (isUriComponentFormattable(value)) {\r\n            v = value.toUriComponent();\r\n            if (v && v.indexOf('&') != 1)\r\n                throw '.toUriComponent() did not encode the value.';\r\n        }\r\n        else {\r\n            v = encodeURIComponent(Serialization.toString(v));\r\n        }\r\n        return v;\r\n    }\r\n    exports.encodeValue = encodeValue;\r\n    function isUriComponentFormattable(instance) {\r\n        return Types_1.default.hasMemberOfType(instance, \"toUriComponent\", Types_1.default.FUNCTION);\r\n    }\r\n    exports.isUriComponentFormattable = isUriComponentFormattable;\r\n    function parse(query, entryHandler, deserialize, decodeValues) {\r\n        if (deserialize === void 0) { deserialize = true; }\r\n        if (decodeValues === void 0) { decodeValues = true; }\r\n        if (query && (query = query.replace(/^\\s*\\?+/, ''))) {\r\n            var entries = query.split(ENTRY_SEPARATOR);\r\n            for (var _i = 0; _i < entries.length; _i++) {\r\n                var entry = entries[_i];\r\n                var si = entry.indexOf(KEY_VALUE_SEPARATOR);\r\n                if (si != -1) {\r\n                    var key = entry.substring(0, si);\r\n                    var value = entry.substring(si + 1);\r\n                    if (decodeValues)\r\n                        value = decodeURIComponent(value);\r\n                    if (deserialize)\r\n                        value = Serialization.toPrimitive(value);\r\n                    entryHandler(key, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    exports.parse = parse;\r\n    function parseToMap(query, deserialize, decodeValues) {\r\n        if (deserialize === void 0) { deserialize = true; }\r\n        if (decodeValues === void 0) { decodeValues = true; }\r\n        var result = {};\r\n        parse(query, function (key, value) {\r\n            if ((key) in (result)) {\r\n                var prev = result[key];\r\n                if (!(Array.isArray(prev)))\r\n                    result[key] = prev = [prev];\r\n                prev.push(value);\r\n            }\r\n            else\r\n                result[key] = value;\r\n        }, deserialize, decodeValues);\r\n        return result;\r\n    }\r\n    exports.parseToMap = parseToMap;\r\n    function parseToArray(query, deserialize, decodeValues) {\r\n        if (deserialize === void 0) { deserialize = true; }\r\n        if (decodeValues === void 0) { decodeValues = true; }\r\n        var result = [];\r\n        parse(query, function (key, value) { result.push({ key: key, value: value }); }, deserialize, decodeValues);\r\n        return result;\r\n    }\r\n    exports.parseToArray = parseToArray;\r\n    var Separator;\r\n    (function (Separator) {\r\n        Separator.Entry = ENTRY_SEPARATOR;\r\n        Separator.KeyValue = KEY_VALUE_SEPARATOR;\r\n    })(Separator = exports.Separator || (exports.Separator = {}));\r\n    Object.freeze(Separator);\r\n});\r\n//# sourceMappingURL=QueryParams.js.map"]}