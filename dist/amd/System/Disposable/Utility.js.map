{"version":3,"sources":["System/Disposable/Utility.js","System/Disposable/Utility.ts"],"names":["define","require","exports","Types_1","dispose","disposables","_i","arguments","length","disposeTheseInternal","disposeWithoutException","disposeThese","trapExceptions","slice","using","disposable","closure","disposeSingle","of","member","isFunction","ex","index","exceptions","len","next","push","success"],"mappings":";;;;AAIAA,QAAQ,UAAW,UAAW,YAAa,SAAUC,EAASC,EAASC,GCGvE,YAUA,SAAAC,KDTQ,ICSgB,GAAAC,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,EAGvBG,GAAqBJ,GAAa,GAUnC,QAAAK,KDdQ,ICcgC,GAAAL,MAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,EAAA,GAAAC,UAAAD,EAGvC,OAAOG,GAAqBJ,GAAa,GAS1C,QAAAM,GAA6BN,EAA2BO,GAEvD,MAAOP,IAAeA,EAAYG,OAC/BC,EAAqBJ,EAAYQ,QAASD,GAC1C,KAkBJ,QAAAE,GACCC,EACAC,GAEA,IAEC,MAAOA,GAAQD,GDtCT,QC0CNE,EAAcF,GAAY,IAS5B,QAAAE,GACCF,EACAH,GAEA,GAAGT,EAAAA,WAAKe,GAAGH,GAAYI,OAAO,WAAWC,WAExC,GAAGR,EAEF,IAECG,EAAWX,UAEZ,MAAMiB,GAEL,MAAOA,OAIRN,GAAWX,SAGb,OAAO,MAMR,QAAAK,GACCJ,EACAO,EACAU,GAAA,SAAAA,IAAAA,EAAA,EAKA,KAHA,GAAIC,GACAC,EAAMnB,EAAYG,OAEVgB,EAANF,EAAWA,IACjB,CACC,GAAIG,GAAOpB,EAAYiB,EACvB,IAAIG,EACJ,GAAGb,EACH,CACC,GAAIS,GAAKJ,EAAcQ,GAAM,EAC1BJ,KAEEE,IAAYA,MAChBA,EAAWG,KAAKL,QAIlB,CACC,GAAIM,IAAU,CACd,KAECV,EAAcQ,GAAM,GACpBE,GAAU,ED/DE,SCoERA,GAAqBH,EAAVF,EAAQ,GAItBb,EAAqBJ,GAAa,EAAOiB,EAAQ,GAInD,IAAIK,EAAS,OAIf,MAAOJ,GAzIQrB,EAAAE,QAAOA,EAaPF,EAAAQ,wBAAuBA,EAYvBR,EAAAS,aAAYA,EAsBZT,EAAAY,MAAKA","file":"System/Disposable/Utility.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n(function (factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define([\"require\", \"exports\", '../Types'], factory);\r\n    }\r\n})(function (require, exports) {\r\n    'use strict';\r\n    var Types_1 = require('../Types');\r\n    function dispose() {\r\n        var disposables = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            disposables[_i - 0] = arguments[_i];\r\n        }\r\n        disposeTheseInternal(disposables, false);\r\n    }\r\n    exports.dispose = dispose;\r\n    function disposeWithoutException() {\r\n        var disposables = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            disposables[_i - 0] = arguments[_i];\r\n        }\r\n        return disposeTheseInternal(disposables, true);\r\n    }\r\n    exports.disposeWithoutException = disposeWithoutException;\r\n    function disposeThese(disposables, trapExceptions) {\r\n        return disposables && disposables.length\r\n            ? disposeTheseInternal(disposables.slice(), trapExceptions)\r\n            : null;\r\n    }\r\n    exports.disposeThese = disposeThese;\r\n    function using(disposable, closure) {\r\n        try {\r\n            return closure(disposable);\r\n        }\r\n        finally {\r\n            disposeSingle(disposable, false);\r\n        }\r\n    }\r\n    exports.using = using;\r\n    function disposeSingle(disposable, trapExceptions) {\r\n        if (Types_1.default.of(disposable).member('dispose').isFunction) {\r\n            if (trapExceptions) {\r\n                try {\r\n                    disposable.dispose();\r\n                }\r\n                catch (ex) {\r\n                    return ex;\r\n                }\r\n            }\r\n            else\r\n                disposable.dispose();\r\n        }\r\n        return null;\r\n    }\r\n    function disposeTheseInternal(disposables, trapExceptions, index) {\r\n        if (index === void 0) { index = 0; }\r\n        var exceptions;\r\n        var len = disposables.length;\r\n        for (; index < len; index++) {\r\n            var next = disposables[index];\r\n            if (!next)\r\n                continue;\r\n            if (trapExceptions) {\r\n                var ex = disposeSingle(next, true);\r\n                if (ex) {\r\n                    if (!exceptions)\r\n                        exceptions = [];\r\n                    exceptions.push(ex);\r\n                }\r\n            }\r\n            else {\r\n                var success = false;\r\n                try {\r\n                    disposeSingle(next, false);\r\n                    success = true;\r\n                }\r\n                finally {\r\n                    if (!success && index + 1 < len) {\r\n                        disposeTheseInternal(disposables, false, index + 1);\r\n                    }\r\n                }\r\n                if (!success)\r\n                    break;\r\n            }\r\n        }\r\n        return exceptions;\r\n    }\r\n});\r\n//# sourceMappingURL=Utility.js.map","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDisposable.d.ts\"/>\r\n///<reference path=\"../Collections/Array/IArray.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport Type from '../Types';\r\n\r\n/**\r\n * Takes any number of disposables as arguments and attempts to dispose them.\r\n * Any exceptions thrown within a dispose are not trapped.\r\n * Use 'disposeWithoutException' to automatically trap exceptions.\r\n * @param disposables\r\n */\r\nexport function dispose(...disposables:IDisposable[]):void\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\tdisposeTheseInternal(disposables, false);\r\n}\r\n\r\n\r\n/**\r\n * Takes any number of disposables and traps any errors that occur when disposing.\r\n * Returns an array of the exceptions thrown.\r\n * @param disposables\r\n * @returns {any[]} Returns an array of exceptions that occurred, if there are any.\r\n */\r\nexport function disposeWithoutException(...disposables:IDisposable[]):any[]\r\n{\r\n\t// The disposables arguments array is effectively localized so it's safe.\r\n\treturn disposeTheseInternal(disposables, true);\r\n}\r\n\r\n/**\r\n * Takes an array of disposable objects and ensures they are disposed.\r\n * @param disposables\r\n * @param trapExceptions If true, prevents exceptions from being thrown when disposing.\r\n * @returns {any[]} If 'trapExceptions' is true, returns an array of exceptions that occurred, if there are any.\r\n */\r\nexport function disposeThese(disposables:IDisposable[], trapExceptions?:boolean):any[]\r\n{\r\n\treturn disposables && disposables.length\r\n\t\t? disposeTheseInternal(disposables.slice(), trapExceptions)\r\n\t\t: null;\r\n}\r\n\r\n/**\r\n * Just like in C# this 'using' function will ensure the passed disposable is disposed when the closure has finished.\r\n *\r\n * Usage:\r\n * ```typescript\r\n * using(new DisposableObject(),(myObj)=>{\r\n *   // do work with myObj\r\n * });\r\n * // myObj automatically has it's dispose method called.\r\n * ```\r\n *\r\n * @param disposable Object to be disposed.\r\n * @param closure Function call to execute.\r\n * @returns {TReturn} Returns whatever the closure's return value is.\r\n */\r\nexport function using<TDisposable extends IDisposable,TReturn>(\r\n\tdisposable:TDisposable,\r\n\tclosure:(disposable:TDisposable) => TReturn):TReturn\r\n{\r\n\ttry\r\n\t{\r\n\t\treturn closure(disposable);\r\n\t}\r\n\tfinally\r\n\t{\r\n\t\tdisposeSingle(disposable, false);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This private function makes disposing more robust for when there's no type checking.\r\n * If trapExceptions is 'true' it catches and returns any exception instead of throwing.\r\n */\r\nfunction disposeSingle(\r\n\tdisposable:IDisposable,\r\n\ttrapExceptions:boolean):any\r\n{\r\n\tif(Type.of(disposable).member('dispose').isFunction)\r\n\t{\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposable.dispose();\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\treturn ex;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tdisposable.dispose();\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * This dispose method assumes it's working on a local copy and is unsafe for external use.\r\n */\r\nfunction disposeTheseInternal(\r\n\tdisposables:IDisposable[],\r\n\ttrapExceptions:boolean,\r\n\tindex:number = 0):any[]\r\n{\r\n\tvar exceptions:any[];\r\n\tvar len = disposables.length;\r\n\r\n\tfor(; index<len; index++)\r\n\t{\r\n\t\tvar next = disposables[index];\r\n\t\tif(!next) continue;\r\n\t\tif(trapExceptions)\r\n\t\t{\r\n\t\t\tvar ex = disposeSingle(next, true);\r\n\t\t\tif(ex)\r\n\t\t\t{\r\n\t\t\t\tif(!exceptions) exceptions = [];\r\n\t\t\t\texceptions.push(ex);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar success = false;\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdisposeSingle(next, false);\r\n\t\t\t\tsuccess = true;\r\n\t\t\t}\r\n\t\t\t\t// Don't trap the exception in order to allow it to propagate the stack trace.\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tif(!success && index + 1<len)\r\n\t\t\t\t{\r\n\t\t\t\t\t/* If code is 'continued' by the debugger,\r\n\t\t\t\t\t * need to ensure the rest of the disposables are cared for. */\r\n\t\t\t\t\tdisposeTheseInternal(disposables, false, index + 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Just in case...  Should never happen, but asserts the intention.\r\n\t\t\tif(!success) break;\r\n\t\t}\r\n\t}\r\n\r\n\treturn exceptions;\r\n}\r\n"]}