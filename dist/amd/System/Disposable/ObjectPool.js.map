{"version":3,"sources":["System/Disposable/ObjectPool.js","System/Disposable/ObjectPool.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","define","require","exports","dispose_1","DisposableBase_1","TaskHandler_1","ArgumentOutOfRangeException_1","OBJECT_POOL","_MAX_SIZE","ABSOLUTE_MAX_SIZE","MUST_BE_GT1","MUST_BE_LTM","ObjectPool","_super","_maxSize","_generator","call","autoClearTimeout","isNaN","_localAbsMaxSize","Math","min","_","_disposableObjectName","_pool","_trimmer","_trim","clear","_clear","_flusher","_autoFlusher","defineProperty","get","enumerable","configurable","length","pool","withoutException","pop","trim","defer","throwIfDisposed","execute","cancel","these","toArrayAndClear","dump","_onDispose","extendAutoClear","t","isFinite","isScheduled","add","o","push","m","take","e","len","value"],"mappings":"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","file":"System/Disposable/ObjectPool.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based upon ObjectPool from Parallel Extension Extras and other ObjectPool implementations.\n * Uses .add(T) and .take():T\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\", \"./dispose\", \"./DisposableBase\", \"../Tasks/TaskHandler\", \"../Exceptions/ArgumentOutOfRangeException\"], function (require, exports, dispose_1, DisposableBase_1, TaskHandler_1, ArgumentOutOfRangeException_1) {\n    \"use strict\";\n    var OBJECT_POOL = \"ObjectPool\", _MAX_SIZE = \"_maxSize\", ABSOLUTE_MAX_SIZE = 65536, MUST_BE_GT1 = \"Must be at valid number least 1.\", MUST_BE_LTM = \"Must be less than or equal to \" + ABSOLUTE_MAX_SIZE + \".\";\n    var ObjectPool = (function (_super) {\n        __extends(ObjectPool, _super);\n        function ObjectPool(_maxSize, _generator) {\n            _super.call(this);\n            this._maxSize = _maxSize;\n            this._generator = _generator;\n            this.autoClearTimeout = 5000;\n            if (isNaN(_maxSize) || _maxSize < 1)\n                throw new ArgumentOutOfRangeException_1.default(_MAX_SIZE, _maxSize, MUST_BE_GT1);\n            if (_maxSize > ABSOLUTE_MAX_SIZE)\n                throw new ArgumentOutOfRangeException_1.default(_MAX_SIZE, _maxSize, MUST_BE_LTM);\n            this._localAbsMaxSize = Math.min(_maxSize * 2, ABSOLUTE_MAX_SIZE);\n            var _ = this;\n            _._disposableObjectName = OBJECT_POOL;\n            _._pool = [];\n            _._trimmer = new TaskHandler_1.default(function () { return _._trim(); });\n            var clear = function () { return _._clear(); };\n            _._flusher = new TaskHandler_1.default(clear);\n            _._autoFlusher = new TaskHandler_1.default(clear);\n        }\n        Object.defineProperty(ObjectPool.prototype, \"maxSize\", {\n            get: function () {\n                return this._maxSize;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ObjectPool.prototype, \"count\", {\n            get: function () {\n                var p = this._pool;\n                return p ? p.length : 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ObjectPool.prototype._trim = function () {\n            var pool = this._pool;\n            while (pool.length > this._maxSize) {\n                dispose_1.default.withoutException(pool.pop());\n            }\n        };\n        ObjectPool.prototype.trim = function (defer) {\n            this.throwIfDisposed();\n            this._trimmer.execute(defer);\n        };\n        ObjectPool.prototype._clear = function () {\n            var _ = this, p = _._pool;\n            _._trimmer.cancel();\n            _._flusher.cancel();\n            _._autoFlusher.cancel();\n            dispose_1.default.these(p, true);\n            p.length = 0;\n        };\n        ObjectPool.prototype.clear = function (defer) {\n            this.throwIfDisposed();\n            this._flusher.execute(defer);\n        };\n        ObjectPool.prototype.toArrayAndClear = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            _._trimmer.cancel();\n            _._flusher.cancel();\n            var p = _._pool;\n            _._pool = [];\n            return p;\n        };\n        ObjectPool.prototype.dump = function () {\n            return this.toArrayAndClear();\n        };\n        ObjectPool.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            var _ = this;\n            _._generator = null;\n            dispose_1.default(_._trimmer, _._flusher, _._autoFlusher);\n            _._trimmer = null;\n            _._flusher = null;\n            _._autoFlusher = null;\n            _._pool.length = 0;\n            _._pool = null;\n        };\n        ObjectPool.prototype.extendAutoClear = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var t = _.autoClearTimeout;\n            if (isFinite(t) && !_._autoFlusher.isScheduled)\n                _._autoFlusher.execute(t);\n        };\n        ObjectPool.prototype.add = function (o) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (_._pool.length >= _._localAbsMaxSize) {\n                dispose_1.default(o);\n            }\n            else {\n                _._pool.push(o);\n                var m = _._maxSize;\n                if (m < ABSOLUTE_MAX_SIZE && _._pool.length > m)\n                    _._trimmer.execute(500);\n            }\n            _.extendAutoClear();\n        };\n        ObjectPool.prototype.take = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var e = _._pool.pop() || _._generator(), len = _._pool.length;\n            if (_._pool.length <= _._maxSize)\n                _._trimmer.cancel();\n            if (len)\n                _.extendAutoClear();\n            return e;\n        };\n        return ObjectPool;\n    }(DisposableBase_1.default));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = ObjectPool;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based upon ObjectPool from Parallel Extension Extras and other ObjectPool implementations.\r\n * Uses .add(T) and .take():T\r\n */\r\n\r\nimport dispose from \"./dispose\";\r\nimport DisposableBase from \"./DisposableBase\";\r\nimport TaskHandler from \"../Tasks/TaskHandler\";\r\nimport ArgumentOutOfRangeException from \"../Exceptions/ArgumentOutOfRangeException\";\r\n\r\nconst\r\n\tOBJECT_POOL       = \"ObjectPool\",\r\n\t_MAX_SIZE         = \"_maxSize\",\r\n\tABSOLUTE_MAX_SIZE = 65536,\r\n\tMUST_BE_GT1       = \"Must be at valid number least 1.\",\r\n\tMUST_BE_LTM       = `Must be less than or equal to ${ABSOLUTE_MAX_SIZE}.`;\r\n\r\nexport default class ObjectPool<T> extends DisposableBase\r\n{\r\n\r\n\tprivate _pool:T[];\r\n\tprivate _trimmer:TaskHandler;\r\n\tprivate _flusher:TaskHandler;\r\n\tprivate _autoFlusher:TaskHandler;\r\n\r\n\t/**\r\n\t * A transient amount of object to exist over _maxSize until trim() is called.\r\n\t * But any added objects over _localAbsMaxSize will be disposed immediately.\r\n\t */\r\n\tprivate _localAbsMaxSize:number;\r\n\r\n\t/**\r\n\t * By default will clear after 5 seconds of non-use.\r\n\t */\r\n\tautoClearTimeout:number = 5000;\r\n\r\n\tconstructor(\r\n\t\tprivate _maxSize:number,\r\n\t\tprivate _generator:()=>T)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(isNaN(_maxSize) || _maxSize<1)\r\n\t\t\tthrow new ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_GT1);\r\n\t\tif(_maxSize>ABSOLUTE_MAX_SIZE)\r\n\t\t\tthrow new ArgumentOutOfRangeException(_MAX_SIZE, _maxSize, MUST_BE_LTM);\r\n\r\n\t\tthis._localAbsMaxSize = Math.min(_maxSize*2, ABSOLUTE_MAX_SIZE);\r\n\r\n\t\tvar _ = this;\r\n\t\t_._disposableObjectName = OBJECT_POOL;\r\n\t\t_._pool = [];\r\n\t\t_._trimmer = new TaskHandler(()=>_._trim());\r\n\t\tvar clear = ()=>_._clear();\r\n\t\t_._flusher = new TaskHandler(clear);\r\n\t\t_._autoFlusher = new TaskHandler(clear);\r\n\t}\r\n\r\n\t/**\r\n\t * Defines the maximum at which trimming should allow.\r\n\t * @returns {number}\r\n\t */\r\n\tget maxSize():number\r\n\t{\r\n\t\treturn this._maxSize;\r\n\t}\r\n\r\n\t/**\r\n\t * Current number of objects in pool.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\t\tvar p = this._pool;\r\n\t\treturn p ? p.length : 0;\r\n\t}\r\n\r\n\tprotected _trim():void\r\n\t{\r\n\t\tvar pool = this._pool;\r\n\t\twhile(pool.length>this._maxSize)\r\n\t\t{\r\n\t\t\tdispose.withoutException(<any>pool.pop());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Will trim ensure the pool is less than the maxSize.\r\n\t * @param defer A delay before trimming.  Will be overridden by later calls.\r\n\t */\r\n\ttrim(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis._trimmer.execute(defer);\r\n\t}\r\n\r\n\tprotected _clear():void\r\n\t{\r\n\t\tvar _ = this, p = _._pool;\r\n\t\t_._trimmer.cancel();\r\n\t\t_._flusher.cancel();\r\n\t\t_._autoFlusher.cancel();\r\n\t\tdispose.these(<any>p, true);\r\n\t\tp.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Will clear out the pool.\r\n\t * Cancels any scheduled trims when executed.\r\n\t * @param defer A delay before clearing.  Will be overridden by later calls.\r\n\t */\r\n\tclear(defer?:number):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis._flusher.execute(defer);\r\n\t}\r\n\r\n\ttoArrayAndClear():T[]\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\t_._trimmer.cancel();\r\n\t\t_._flusher.cancel();\r\n\t\tvar p = _._pool;\r\n\t\t_._pool = [];\r\n\t\treturn p;\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for toArrayAndClear();\r\n\t */\r\n\tdump():T[]\r\n\t{\r\n\t\treturn this.toArrayAndClear();\r\n\t}\r\n\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tvar _ = this;\r\n\t\t_._generator = null;\r\n\t\tdispose(\r\n\t\t\t_._trimmer,\r\n\t\t\t_._flusher,\r\n\t\t\t_._autoFlusher\r\n\t\t);\r\n\t\t_._trimmer = null;\r\n\t\t_._flusher = null;\r\n\t\t_._autoFlusher = null;\r\n\r\n\t\t_._pool.length = 0;\r\n\t\t_._pool = null;\r\n\t}\r\n\r\n\textendAutoClear():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tvar t = _.autoClearTimeout;\r\n\t\tif(isFinite(t) && !_._autoFlusher.isScheduled)\r\n\t\t\t_._autoFlusher.execute(t);\r\n\t}\r\n\r\n\tadd(o:T):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tif(_._pool.length>=_._localAbsMaxSize)\r\n\t\t{\r\n\t\t\t// Getting too big, dispose immediately...\r\n\t\t\tdispose(<any>o);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._pool.push(o);\r\n\t\t\tvar m = _._maxSize;\r\n\t\t\tif(m<ABSOLUTE_MAX_SIZE && _._pool.length>m)\r\n\t\t\t\t_._trimmer.execute(500);\r\n\t\t}\r\n\t\t_.extendAutoClear();\r\n\r\n\t}\r\n\r\n\ttake():T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar e   = _._pool.pop() || _._generator(),\r\n\t\t    len = _._pool.length;\r\n\r\n\t\tif(_._pool.length<=_._maxSize)\r\n\t\t\t_._trimmer.cancel();\r\n\t\tif(len)\r\n\t\t\t_.extendAutoClear();\r\n\r\n\t\treturn e;\r\n\t}\r\n\r\n\r\n}\r\n"]}