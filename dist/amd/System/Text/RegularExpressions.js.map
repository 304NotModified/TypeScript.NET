{"version":3,"sources":["System/Text/RegularExpressions.js","System/Text/RegularExpressions.ts"],"names":["define","require","exports","extends_1","RegexOptions","__extends","EMPTY","_I","_G","_M","_U","_W","_Y","IGNORE_CASE","I","GLOBAL","G","MULTI_LINE","M","UNICODE","U","STICKY","Y","IGNORE_PATTERN_WHITESPACE","W","Regex","pattern","options","extra","_i","arguments","length","Error","patternString","flags","concat","join","toLowerCase","RegExp","p","ignoreCase","indexOf","multiline","source","ignoreWhiteSpace","replace","keys","k","match","i","len","this","_keys","_re","Object","freeze","prototype","input","startIndex","r","_","exec","substring","Match","Empty","first","index","loc","groups","groupMap","text","g","EmptyGroup","Group","push","m","matches","end","success","count","Infinity","result","isEvaluator","length_1","isMatch","test","e","Capture","value","defineProperty","get","v","enumerable","configurable","_super","call","namedGroups","_this","EmptyMatch"],"mappings":"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","file":"RegularExpressions.js","sourcesContent":["define([\"require\", \"exports\", \"../../extends\"], function (require, exports, extends_1) {\n    \"use strict\";\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var EMPTY = \"\";\n    var _I = 'i', _G = 'g', _M = 'm', _U = 'u', _W = 'w', _Y = 'y';\n    /**\n     * https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions%28v=vs.110%29.aspx\n     */\n    var RegexOptions;\n    (function (RegexOptions) {\n        /**\n         * Specifies case-insensitive matching. For more information, see the \"Case-Insensitive Matching \" section in the Regular Expression Options topic.\n         */\n        RegexOptions.IGNORE_CASE = _I;\n        RegexOptions.I = _I;\n        /**\n         * Specifies global matching instead of single.\n         */\n        RegexOptions.GLOBAL = _G;\n        RegexOptions.G = _G;\n        /**\n         * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \\n or \\r), not only the very beginning or end of the whole input string)\n         */\n        RegexOptions.MULTI_LINE = _M;\n        RegexOptions.M = _M;\n        /**\n         * treat pattern as a sequence of unicode code points\n         */\n        RegexOptions.UNICODE = _U;\n        RegexOptions.U = _U;\n        /**\n         * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\n         */\n        RegexOptions.STICKY = _Y;\n        RegexOptions.Y = _Y;\n        /**\n         * Modifies the pattern to ignore standard whitespace characters.\n         */\n        RegexOptions.IGNORE_PATTERN_WHITESPACE = _W;\n        RegexOptions.W = _W;\n    })(RegexOptions = exports.RegexOptions || (exports.RegexOptions = {}));\n    var Regex = (function () {\n        function Regex(pattern, options) {\n            var extra = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                extra[_i - 2] = arguments[_i];\n            }\n            if (!pattern)\n                throw new Error(\"'pattern' cannot be null or empty.\");\n            var patternString, flags = (options && ((options) instanceof (Array) ? options : [options]).concat(extra) || extra)\n                .join(EMPTY)\n                .toLowerCase();\n            if (pattern instanceof RegExp) {\n                var p = pattern;\n                if (p.ignoreCase && flags.indexOf(_I) === -1)\n                    flags += _I;\n                if (p.multiline && flags.indexOf(_M) === -1)\n                    flags += _M;\n                patternString = p.source;\n            }\n            else {\n                patternString = pattern;\n            }\n            var ignoreWhiteSpace = flags.indexOf(_W) != -1;\n            // For the majority of expected behavior, we need to eliminate global and whitespace ignore.\n            flags = flags.replace(/[gw]/g, EMPTY);\n            // find the keys inside the pattern, and place in mapping array {0:'key1', 1:'key2', ...}\n            var keys = [];\n            {\n                var k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\n                if (k) {\n                    for (var i = 0, len = k.length; i < len; i++) {\n                        keys[i + 1] = k[i];\n                    }\n                    // remove keys from regexp leaving standard regexp\n                    patternString = patternString.replace(/\\?<\\w+>/g, EMPTY);\n                    this._keys = keys;\n                }\n                if (ignoreWhiteSpace)\n                    patternString = patternString.replace(/\\s+/g, \"\\\\s*\");\n                this._re = new RegExp(patternString, flags);\n            }\n            Object.freeze(this);\n        }\n        Regex.prototype.match = function (input, startIndex) {\n            if (startIndex === void 0) { startIndex = 0; }\n            var _ = this;\n            var r;\n            if (!input\n                || startIndex >= input.length\n                || !(r = this._re.exec(input.substring(startIndex))))\n                return Match.Empty;\n            if (!(startIndex > 0))\n                startIndex = 0;\n            var first = startIndex + r.index;\n            var loc = first;\n            var groups = [], groupMap = {};\n            for (var i = 0, len = r.length; i < len; ++i) {\n                var text = r[i];\n                var g = EmptyGroup;\n                if (text !== null || text !== void 0) {\n                    // Empty string might mean \\b match or similar.\n                    g = new Group(text, loc);\n                    g.freeze();\n                }\n                if (i && _._keys && i < _._keys.length)\n                    groupMap[_._keys[i]] = g;\n                groups.push(g);\n                if (i !== 0)\n                    loc += text.length;\n            }\n            var m = new Match(r[0], first, groups, groupMap);\n            m.freeze();\n            return m;\n        };\n        Regex.prototype.matches = function (input) {\n            var matches = [];\n            var m, p = 0;\n            var end = input && input.length || 0;\n            while (p < end && (m = this.match(input, p)) && m.success) {\n                matches.push(m);\n                p = m.index + m.length;\n            }\n            Object.freeze(matches);\n            return matches;\n        };\n        Regex.prototype.replace = function (input, r, count) {\n            if (count === void 0) { count = Infinity; }\n            if (!input || r === null || r === void 0 || !(count > 0))\n                return input;\n            var result = [];\n            var p = 0;\n            var end = input.length, isEvaluator = typeof r == \"function\";\n            var m, i = 0;\n            while (i < count && p < end && (m = this.match(input, p)) && m.success) {\n                var index = m.index, length_1 = m.length;\n                if (p !== index)\n                    result.push(input.substring(p, index));\n                result.push(isEvaluator ? r(m, i++) : r);\n                p = index + length_1;\n            }\n            if (p < end)\n                result.push(input.substring(p));\n            return result.join(EMPTY);\n        };\n        Regex.prototype.isMatch = function (input) {\n            return this._re.test(input);\n        };\n        Regex.isMatch = function (input, pattern, options) {\n            var r = new Regex(pattern, options);\n            return r.isMatch(input);\n        };\n        Regex.replace = function (input, pattern, e, options) {\n            var r = new Regex(pattern, options);\n            return r.replace(input, e);\n        };\n        return Regex;\n    }());\n    exports.Regex = Regex;\n    var Capture = (function () {\n        function Capture(value, index) {\n            if (value === void 0) { value = EMPTY; }\n            if (index === void 0) { index = -1; }\n            this.value = value;\n            this.index = index;\n        }\n        Object.defineProperty(Capture.prototype, \"length\", {\n            get: function () {\n                var v = this.value;\n                return v && v.length || 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Capture.prototype.freeze = function () {\n            Object.freeze(this);\n        };\n        return Capture;\n    }());\n    exports.Capture = Capture;\n    var Group = (function (_super) {\n        __extends(Group, _super);\n        function Group(value, index) {\n            if (value === void 0) { value = EMPTY; }\n            if (index === void 0) { index = -1; }\n            return _super.call(this, value, index) || this;\n        }\n        Object.defineProperty(Group.prototype, \"success\", {\n            get: function () {\n                return this.index != -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Group, \"Empty\", {\n            get: function () {\n                return EmptyGroup;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return Group;\n    }(Capture));\n    exports.Group = Group;\n    var EmptyGroup = new Group();\n    EmptyGroup.freeze();\n    var Match = (function (_super) {\n        __extends(Match, _super);\n        function Match(value, index, groups, namedGroups) {\n            if (value === void 0) { value = EMPTY; }\n            if (index === void 0) { index = -1; }\n            if (groups === void 0) { groups = []; }\n            if (namedGroups === void 0) { namedGroups = {}; }\n            var _this = _super.call(this, value, index) || this;\n            _this.groups = groups;\n            _this.namedGroups = namedGroups;\n            return _this;\n        }\n        Match.prototype.freeze = function () {\n            if (!this.groups)\n                throw new Error(\"'groups' cannot be null.\");\n            if (!this.namedGroups)\n                throw new Error(\"'groupMap' cannot be null.\");\n            Object.freeze(this.groups);\n            Object.freeze(this.namedGroups);\n            _super.prototype.freeze.call(this);\n        };\n        Object.defineProperty(Match, \"Empty\", {\n            get: function () {\n                return EmptyMatch;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return Match;\n    }(Group));\n    exports.Match = Match;\n    var EmptyMatch = new Match();\n    EmptyMatch.freeze();\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Regex;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n// NOTE: Avoid real (types/interfaces only = ok) dependencies so this class can be used cleanly.\r\nimport {IMap} from \"../../IMap\";\r\nimport {Primitive} from \"../Primitive\";\r\nimport {SelectorWithIndex} from \"../FunctionTypes\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst EMPTY:string = \"\";\r\n\r\nconst _I = 'i', _G = 'g', _M = 'm', _U = 'u', _W = 'w', _Y = 'y';\r\n\r\n\r\n/**\r\n * https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions%28v=vs.110%29.aspx\r\n */\r\nexport module RegexOptions\r\n{\r\n\texport type Global = 'g';\r\n\texport type IgnoreCase = 'i';\r\n\texport type MultiLine = 'm';\r\n\texport type Unicode = 'u';\r\n\texport type Sticky = 'y';\r\n\texport type IgnorePatternWhitespace = \"w\";\r\n\r\n\texport type Literal = Global | IgnoreCase | MultiLine | Unicode | Sticky | IgnorePatternWhitespace;\r\n\r\n\r\n\t/**\r\n\t * Specifies case-insensitive matching. For more information, see the \"Case-Insensitive Matching \" section in the Regular Expression Options topic.\r\n\t */\r\n\texport const IGNORE_CASE:IgnoreCase = _I;\r\n\texport const I:IgnoreCase = _I;\r\n\r\n\t/**\r\n\t * Specifies global matching instead of single.\r\n\t */\r\n\texport const GLOBAL:Global = _G;\r\n\texport const G:Global = _G;\r\n\r\n\t/**\r\n\t * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \\n or \\r), not only the very beginning or end of the whole input string)\r\n\t */\r\n\texport const MULTI_LINE:MultiLine = _M;\r\n\texport const M:MultiLine = _M;\r\n\r\n\t/**\r\n\t * treat pattern as a sequence of unicode code points\r\n\t */\r\n\texport const UNICODE:Unicode = _U;\r\n\texport const U:Unicode = _U;\r\n\r\n\t/**\r\n\t * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\r\n\t */\r\n\texport const STICKY:Sticky = _Y;\r\n\texport const Y:Sticky = _Y;\r\n\r\n\t/**\r\n\t * Modifies the pattern to ignore standard whitespace characters.\r\n\t */\r\n\texport const IGNORE_PATTERN_WHITESPACE:IgnorePatternWhitespace = _W;\r\n\texport const W:IgnorePatternWhitespace = _W;\r\n\r\n}\r\n\r\n\r\nexport class Regex\r\n{\r\n\tprivate readonly _re:RegExp;\r\n\tprivate readonly _keys:string[];\r\n\r\n\tconstructor(\r\n\t\tpattern:string|RegExp,\r\n\t\toptions?:RegexOptions.Literal|RegexOptions.Literal[],\r\n\t\t...extra:RegexOptions.Literal[])\r\n\t{\r\n\t\tif(!pattern) throw new Error(\"'pattern' cannot be null or empty.\");\r\n\r\n\t\tlet patternString:string,\r\n\t\t    flags:string\r\n\t\t\t    = (options && ((options)instanceof(Array) ? options : [options]).concat(extra) || extra)\r\n\t\t\t    .join(EMPTY)\r\n\t\t\t    .toLowerCase();\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tlet p = <RegExp>pattern;\r\n\t\t\tif(p.ignoreCase && flags.indexOf(_I)=== -1)\r\n\t\t\t\tflags += _I;\r\n\t\t\tif(p.multiline && flags.indexOf(_M)=== -1)\r\n\t\t\t\tflags += _M;\r\n\t\t\tpatternString = p.source;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpatternString = pattern;\r\n\t\t}\r\n\t\tconst ignoreWhiteSpace = flags.indexOf(_W)!= -1;\r\n\r\n\t\t// For the majority of expected behavior, we need to eliminate global and whitespace ignore.\r\n\t\tflags = flags.replace(/[gw]/g, EMPTY);\r\n\r\n\t\t// find the keys inside the pattern, and place in mapping array {0:'key1', 1:'key2', ...}\r\n\t\tconst keys:string[] = [];\r\n\t\t{\r\n\t\t\tlet k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = 0, len = k.length; i<len; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys[i + 1] = k[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// remove keys from regexp leaving standard regexp\r\n\t\t\t\tpatternString = patternString.replace(/\\?<\\w+>/g, EMPTY);\r\n\t\t\t\tthis._keys = keys;\r\n\t\t\t}\r\n\r\n\t\t\tif(ignoreWhiteSpace)\r\n\t\t\t\tpatternString = patternString.replace(/\\s+/g, \"\\\\s*\");\r\n\r\n\t\t\tthis._re = new RegExp(patternString, flags);\r\n\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tmatch(input:string, startIndex:number = 0):Match\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet r:RegExpExecArray | null;\r\n\t\tif(!input\r\n\t\t\t|| startIndex>=input.length\r\n\t\t\t|| !(r = this._re.exec(input.substring(startIndex))))\r\n\t\t\treturn Match.Empty;\r\n\r\n\t\tif(!(startIndex>0)) startIndex = 0;\r\n\r\n\t\tconst first = startIndex + r.index;\r\n\t\tlet loc = first;\r\n\t\tconst groups:Group[] = [],\r\n\t\t      groupMap:IMap<Group> = {};\r\n\r\n\t\tfor(let i = 0, len = r.length; i<len; ++i)\r\n\t\t{\r\n\t\t\tlet text = r[i];\r\n\t\t\tlet g = EmptyGroup;\r\n\t\t\tif(text!==null || text!== void 0)\r\n\t\t\t{\r\n\t\t\t\t// Empty string might mean \\b match or similar.\r\n\t\t\t\tg = new Group(text, loc);\r\n\t\t\t\tg.freeze();\r\n\t\t\t}\r\n\t\t\tif(i && _._keys && i<_._keys.length) groupMap[_._keys[i]] = g;\r\n\t\t\tgroups.push(g);\r\n\t\t\tif(i!==0) loc += text.length;\r\n\t\t}\r\n\r\n\t\tconst m = new Match(r[0], first, groups, groupMap);\r\n\t\tm.freeze();\r\n\t\treturn m;\r\n\t}\r\n\r\n\tmatches(input:string):Match[] //Readonly<Match[]>\r\n\t{\r\n\t\tconst matches:Match[] = [];\r\n\t\tlet m:Match, p = 0;\r\n\t\tconst end = input && input.length || 0;\r\n\t\twhile(p<end && (m = this.match(input, p)) && m.success)\r\n\t\t{\r\n\t\t\tmatches.push(m);\r\n\t\t\tp = m.index + m.length;\r\n\t\t}\r\n\t\tObject.freeze(matches);\r\n\t\treturn matches;\r\n\t}\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\treplacement:Primitive,\r\n\t\tcount?:number):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tevaluator:SelectorWithIndex<Match,Primitive>,\r\n\t\tcount?:number):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tr:any,\r\n\t\tcount:number = Infinity):string\r\n\t{\r\n\t\tif(!input || r===null || r=== void 0 || !(count>0)) return input;\r\n\t\tconst result:string[] = [];\r\n\t\tlet p = 0;\r\n\t\tconst end = input.length, isEvaluator = typeof r==\"function\";\r\n\r\n\t\tlet m:Match, i:number = 0;\r\n\t\twhile(i<count && p<end && (m = this.match(input, p)) && m.success)\r\n\t\t{\r\n\t\t\tlet {index, length} = m;\r\n\t\t\tif(p!==index) result.push(input.substring(p, index));\r\n\t\t\tresult.push(isEvaluator ? r(m, i++) : r);\r\n\t\t\tp = index + length;\r\n\t\t}\r\n\r\n\t\tif(p<end) result.push(input.substring(p));\r\n\r\n\t\treturn result.join(EMPTY);\r\n\t}\r\n\r\n\tisMatch(input:string):boolean\r\n\t{\r\n\t\treturn this._re.test(input);\r\n\t}\r\n\r\n\tstatic isMatch(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\toptions?:RegexOptions.Literal[]):boolean\r\n\t{\r\n\t\tconst r = new Regex(pattern, options);\r\n\t\treturn r.isMatch(input);\r\n\t}\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\treplacement:string,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\tevaluator:SelectorWithIndex<Match,Primitive>,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\te:any,\r\n\t\toptions?:RegexOptions.Literal[]):string\r\n\t{\r\n\t\tconst r = new Regex(pattern, options);\r\n\t\treturn r.replace(input, e);\r\n\t}\r\n}\r\n\r\nexport class Capture\r\n{\r\n\r\n\tget length():number\r\n\t{\r\n\t\tconst v = this.value;\r\n\t\treturn v && v.length || 0;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tpublic readonly value:string = EMPTY,\r\n\t\tpublic readonly index:number = -1)\r\n\t{\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n}\r\n\r\nexport class Group extends Capture\r\n{\r\n\tget success():boolean\r\n\t{\r\n\t\treturn this.index!= -1;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1)\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tstatic get Empty():Group\r\n\t{\r\n\t\treturn EmptyGroup;\r\n\t}\r\n\r\n}\r\nconst EmptyGroup = new Group();\r\nEmptyGroup.freeze();\r\n\r\nexport class Match extends Group\r\n{\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1,\r\n\t\tpublic readonly groups:Group[] = [],\r\n\t\tpublic readonly namedGroups:IMap<Group> = {})\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tif(!this.groups) throw new Error(\"'groups' cannot be null.\");\r\n\t\tif(!this.namedGroups) throw new Error(\"'groupMap' cannot be null.\");\r\n\t\tObject.freeze(this.groups);\r\n\t\tObject.freeze(this.namedGroups);\r\n\t\tsuper.freeze();\r\n\t}\r\n\r\n\tstatic get Empty():Match\r\n\t{\r\n\t\treturn EmptyMatch;\r\n\t}\r\n}\r\nconst EmptyMatch = new Match();\r\nEmptyMatch.freeze();\r\n\r\n\r\nexport default Regex;"]}