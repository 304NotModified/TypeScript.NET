{"version":3,"sources":["System/Tasks/defer.js","System/Tasks/defer.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","define","require","exports","defer","task","delay","Defer","interval","count","Infinity","DeferInterval","DeferBase","dispose","cancel","_super","call","_id","setTimeout","handler","id","clearTimeout","_remaining","setInterval","clearInterval","defineProperty","value"],"mappings":";;;;AAIA,GAAIA,WAAaC,MAAQA,KAAKD,WAAc,SAAUE,EAAGC,GAErD,QAASC,KAAOH,KAAKI,YAAcH,EADnC,IAAK,GAAII,KAAKH,GAAOA,EAAEI,eAAeD,KAAIJ,EAAEI,GAAKH,EAAEG,GAEnDJ,GAAEM,UAAkB,OAANL,EAAaM,OAAOC,OAAOP,IAAMC,EAAGI,UAAYL,EAAEK,UAAW,GAAIJ,IAEnFO,SAAQ,UAAW,WAAY,SAAUC,EAASC,GAC9C,YCgFJ,SAAAC,GACCC,EACAC,GAEA,MAAO,IAAIC,GAAMF,EAAMC,GAGxB,QAAAE,GACCH,EACAG,EACAC,GAEA,MAFA,UAAAA,IAAAA,EAAAC,EAAAA,GAEO,GAAIC,GAAcN,EAAMG,EAAUC,GA/F1C,GAAAG,GAAA,WAAA,QAAAA,MAUA,MAJCA,GAAAd,UAAAe,QAAA,WAECtB,KAAKuB,UAEPF,KAEAL,EAAA,SAAAQ,GAIC,QAAAR,GAAYF,EAAeC,GAE1BS,EAAAC,KAAAzB,MACKe,GAAO,IAAIA,EAAQ,GACxBf,KAAK0B,IAAMC,WAAWX,EAAMY,QAASb,EAAOD,EAAMd,MAsBpD,MA9BoBD,WAAAiB,EAAAQ,GAWnBR,EAAAT,UAAAgB,OAAA,WAEC,GAAIM,GAAK7B,KAAK0B,GACd,OAAGG,IAEFC,aAAaD,GACb7B,KAAK0B,IAAM,MACJ,IAED,GAIOV,EAAAY,QAAf,SAAuBd,EAAeb,GAErCA,EAAEsB,SACFT,KAGFE,GA9BoBK,GAgCpBD,EAAA,SAAAI,GAIC,QAAAJ,GACCN,EACAG,EACQc,GAGR,GAHA,SAAAA,IAAAA,EAAAZ,EAAAA,GAEAK,EAAAC,KAAAzB,MAFQA,KAAA+B,WAAAA,EAGM,OAAXd,GAA+B,SAAZA,EACrB,KAAM,oCACP,IAAY,EAATA,EACF,KAAM,gCAEPjB,MAAK0B,IAAMM,YAAYZ,EAAcQ,QAASX,EAAUH,EAAMd,MAqBhE,MApC4BD,WAAAqB,EAAAI,GAkB3BJ,EAAAb,UAAAgB,OAAA,WAEC,GAAIM,GAAK7B,KAAK0B,GACd,OAAGG,IAEFI,cAAcJ,GACd7B,KAAK0B,IAAM,GACJ,IAED,GAGON,EAAAQ,QAAf,SAAuBd,EAAeb,KAE9BA,EAAE8B,YAAa9B,EAAEsB,SACxBT,KAGFM,GApC4BC,EAuC5Bb,QAAA0B,eAAAtB,EAAA,cAAAuB,OAAA,IDhBIvB,EAAAA,WAAkBC,ECuBND,EAAAK,SAAQA","file":"System/Tasks/defer.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\"], function (require, exports) {\n    \"use strict\";\n    var DeferBase = (function () {\n        function DeferBase() {\n        }\n        DeferBase.prototype.dispose = function () {\n            this.cancel();\n        };\n        return DeferBase;\n    }());\n    var Defer = (function (_super) {\n        __extends(Defer, _super);\n        function Defer(task, delay) {\n            _super.call(this);\n            if (!(delay >= 0))\n                delay = 0;\n            this._id = setTimeout(Defer.handler, delay, task, this);\n        }\n        Defer.prototype.cancel = function () {\n            var id = this._id;\n            if (id) {\n                clearTimeout(id);\n                this._id = null;\n                return true;\n            }\n            return false;\n        };\n        Defer.handler = function (task, d) {\n            d.cancel();\n            task();\n        };\n        return Defer;\n    }(DeferBase));\n    var DeferInterval = (function (_super) {\n        __extends(DeferInterval, _super);\n        function DeferInterval(task, interval, _remaining) {\n            if (_remaining === void 0) { _remaining = Infinity; }\n            _super.call(this);\n            this._remaining = _remaining;\n            if (interval === null || interval === void (0))\n                throw \"'interval' must be a valid number.\";\n            if (interval < 0)\n                throw \"'interval' cannot be negative.\";\n            this._id = setInterval(DeferInterval.handler, interval, task, this);\n        }\n        DeferInterval.prototype.cancel = function () {\n            var id = this._id;\n            if (id) {\n                clearInterval(id);\n                this._id = 0;\n                return true;\n            }\n            return false;\n        };\n        DeferInterval.handler = function (task, d) {\n            if (!(--d._remaining))\n                d.cancel();\n            task();\n        };\n        return DeferInterval;\n    }(DeferBase));\n    function defer(task, delay) {\n        return new Defer(task, delay);\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = defer;\n    function interval(task, interval, count) {\n        if (count === void 0) { count = Infinity; }\n        return new DeferInterval(task, interval, count);\n    }\n    exports.interval = interval;\n});\n","///<reference path=\"ICancellable.d.ts\"/>\r\n/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nabstract class DeferBase implements ICancellable\r\n{\r\n\tprotected _id:number;\r\n\r\n\tabstract cancel():boolean;\r\n\r\n\tdispose():void\r\n\t{\r\n\t\tthis.cancel();\r\n\t}\r\n}\r\n\r\nclass Defer extends DeferBase\r\n{\r\n\r\n\r\n\tconstructor(task:Function, delay?:number)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!(delay>=0)) delay = 0;\r\n\t\tthis._id = setTimeout(Defer.handler, delay, task, this);\r\n\t}\r\n\r\n\tcancel():boolean\r\n\t{\r\n\t\tvar id = this._id;\r\n\t\tif(id)\r\n\t\t{\r\n\t\t\tclearTimeout(id);\r\n\t\t\tthis._id = null;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// Use a static function here to avoid recreating a new function every time.\r\n\tprivate static handler(task:Function, d:Defer):void\r\n\t{\r\n\t\td.cancel();\r\n\t\ttask();\r\n\t}\r\n\r\n}\r\n\r\nclass DeferInterval extends DeferBase\r\n{\r\n\r\n\r\n\tconstructor(\r\n\t\ttask:Function,\r\n\t\tinterval:number,\r\n\t\tprivate _remaining:number = Infinity)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(interval===null || interval=== void(0))\r\n\t\t\tthrow \"'interval' must be a valid number.\";\r\n\t\tif(interval<0)\r\n\t\t\tthrow \"'interval' cannot be negative.\";\r\n\r\n\t\tthis._id = setInterval(DeferInterval.handler, interval, task, this);\r\n\t}\r\n\r\n\tcancel():boolean\r\n\t{\r\n\t\tvar id = this._id;\r\n\t\tif(id)\r\n\t\t{\r\n\t\t\tclearInterval(id);\r\n\t\t\tthis._id = 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate static handler(task:Function, d:DeferInterval):void\r\n\t{\r\n\t\tif(!(--d._remaining)) d.cancel();\r\n\t\ttask();\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport default function defer(\r\n\ttask:Function,\r\n\tdelay?:number):ICancellable\r\n{\r\n\treturn new Defer(task, delay);\r\n}\r\n\r\nexport function interval(\r\n\ttask:Function,\r\n\tinterval:number,\r\n\tcount:number = Infinity):ICancellable\r\n{\r\n\treturn new DeferInterval(task, interval, count);\r\n}"]}