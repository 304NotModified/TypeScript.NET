{"version":3,"sources":["System/Tasks/deferImmediate.js","System/Tasks/deferImmediate.ts"],"names":["define","require","exports","Types_1","LinkedNodeList_1","Queue_1","flush","entry","immediateQueue","first","task_1","task","domain","removeNode","enter","runSingle","laterQueue","dequeue","flushing","e","isNodeJS","exit","setTimeout","requestFlush","requestTick","deferImmediate","_this","this","process","addNode","cancel","dispose","runAfterDeferred","enqueue","Object","defineProperty","value","isObject","toString","nextTick","setImmediate","window","bind","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage"],"mappings":";;;;;AAKAA,QAAQ,UAAW,UAAW,WAAY,gCAAiC,wBAAyB,SAAUC,EAASC,EAASC,EAASC,EAAkBC,GACvJ,YCmCJ,SAAAC,KAIC,IADA,GAAIC,GACEA,EAAQC,EAAeC,OAC7B,CACM,GAAAC,GAAAH,EAAAI,KAAMC,EAAAL,EAAAK,MACXJ,GAAeK,WAAWN,GACvBK,GAAQA,EAAOE,QAClBC,EAAUL,EAAME,GAIjB,IADA,GAAID,GACEA,EAAOK,EAAWC,WAEvBF,EAAUJ,EAGXO,IAAW,EAUZ,QAAAH,GAAmBJ,EAAcC,GAEhC,IAECD,IAGD,MAAMQ,GAEL,GAAGC,EAkBF,KAVGR,IAEFA,EAAOS,OAERC,WAAWhB,EAAO,GACfM,GAEFA,EAAOE,QAGFK,CAONG,YAAW,WAEV,KAAMH,IACJ,GAIFP,GAEFA,EAAOS,OAIT,QAAAE,KAEKL,IAEHA,GAAW,EACXM,KAIF,QAAAC,GAAuCd,GAAvC,GAAAe,GAAAC,KAEKpB,GACHI,KAAMA,EACNC,OAAQQ,GAAkBQ,QAAiB,OAO5C,OAJApB,GAAeqB,QAAQtB,GAEvBgB,KAGCO,OAAO,WAAI,QAAEtB,EAAeK,WAAWN,IACvCwB,QAAQ,WAAML,EAAKI,WAQrB,QAAAE,GAAiCrB,GAEhCK,EAAWiB,QAAQtB,GACnBY,IApHD,GAAIC,GACAJ,GAAmB,EACnBF,GAAmB,EA6BnBV,EAAiB,GAAIJ,GAAAA,WAGrBY,EAA4B,GAAIX,GAAAA,UAsFpC,IA5BA6B,OAAAC,eAAAjC,EAAA,cAAAkC,OAAA,IDpDIlC,EAAAA,WAAkBuB,ECyENvB,EAAA8B,iBAAgBA,EAO7B7B,EAAAA,WAAKkC,SAAST,UACQ,qBAArBA,QAAQU,YACRV,QAAQW,SAYXnB,GAAW,EAEXI,EAAc,WAEbI,QAAQW,SAASjC,QAId,IAAyB,kBAAfkC,cAKbhB,EAFkB,mBAATiB,QAEKD,aAAaE,KAAKD,OAAQnC,GAI1B,WAEbkC,aAAalC,QAKX,IAA2B,mBAAjBqC,gBACf,CAGC,GAAIC,GAAU,GAAID,eAGlBC,GAAQC,MAAMC,UAAY,WAEzBtB,EAAcuB,EACdH,EAAQC,MAAMC,UAAYxC,EAC1BA,IAED,IAAIyC,GAAkB,WAIrBH,EAAQI,MAAMC,YAAY,GAE3BzB,GAAc,WAEbF,WAAWhB,EAAO,GAClByC,SAODvB,GAAc,WAEbF,WAAWhB,EAAO","file":"System/Tasks/deferImmediate.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Based on code from: https://github.com/kriskowal/q\n */\ndefine([\"require\", \"exports\", \"../Types\", \"../Collections/LinkedNodeList\", \"../Collections/Queue\"], function (require, exports, Types_1, LinkedNodeList_1, Queue_1) {\n    \"use strict\";\n    \"use strict\";\n    var requestTick;\n    var isNodeJS = false;\n    var flushing = false;\n    function flush() {\n        var entry;\n        while (entry = immediateQueue.first) {\n            var task_1 = entry.task, domain = entry.domain;\n            immediateQueue.removeNode(entry);\n            if (domain)\n                domain.enter();\n            runSingle(task_1, domain);\n        }\n        var task;\n        while (task = laterQueue.dequeue()) {\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    var immediateQueue = new LinkedNodeList_1.default();\n    var laterQueue = new Queue_1.default();\n    function runSingle(task, domain) {\n        try {\n            task();\n        }\n        catch (e) {\n            if (isNodeJS) {\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n                throw e;\n            }\n            else {\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n        if (domain) {\n            domain.exit();\n        }\n    }\n    function requestFlush() {\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    }\n    function deferImmediate(task) {\n        var _this = this;\n        var entry = {\n            task: task,\n            domain: isNodeJS && process['domain']\n        };\n        immediateQueue.addNode(entry);\n        requestFlush();\n        return {\n            cancel: function () { return !!immediateQueue.removeNode(entry); },\n            dispose: function () { _this.cancel(); }\n        };\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = deferImmediate;\n    function runAfterDeferred(task) {\n        laterQueue.enqueue(task);\n        requestFlush();\n    }\n    exports.runAfterDeferred = runAfterDeferred;\n    if (Types_1.default.isObject(process)\n        && process.toString() === \"[object process]\"\n        && process.nextTick) {\n        isNodeJS = true;\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n    }\n    else if (typeof setImmediate === \"function\") {\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        }\n        else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n    }\n    else if (typeof MessageChannel !== \"undefined\") {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n    }\n    else {\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\n\r\n///<reference path=\"../Collections/ILinkedListNode.d.ts\"/>\r\nimport Type from \"../Types\";\r\nimport LinkedNodeList from \"../Collections/LinkedNodeList\";\r\nimport Queue from \"../Collections/Queue\";\r\n\r\ndeclare module process\r\n{\r\n\texport function nextTick(callback:Closure):void;\r\n\r\n\texport function toString():string;\r\n}\r\n\r\ninterface IDomain\r\n{\r\n\tenter():void;\r\n\texit():void;\r\n}\r\n\r\ninterface ITaskQueueEntry extends ILinkedNode<ITaskQueueEntry>\r\n{\r\n\ttask:Closure;\r\n\tdomain?:IDomain;\r\n}\r\n\r\n\r\n\"use strict\";\r\n\r\nvar requestTick:()=>void;\r\nvar isNodeJS:boolean = false;\r\nvar flushing:boolean = false;\r\n\r\n// Use the fastest possible means to execute a task in a future turn\r\n// of the event loop.\r\n\r\n\r\nfunction flush():void\r\n{\r\n\t/* jshint loopfunc: true */\r\n\tvar entry:ITaskQueueEntry;\r\n\twhile(entry = immediateQueue.first)\r\n\t{\r\n\t\tlet {task, domain} = entry;\r\n\t\timmediateQueue.removeNode(entry);\r\n\t\tif(domain) domain.enter();\r\n\t\trunSingle(task, domain);\r\n\t}\r\n\r\n\tlet task:Closure;\r\n\twhile(task = laterQueue.dequeue())\r\n\t{\r\n\t\trunSingle(task);\r\n\t}\r\n\r\n\tflushing = false;\r\n}\r\n\r\n\r\n// linked list of tasks.  Using a real linked list to allow for removal.\r\nvar immediateQueue = new LinkedNodeList<ITaskQueueEntry>();\r\n\r\n// queue for late tasks, used by unhandled rejection tracking\r\nvar laterQueue:Queue<Closure> = new Queue<Closure>();\r\n\r\nfunction runSingle(task:Closure, domain?:IDomain):void\r\n{\r\n\ttry\r\n\t{\r\n\t\ttask();\r\n\r\n\t}\r\n\tcatch(e)\r\n\t{\r\n\t\tif(isNodeJS)\r\n\t\t{\r\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\r\n\t\t\t// Re-throw them synchronously to interrupt flushing!\r\n\r\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\r\n\t\t\t// listening \"uncaughtException\" events (as domains does).\r\n\t\t\t// Continue in next event to avoid tick recursion.\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.exit();\r\n\t\t\t}\r\n\t\t\tsetTimeout(flush, 0);\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.enter();\r\n\t\t\t}\r\n\r\n\t\t\tthrow e;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// In browsers, uncaught exceptions are not fatal.\r\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\r\n\t\t\tsetTimeout(()=>\r\n\t\t\t{\r\n\t\t\t\tthrow e;\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tif(domain)\r\n\t{\r\n\t\tdomain.exit();\r\n\t}\r\n}\r\n\r\nfunction requestFlush():void\r\n{\r\n\tif(!flushing)\r\n\t{\r\n\t\tflushing = true;\r\n\t\trequestTick();\r\n\t}\r\n}\r\n\r\nexport default function deferImmediate(task:Closure):ICancellable\r\n{\r\n\tvar entry:ITaskQueueEntry = {\r\n\t\ttask: task,\r\n\t\tdomain: isNodeJS && (<any>process)['domain']\r\n\t};\r\n\r\n\timmediateQueue.addNode(entry);\r\n\r\n\trequestFlush();\r\n\r\n\treturn {\r\n\t\tcancel:()=>!!immediateQueue.removeNode(entry),\r\n\t\tdispose:()=>{ this.cancel(); }\r\n\t}\r\n}\r\n\r\n\r\n// runs a task after all other tasks have been run\r\n// this is useful for unhandled rejection tracking that needs to happen\r\n// after all `then`d tasks have been run.\r\nexport function runAfterDeferred(task:Closure):void\r\n{\r\n\tlaterQueue.enqueue(task);\r\n\trequestFlush();\r\n}\r\n\r\n\r\nif(Type.isObject(process)\r\n\t&& process.toString()===\"[object process]\"\r\n\t&& process.nextTick)\r\n{\r\n\t/*\r\n\tEnsure is in a real Node environment, with a `process.nextTick`.\r\n\tTo see through fake Node environments:\r\n\t* Mocha test runner - exposes a `process` global without a `nextTick`\r\n\t* Browserify - exposes a `process.nexTick` function that uses\r\n\t  `setTimeout`. In this case `setImmediate` is preferred because\r\n\t   it is faster. Browserify's `process.toString()` yields\r\n\t  \"[object Object]\", while in a real Node environment\r\n\t  `process.nextTick()` yields \"[object process]\".\r\n\t*/\r\n\tisNodeJS = true;\r\n\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tprocess.nextTick(flush);\r\n\t};\r\n\r\n}\r\nelse if(typeof setImmediate===\"function\")\r\n{\r\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\r\n\tif(typeof window!==\"undefined\")\r\n\t{\r\n\t\trequestTick = setImmediate.bind(window, flush);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestTick = ()=>\r\n\t\t{\r\n\t\t\tsetImmediate(flush);\r\n\t\t};\r\n\t}\r\n\r\n}\r\nelse if(typeof MessageChannel!==\"undefined\")\r\n{\r\n\t// modern browsers\r\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\r\n\tvar channel = new MessageChannel();\r\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\r\n\t// working message ports the first time a page loads.\r\n\tchannel.port1.onmessage = function()\r\n\t{\r\n\t\trequestTick = requestPortTick;\r\n\t\tchannel.port1.onmessage = flush;\r\n\t\tflush();\r\n\t};\r\n\tvar requestPortTick = ()=>\r\n\t{\r\n\t\t// Opera requires us to provide a message payload, regardless of\r\n\t\t// whether we use it.\r\n\t\tchannel.port2.postMessage(0);\r\n\t};\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t\trequestPortTick();\r\n\t};\r\n\r\n}\r\nelse\r\n{\r\n\t// old browsers\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t};\r\n}\r\n"]}