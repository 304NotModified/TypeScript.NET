{"version":3,"sources":["System/Integer.js","System/Integer.ts"],"names":["define","require","exports","ArgumentException_1","ArgumentOutOfRangeException_1","Integer","n","Math","floor","r","maxExclusive","random","assert","as32Bit","result","is","NUMBER","isFinite","is32Bit","argumentName","i","ArgumentException","assertZeroOrGreater","ArgumentOutOfRangeException","assertPositive","MAX_32_BIT","next","boundary","inclusive","abs","set","count","s","length","nextInRange","min","max","range","select","source","one","Object","defineProperty","value"],"mappings":"AAAAA,QAAQ,UAAW,UAAW,iCAAkC,4CAA6C,SAAUC,EAASC,EAASC,EAAqBC,GAC1J,YCOJ,SAAAC,GAAwBC,GAEvB,MAAOC,MAAKC,MAAMF,GAFnBJ,EAAAG,QAAAA,EAKA,SAAcA,GAIb,QAAAI,GAAWC,GAEV,MAAQH,MAAKI,SAASD,EAAgB,EAWvC,QAAAC,GAAuBD,GAGtB,MADAE,GAAOF,EAAc,gBACdD,EAAEC,GAgEV,QAAAG,GAAwBP,GAEvB,GAAMQ,GAAa,EAAJR,CACf,OAAQA,SAAWQ,OAAgBA,EAAS,KAU7C,QAAAC,GAAmBT,GAElB,aAAcA,KAAIU,GAAUC,SAASX,IAAMA,IAAIC,KAAKC,MAAMF,GAQ3D,QAAAY,GAAwBZ,GAEvB,MAAOA,MAAS,EAAJA,GAUb,QAAAM,GAAuBN,EAAUa,GAEhC,GAAIC,GAAIL,EAAGT,EACX,KAAIc,EACH,KAAM,IAAIjB,GAAAkB,kBAAkBF,GAAgB,IAAK,qBAClD,OAAOC,GASR,QAAAE,GAAoChB,EAAUa,GAE7C,GAAIC,GAAIR,EAAON,EAAGa,IAAiBb,GAAG,CACtC,KAAIc,EACH,KAAM,IAAIhB,GAAAmB,4BAA4BJ,GAAgB,IAAKb,EAAG,yDAC/D,OAAOc,GASR,QAAAI,GAA+BlB,EAAUa,GAExC,GAAIC,GAAIR,EAAON,EAAGa,IAAiBb,EAAE,CACrC,KAAIc,EACH,KAAM,IAAIhB,GAAAmB,4BAA4BJ,GAAgB,IAAKb,EAAG,6BAC/D,OAAOc,GAtJKf,EAAAoB,WAAoB,WAejBpB,EAAAM,OAAMA,EAMtB,SAAcA,GAEb,QAAAe,GACCC,EACAC,GAGA,MADAhB,GAAOe,EAAU,OACH,IAAXA,EAAqB,GACrBC,IAAWD,GAAYA,EAASpB,KAAKsB,IAAIF,IACrClB,EAAEkB,IAGV,QAAAG,GACCC,EACAJ,EACAC,GAEA,GAAMI,KACNA,GAAEC,OAASF,CACX,KAAI,GAAIX,GAAE,EAAEA,EAAEW,EAAMX,IACnBY,EAAEZ,GAAKM,EAAKC,EAASC,EAEtB,OAAOI,GAGR,QAAAE,GACCC,EACAC,EACAR,GAEAhB,EAAOuB,EAAK,OACZvB,EAAOwB,EAAK,MACZ,IAAIC,GAAQD,EAAMD,CAClB,OAAW,KAARE,EAAkBF,GAClBP,IAAWS,GAASA,EAAM9B,KAAKsB,IAAIQ,IAC/BF,EAAMT,EAAKW,IAGnB,QAAAC,GAA0BC,GAEzB,MAAOA,IAAUA,EAAON,OACrBM,EAAO9B,EAAE8B,EAAON,SAChB,OAxCYtB,EAAAe,KAAIA,EAUJf,EAAAmB,IAAGA,EAaHnB,EAAAuB,YAAWA,EAaXvB,EAAA2B,OAAMA,EAOtB,SAAcA,GAEb,QAAAE,GAAuBD,GAEtB,MAAO5B,GAAO2B,OAAOC,GAFND,EAAAE,IAAGA,GAFNF,EAAA3B,EAAA2B,SAAA3B,EAAA2B,aA7CD3B,EAAAN,EAAAM,SAAAN,EAAAM,YA6DEN,EAAAQ,QAAOA,CAMvB,IAAMG,GAAgB,QAONX,GAAAU,GAAEA,EAUFV,EAAAa,QAAOA,EAYPb,EAAAO,OAAMA,EAcNP,EAAAiB,oBAAmBA,EAcnBjB,EAAAmB,eAAcA,GAnJjBnB,EAAAH,EAAAG,UAAAH,EAAAG,aD2HVoC,OAAOC,eAAexC,EAAS,cAAgByC,OAAO,ICkC1DzC,EAAAA,WAAeG","file":"Integer.js","sourcesContent":["define([\"require\", \"exports\", \"./Exceptions/ArgumentException\", \"./Exceptions/ArgumentOutOfRangeException\"], function (require, exports, ArgumentException_1, ArgumentOutOfRangeException_1) {\n    \"use strict\";\n    function Integer(n) {\n        return Math.floor(n);\n    }\n    exports.Integer = Integer;\n    (function (Integer) {\n        Integer.MAX_32_BIT = 2147483647;\n        function r(maxExclusive) {\n            return (Math.random() * maxExclusive) | 0;\n        }\n        /**\n         * Returns a random integer from minInclusive to the maxExclusive.\n         * Negative numbers are allowed.\n         *\n         * @param maxExclusive\n         * @returns {number}\n         */\n        function random(maxExclusive) {\n            assert(maxExclusive, 'maxExclusive');\n            return r(maxExclusive);\n        }\n        Integer.random = random;\n        (function (random) {\n            function next(boundary, inclusive) {\n                assert(boundary, 'max');\n                if (boundary === 0)\n                    return 0;\n                if (inclusive)\n                    boundary += boundary / Math.abs(boundary);\n                return r(boundary);\n            }\n            random.next = next;\n            function set(count, boundary, inclusive) {\n                var s = [];\n                s.length = count;\n                for (var i = 0; i < count; i++) {\n                    s[i] = next(boundary, inclusive);\n                }\n                return s;\n            }\n            random.set = set;\n            function nextInRange(min, max, inclusive) {\n                assert(min, 'min');\n                assert(max, 'max');\n                var range = max - min;\n                if (range === 0)\n                    return min;\n                if (inclusive)\n                    range += range / Math.abs(range);\n                return min + next(range);\n            }\n            random.nextInRange = nextInRange;\n            function select(source) {\n                return source && source.length\n                    ? source[r(source.length)]\n                    : void (0);\n            }\n            random.select = select;\n            (function (select) {\n                function one(source) {\n                    return random.select(source);\n                }\n                select.one = one;\n            })(select = random.select || (random.select = {}));\n        })(random = Integer.random || (Integer.random = {}));\n        /**\n         * Converts any number to its 32bit counterpart.\n         * Returns null if conversion is not possible.\n         * @param n\n         * @returns {number}\n         */\n        function as32Bit(n) {\n            var result = n | 0;\n            return (n === -1 || result !== -1) ? result : null;\n        }\n        Integer.as32Bit = as32Bit;\n        var NUMBER = \"number\";\n        /**\n         * Returns true if the value is an integer.\n         * @param n\n         * @returns {boolean}\n         */\n        function is(n) {\n            return typeof n === NUMBER && isFinite(n) && n === Math.floor(n);\n        }\n        Integer.is = is;\n        /**\n         * Returns true if the value is within a 32 bit range.\n         * @param n\n         * @returns {boolean}\n         */\n        function is32Bit(n) {\n            return n === (n | 0);\n        }\n        Integer.is32Bit = is32Bit;\n        /**\n         * Throws if not an integer.\n         * @param n\n         * @param argumentName\n         * @returns {boolean}\n         */\n        function assert(n, argumentName) {\n            var i = is(n);\n            if (!i)\n                throw new ArgumentException_1.ArgumentException(argumentName || 'n', \"Must be a integer.\");\n            return i;\n        }\n        Integer.assert = assert;\n        /**\n         * Throws if less than zero.\n         * @param n\n         * @param argumentName\n         * @returns {boolean}\n         */\n        function assertZeroOrGreater(n, argumentName) {\n            var i = assert(n, argumentName) && n >= 0;\n            if (!i)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be a valid integer greater than or equal to zero.\");\n            return i;\n        }\n        Integer.assertZeroOrGreater = assertZeroOrGreater;\n        /**\n         * Throws if not greater than zero.\n         * @param n\n         * @param argumentName\n         * @returns {boolean}\n         */\n        function assertPositive(n, argumentName) {\n            var i = assert(n, argumentName) && n > 0;\n            if (!i)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be greater than zero.\");\n            return i;\n        }\n        Integer.assertPositive = assertPositive;\n    })(Integer = exports.Integer || (exports.Integer = {}));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Integer;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {ArgumentException} from \"./Exceptions/ArgumentException\";\r\nimport {ArgumentOutOfRangeException} from \"./Exceptions/ArgumentOutOfRangeException\";\r\nimport {IArray} from \"./Collections/Array/IArray\";\r\n\r\nexport function Integer(n:number):number\r\n{\r\n\treturn Math.floor(n);\r\n}\r\n\r\nexport module Integer\r\n{\r\n\texport const MAX_32_BIT:number = 2147483647;\r\n\r\n\tfunction r(maxExclusive:number):number\r\n\t{\r\n\t\treturn (Math.random()*maxExclusive) | 0;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a random integer from minInclusive to the maxExclusive.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param maxExclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function random(maxExclusive:number):number\r\n\t{\r\n\t\tassert(maxExclusive, 'maxExclusive');\r\n\t\treturn r(maxExclusive);\r\n\t}\r\n\r\n\texport module random\r\n\t{\r\n\t\texport function next(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(boundary, 'max');\r\n\t\t\tif(boundary===0) return 0;\r\n\t\t\tif(inclusive) boundary += boundary/Math.abs(boundary);\r\n\t\t\treturn r(boundary);\r\n\t\t}\r\n\r\n\t\texport function set(\r\n\t\t\tcount:number,\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):number[]\r\n\t\t{\r\n\t\t\tconst s:number[] = [];\r\n\t\t\ts.length = count;\r\n\t\t\tfor(let i=0;i<count;i++) {\r\n\t\t\t\ts[i] = next(boundary,inclusive);\r\n\t\t\t}\r\n\t\t\treturn s;\r\n\t\t}\r\n\r\n\t\texport function nextInRange(\r\n\t\t\tmin:number,\r\n\t\t\tmax:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(min, 'min');\r\n\t\t\tassert(max, 'max');\r\n\t\t\tlet range = max - min;\r\n\t\t\tif(range===0) return min;\r\n\t\t\tif(inclusive) range += range/Math.abs(range);\r\n\t\t\treturn min + next(range);\r\n\t\t}\r\n\r\n\t\texport function select<T>(source:IArray<T>):T|undefined\r\n\t\t{\r\n\t\t\treturn source && source.length\r\n\t\t\t\t? source[r(source.length)]\r\n\t\t\t\t: void(0);\r\n\t\t}\r\n\r\n\t\texport module select\r\n\t\t{\r\n\t\t\texport function one<T>(source:IArray<T>):T|undefined\r\n\t\t\t{\r\n\t\t\t\treturn random.select(source);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Converts any number to its 32bit counterpart.\r\n\t * Returns null if conversion is not possible.\r\n\t * @param n\r\n\t * @returns {number}\r\n\t */\r\n\texport function as32Bit(n:number):number|null\r\n\t{\r\n\t\tconst result = n | 0;\r\n\t\treturn (n=== -1 || result!== -1) ? result : null;\r\n\t}\r\n\r\n\tconst NUMBER:string = \"number\";\r\n\r\n\t/**\r\n\t * Returns true if the value is an integer.\r\n\t * @param n\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function is(n:number):boolean\r\n\t{\r\n\t\treturn typeof n===NUMBER && isFinite(n) && n===Math.floor(n);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the value is within a 32 bit range.\r\n\t * @param n\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function is32Bit(n:number):boolean\r\n\t{\r\n\t\treturn n===(n | 0);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Throws if not an integer.\r\n\t * @param n\r\n\t * @param argumentName\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function assert(n:number, argumentName?:string):true|never\r\n\t{\r\n\t\tlet i = is(n);\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentException(argumentName || 'n', \"Must be a integer.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n\t/**\r\n\t * Throws if less than zero.\r\n\t * @param n\r\n\t * @param argumentName\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function assertZeroOrGreater(n:number, argumentName?:string):true|never\r\n\t{\r\n\t\tlet i = assert(n, argumentName) && n>=0;\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be a valid integer greater than or equal to zero.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n\t/**\r\n\t * Throws if not greater than zero.\r\n\t * @param n\r\n\t * @param argumentName\r\n\t * @returns {boolean}\r\n\t */\r\n\texport function assertPositive(n:number, argumentName?:string):true|never\r\n\t{\r\n\t\tlet i = assert(n, argumentName) && n>0;\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be greater than zero.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n}\r\n\r\nexport default Integer;\r\n"]}