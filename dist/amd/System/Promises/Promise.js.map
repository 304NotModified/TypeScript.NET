{"version":3,"sources":["System/Promises/Promise.js","System/Promises/Promise.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","define","require","exports","Types_1","deferImmediate_1","DisposableBase_1","InvalidOperationException_1","ArgumentException_1","ArgumentNullException_1","ObjectPool_1","Set_1","defer_1","isPromise","value","hasMemberOfType","THEN","FUNCTION","resolve","resolver","promiseFactory","nextValue","Promise","wrap","handleResolution","v","ex","reject","handleResolutionMethods","targetFulfill","targetReject","handleDispatch","onFulfilled","onRejected","PromiseBase","thenThis","then","VOID0","PROMISE","PROMISE_STATE","TARGET","PromiseState","_super","_state","_result","_error","call","_disposableObjectName","_onDispose","getState","defineProperty","get","enumerable","configurable","State","Pending","Fulfilled","Rejected","getResult","throwIfDisposed","getError","DisposableBase","_this","result","error","delayFromNow","milliseconds","defer","e","delayAfterResolve","isSettled","fin","finallyThis","f","deferImmediate","Resolvable","apply","arguments","thenSynchronous","state","Error","Resolved","PromiseWrapper","_target","ArgumentNullException","ArgumentException","t","forceSynchronous","resolveUsing","_waiting","push","pools","PromiseCallbacks","init","_resolvedCalled","throwIfSettled","InvalidOperationException","rejectHandler","reason","console","warn","fulfillHandler","r","o","_i","o_1","length","c","promise","recycle","o_2","getPool","pool","ObjectPool","factory","take","add","all","first","rest","promises","Array","isArray","concat","every","len","remaining","Set","map","i","cleanup","dispose","checkIfShouldResolve","count","onFulfill","remove","onReject","_loop_1","waitAll","onResolved","_loop_2","race","filter","onResolve","promises_1","p_1","target","createFrom","freeze"],"mappings":"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","file":"System/Promises/Promise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n * Although most of the following code is written from scratch, it is\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\ndefine([\"require\", \"exports\", \"../Types\", \"../Threading/deferImmediate\", \"../Disposable/DisposableBase\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentException\", \"../Exceptions/ArgumentNullException\", \"../Disposable/ObjectPool\", \"../Collections/Set\", \"../Threading/defer\"], function (require, exports, Types_1, deferImmediate_1, DisposableBase_1, InvalidOperationException_1, ArgumentException_1, ArgumentNullException_1, ObjectPool_1, Set_1, defer_1) {\n    \"use strict\";\n    var VOID0 = void 0, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\n    function isPromise(value) {\n        return Types_1.default.hasMemberOfType(value, THEN, Types_1.default.FUNCTION);\n    }\n    function resolve(value, resolver, promiseFactory) {\n        var nextValue = resolver\n            ? resolver(value)\n            : value;\n        return nextValue && isPromise(nextValue)\n            ? Promise.wrap(nextValue)\n            : promiseFactory(nextValue);\n    }\n    function handleResolution(p, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (p)\n                p.resolve(v);\n        }\n        catch (ex) {\n            p.reject(ex);\n        }\n    }\n    function handleResolutionMethods(targetFulfill, targetReject, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (targetFulfill)\n                targetFulfill(v);\n        }\n        catch (ex) {\n            if (targetReject)\n                targetReject(ex);\n        }\n    }\n    function handleDispatch(p, onFulfilled, onRejected) {\n        if (p instanceof PromiseBase)\n            p.thenThis(onFulfilled, onRejected);\n        else\n            p.then(onFulfilled, onRejected);\n    }\n    var PromiseState = (function (_super) {\n        __extends(PromiseState, _super);\n        function PromiseState(_state, _result, _error) {\n            _super.call(this);\n            this._state = _state;\n            this._result = _result;\n            this._error = _error;\n            this._disposableObjectName = PROMISE_STATE;\n        }\n        PromiseState.prototype._onDispose = function () {\n            this._state = VOID0;\n            this._result = VOID0;\n            this._error = VOID0;\n        };\n        PromiseState.prototype.getState = function () {\n            return this._state;\n        };\n        Object.defineProperty(PromiseState.prototype, \"state\", {\n            get: function () {\n                return this._state;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isPending\", {\n            get: function () {\n                return this.getState() === Promise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isSettled\", {\n            get: function () {\n                return this.getState() != Promise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isFulfilled\", {\n            get: function () {\n                return this.getState() === Promise.State.Fulfilled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isRejected\", {\n            get: function () {\n                return this.getState() === Promise.State.Rejected;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getResult = function () {\n            return this._result;\n        };\n        Object.defineProperty(PromiseState.prototype, \"result\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getResult();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getError = function () {\n            return this._error;\n        };\n        Object.defineProperty(PromiseState.prototype, \"error\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getError();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return PromiseState;\n    }(DisposableBase_1.DisposableBase));\n    exports.PromiseState = PromiseState;\n    var PromiseBase = (function (_super) {\n        __extends(PromiseBase, _super);\n        function PromiseBase() {\n            _super.call(this, Promise.State.Pending);\n            this._disposableObjectName = PROMISE;\n        }\n        PromiseBase.prototype.then = function (onFulfilled, onRejected) {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                _this.thenThis(function (result) { return handleResolutionMethods(resolve, reject, result, onFulfilled); }, function (error) { return onRejected\n                    ? handleResolutionMethods(resolve, null, error, onRejected)\n                    : reject(error); });\n            });\n        };\n        PromiseBase.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            return new Promise(function (resolve, reject) {\n                defer_1.defer(function () {\n                    _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                }, milliseconds);\n            }, true);\n        };\n        PromiseBase.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (this.isSettled)\n                return this.delayFromNow(milliseconds);\n            return new Promise(function (resolve, reject) {\n                _this.thenThis(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n            }, true);\n        };\n        PromiseBase.prototype['catch'] = function (onRejected) {\n            this.throwIfDisposed();\n            return this.then(VOID0, onRejected);\n        };\n        PromiseBase.prototype['finally'] = function (fin) {\n            this.throwIfDisposed();\n            return this.then(fin, fin);\n        };\n        PromiseBase.prototype.finallyThis = function (fin) {\n            this.throwIfDisposed();\n            var f = function () { return deferImmediate_1.deferImmediate(fin); };\n            this.thenThis(f, f);\n            return this;\n        };\n        return PromiseBase;\n    }(PromiseState));\n    exports.PromiseBase = PromiseBase;\n    var Resolvable = (function (_super) {\n        __extends(Resolvable, _super);\n        function Resolvable() {\n            _super.apply(this, arguments);\n        }\n        Resolvable.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            try {\n                switch (this.state) {\n                    case Promise.State.Fulfilled:\n                        return onFulfilled\n                            ? resolve(this._result, onFulfilled, Promise.resolve)\n                            : this;\n                    case Promise.State.Rejected:\n                        return onRejected\n                            ? resolve(this._error, onRejected, Promise.resolve)\n                            : this;\n                }\n            }\n            catch (ex) {\n                return new Rejected(ex);\n            }\n            throw new Error(\"Invalid state for a resolved promise.\");\n        };\n        Resolvable.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            switch (this.state) {\n                case Promise.State.Fulfilled:\n                    if (onFulfilled)\n                        onFulfilled(this._result);\n                    break;\n                case Promise.State.Rejected:\n                    if (onRejected)\n                        onRejected(this._error);\n                    break;\n            }\n            return this;\n        };\n        return Resolvable;\n    }(PromiseBase));\n    exports.Resolvable = Resolvable;\n    var Resolved = (function (_super) {\n        __extends(Resolved, _super);\n        function Resolved(state, result, error) {\n            _super.call(this);\n            this._result = result;\n            this._error = error;\n            this._state = state;\n        }\n        return Resolved;\n    }(Resolvable));\n    exports.Resolved = Resolved;\n    var Fulfilled = (function (_super) {\n        __extends(Fulfilled, _super);\n        function Fulfilled(value) {\n            _super.call(this, Promise.State.Fulfilled, value);\n        }\n        return Fulfilled;\n    }(Resolved));\n    var Rejected = (function (_super) {\n        __extends(Rejected, _super);\n        function Rejected(error) {\n            _super.call(this, Promise.State.Rejected, VOID0, error);\n        }\n        return Rejected;\n    }(Resolved));\n    var PromiseWrapper = (function (_super) {\n        __extends(PromiseWrapper, _super);\n        function PromiseWrapper(_target) {\n            var _this = this;\n            _super.call(this);\n            this._target = _target;\n            if (!_target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            if (!isPromise(_target))\n                throw new ArgumentException_1.ArgumentException(TARGET, \"Must be a promise-like object.\");\n            _target.then(function (v) {\n                _this._state = Promise.State.Fulfilled;\n                _this._result = v;\n                _this._error = VOID0;\n                _this._target = VOID0;\n            }, function (e) {\n                _this._state = Promise.State.Rejected;\n                _this._error = e;\n                _this._target = VOID0;\n            });\n        }\n        PromiseWrapper.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n            return new Promise(function (resolve, reject) {\n                handleDispatch(t, function (result) { return handleResolutionMethods(resolve, reject, result, onFulfilled); }, function (error) { return onRejected\n                    ? handleResolutionMethods(resolve, null, error, onRejected)\n                    : reject(error); });\n            }, true);\n        };\n        PromiseWrapper.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n            handleDispatch(t, onFulfilled, onRejected);\n            return this;\n        };\n        PromiseWrapper.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._target = VOID0;\n        };\n        return PromiseWrapper;\n    }(Resolvable));\n    var Promise = (function (_super) {\n        __extends(Promise, _super);\n        function Promise(resolver, forceSynchronous) {\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            _super.call(this);\n            if (resolver)\n                this.resolveUsing(resolver, forceSynchronous);\n        }\n        Promise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            if (this._state)\n                return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n            var p = new Promise();\n            (this._waiting || (this._waiting = []))\n                .push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\n            return p;\n        };\n        Promise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            if (this._state)\n                return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n            (this._waiting || (this._waiting = []))\n                .push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\n            return this;\n        };\n        Promise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolvedCalled = VOID0;\n        };\n        Promise.prototype.resolveUsing = function (resolver, forceSynchronous, throwIfSettled) {\n            var _this = this;\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            if (!resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            if (this._resolvedCalled)\n                throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n            if (this.state)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\n            this._resolvedCalled = true;\n            var state = 0;\n            var rejectHandler = function (reason) {\n                if (state) {\n                    console.warn(state == -1 ? \"Rejection called multiple times\" : \"Rejection called after fulfilled.\");\n                }\n                else {\n                    state = -1;\n                    _this._resolvedCalled = false;\n                    _this.reject(reason);\n                }\n            };\n            var fulfillHandler = function (v) {\n                if (state) {\n                    console.warn(state == 1 ? \"Fulfill called multiple times\" : \"Fulfill called after rejection.\");\n                }\n                else {\n                    state = 1;\n                    _this._resolvedCalled = false;\n                    _this.resolve(v);\n                }\n            };\n            var r = function () { return resolver(function (v) {\n                if (v == _this)\n                    throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n                if (isPromise(v))\n                    handleDispatch(v, fulfillHandler, rejectHandler);\n                else {\n                    fulfillHandler(v);\n                }\n            }, rejectHandler); };\n            if (forceSynchronous)\n                r();\n            else\n                deferImmediate_1.deferImmediate(r);\n        };\n        Promise.prototype.resolve = function (result, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (result == this)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n            if (this._state) {\n                if (!throwIfSettled || this._state == Promise.State.Fulfilled && this._result === result)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._state = Promise.State.Fulfilled;\n            this._result = result;\n            this._error = VOID0;\n            var o = this._waiting;\n            if (o) {\n                this._waiting = VOID0;\n                for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n                    var c = o_1[_i];\n                    var onFulfilled = c.onFulfilled, promise = c.promise, p = promise;\n                    pools.PromiseCallbacks.recycle(c);\n                    handleResolution(p, result, onFulfilled);\n                }\n                o.length = 0;\n            }\n        };\n        Promise.prototype.reject = function (error, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (this._state) {\n                if (!throwIfSettled || this._state == Promise.State.Rejected && this._error === error)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._state = Promise.State.Rejected;\n            this._error = error;\n            var o = this._waiting;\n            if (o) {\n                this._waiting = null;\n                for (var _i = 0, o_2 = o; _i < o_2.length; _i++) {\n                    var c = o_2[_i];\n                    var onRejected = c.onRejected, promise = c.promise, p = promise;\n                    pools.PromiseCallbacks.recycle(c);\n                    if (onRejected)\n                        handleResolution(p, error, onRejected);\n                    else\n                        p.reject(error);\n                }\n                o.length = 0;\n            }\n        };\n        return Promise;\n    }(Resolvable));\n    exports.Promise = Promise;\n    var pools;\n    (function (pools) {\n        var PromiseCallbacks;\n        (function (PromiseCallbacks) {\n            var pool;\n            function getPool() {\n                return pool\n                    || (pool = new ObjectPool_1.ObjectPool(40, factory, function (c) {\n                        c.onFulfilled = null;\n                        c.onRejected = null;\n                        c.promise = null;\n                    }));\n            }\n            function factory() {\n                return {\n                    onFulfilled: null,\n                    onRejected: null,\n                    promise: null\n                };\n            }\n            function init(onFulfilled, onRejected, promise) {\n                var c = getPool().take();\n                c.onFulfilled = onFulfilled;\n                c.onRejected = onRejected;\n                c.promise = promise;\n                return c;\n            }\n            PromiseCallbacks.init = init;\n            function recycle(c) {\n                getPool().add(c);\n            }\n            PromiseCallbacks.recycle = recycle;\n        })(PromiseCallbacks = pools.PromiseCallbacks || (pools.PromiseCallbacks = {}));\n    })(pools || (pools = {}));\n    var Promise;\n    (function (Promise) {\n        (function (State) {\n            State[State[\"Pending\"] = 0] = \"Pending\";\n            State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n            State[State[\"Rejected\"] = -1] = \"Rejected\";\n        })(Promise.State || (Promise.State = {}));\n        var State = Promise.State;\n        Object.freeze(State);\n        function all(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new Fulfilled(promises);\n            return new Promise(function (resolve, reject) {\n                var checkedAll = false;\n                var result = [];\n                var len = promises.length;\n                result.length = len;\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; }));\n                var cleanup = function () {\n                    reject = null;\n                    resolve = null;\n                    promises.length = 0;\n                    promises = null;\n                    remaining.dispose();\n                    remaining = null;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(result);\n                    }\n                };\n                var onFulfill = function (v, i) {\n                    if (resolve) {\n                        result[i] = v;\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var onReject = function (e) {\n                    var r = reject;\n                    if (r) {\n                        cleanup();\n                        r(e);\n                    }\n                };\n                var _loop_1 = function(i) {\n                    var p = promises[i];\n                    if (p)\n                        p.then(function (v) { return onFulfill(v, i); }, onReject);\n                    else\n                        remaining.remove(i);\n                    checkIfShouldResolve();\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_1(i);\n                }\n            });\n        }\n        Promise.all = all;\n        function waitAll(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new Fulfilled(promises);\n            return new Promise(function (resolve, reject) {\n                var checkedAll = false;\n                var len = promises.length;\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; }));\n                var cleanup = function () {\n                    reject = null;\n                    resolve = null;\n                    remaining.dispose();\n                    remaining = null;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(promises);\n                    }\n                };\n                var onResolved = function (i) {\n                    if (remaining) {\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var _loop_2 = function(i) {\n                    var p = promises[i];\n                    if (p)\n                        p.then(function (v) { return onResolved(i); }, function (e) { return onResolved(i); });\n                    else\n                        onResolved(i);\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_2(i);\n                }\n            });\n        }\n        Promise.waitAll = waitAll;\n        function race(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            var promises = first && (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises || !promises.length || !(promises = promises.filter(function (v) { return v != null; })).length)\n                throw new ArgumentException_1.ArgumentException(\"Nothing to wait for.\");\n            var len = promises.length;\n            if (len == 1)\n                return wrap(promises[0]);\n            for (var i = 0; i < len; i++) {\n                var p = promises[i];\n                if (p instanceof PromiseBase && p.isSettled)\n                    return p;\n            }\n            return new Promise(function (resolve, reject) {\n                var cleanup = function () {\n                    reject = null;\n                    resolve = null;\n                    promises.length = 0;\n                    promises = null;\n                };\n                var onResolve = function (r, v) {\n                    if (r) {\n                        cleanup();\n                        r(v);\n                    }\n                };\n                var onFulfill = function (v) { return onResolve(resolve, v); };\n                var onReject = function (e) { return onResolve(reject, e); };\n                for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {\n                    var p_1 = promises_1[_i];\n                    if (!resolve)\n                        break;\n                    p_1.then(onFulfill, onReject);\n                }\n            });\n        }\n        Promise.race = race;\n        function resolve(value) {\n            return isPromise(value) ? wrap(value) : new Fulfilled(value);\n        }\n        Promise.resolve = resolve;\n        function reject(reason) {\n            return new Rejected(reason);\n        }\n        Promise.reject = reject;\n        function wrap(target) {\n            if (!target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            return target instanceof Promise ? this : new PromiseWrapper(target);\n        }\n        Promise.wrap = wrap;\n        function createFrom(then) {\n            if (!then)\n                throw new ArgumentNullException_1.ArgumentNullException(THEN);\n            return new PromiseWrapper({ then: then });\n        }\n        Promise.createFrom = createFrom;\n    })(Promise = exports.Promise || (exports.Promise = {}));\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n * Although most of the following code is written from scratch, it is\r\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\r\n */\r\n\r\n/*\r\n * Note: The Promise herein does NOT defer by default.\r\n * If you require a promise to defer its result then use the .defer() or .delay(ms) methods.\r\n * The API attempts to follow ES6 style promises.\r\n */\r\n\r\nimport Type from \"../Types\";\r\nimport {deferImmediate} from \"../Threading/deferImmediate\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\nimport {Set} from \"../Collections/Set\";\r\nimport {defer} from \"../Threading/defer\";\r\n\r\n\r\nconst VOID0:any = void 0, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\r\n\r\nfunction isPromise<T>(value:any):value is PromiseLike<T>\r\n{\r\n\treturn Type.hasMemberOfType(value, THEN, Type.FUNCTION);\r\n}\r\n\r\nfunction resolve<T>(\r\n\tvalue:Promise.Resolution<T>, resolver:(v:Promise.Resolution<T>)=>any,\r\n\tpromiseFactory:(v:any)=>PromiseBase<any>):PromiseBase<any>\r\n{\r\n\tlet nextValue = resolver\r\n\t\t? resolver(value)\r\n\t\t: value;\r\n\r\n\treturn nextValue && isPromise(nextValue)\r\n\t\t? Promise.wrap(nextValue)\r\n\t\t: promiseFactory(nextValue);\r\n}\r\n\r\nfunction handleResolution(\r\n\tp:Promise<any>,\r\n\tvalue:Promise.Resolution<any>,\r\n\tresolver?:(v:Promise.Resolution<any>)=>any):void\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(p) p.resolve(v);\r\n\t}\r\n\tcatch(ex)\r\n\t{ p.reject(ex); }\r\n}\r\n\r\nfunction handleResolutionMethods(\r\n\ttargetFulfill:Promise.Fulfill<any,any>,\r\n\ttargetReject:Promise.Reject<any>,\r\n\tvalue:Promise.Resolution<any>,\r\n\tresolver?:(v:Promise.Resolution<any>)=>any):void\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(targetFulfill) targetFulfill(v);\r\n\t}\r\n\tcatch(ex)\r\n\t{ if(targetReject) targetReject(ex); }\r\n}\r\n\r\nfunction handleDispatch<T,TResult>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\tonRejected?:Promise.Reject<TResult>):void\r\n{\r\n\tif(p instanceof PromiseBase)\r\n\t\tp.thenThis(onFulfilled, onRejected);\r\n\telse\r\n\t\tp.then(<any>onFulfilled, onRejected);\r\n}\r\n\r\nexport class PromiseState<T>\r\nextends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tprotected _state:Promise.State,\r\n\t\tprotected _result?:T,\r\n\t\tprotected _error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = PROMISE_STATE;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._state = VOID0;\r\n\t\tthis._result = VOID0;\r\n\t\tthis._error = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget state():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget isPending():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Pending;\r\n\t}\r\n\r\n\tget isSettled():boolean\r\n\t{\r\n\t\treturn this.getState()!=Promise.State.Pending; // Will also include undefined==0 aka disposed!=resolved.\r\n\t}\r\n\r\n\tget isFulfilled():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Fulfilled;\r\n\t}\r\n\r\n\tget isRejected():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Rejected;\r\n\t}\r\n\r\n\t/*\r\n\t * Providing overrides allows for special defer or lazy sub classes.\r\n\t */\r\n\tprotected getResult():T\r\n\t{\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tget result():T\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getResult();\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class PromiseBase<T>\r\nextends PromiseState<T> implements PromiseLike<T>\r\n{\r\n\tconstructor()\r\n\t{\r\n\t\tsuper(Promise.State.Pending);\r\n\t\tthis._disposableObjectName = PROMISE;\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the respective handlers once the promise is resolved.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>;\r\n\r\n\t/**\r\n\t * Same as 'thenSynchronous' but does not return the result.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * Errors are not trapped.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>;\r\n\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn new Promise<TResult>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tthis.thenThis(\r\n\t\t\t\tresult=>handleResolutionMethods(resolve, reject, result, onFulfilled),\r\n\t\t\t\terror=>onRejected\r\n\t\t\t\t\t? handleResolutionMethods(resolve, null, error, onRejected)\r\n\t\t\t\t\t: reject(error)\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new Promise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\tdefer(()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e));\r\n\t\t\t\t}, milliseconds)\r\n\t\t\t},\r\n\t\t\ttrue // Since the resolve/reject is deferred.\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(this.isSettled) return this.delayFromNow(milliseconds);\r\n\r\n\t\treturn new Promise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\tthis.thenThis(\r\n\t\t\t\t\tv=>defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\te=>defer(()=>reject(e), milliseconds))\r\n\t\t\t},\r\n\t\t\ttrue // Since the resolve/reject is deferred.\r\n\t\t);\r\n\t}\r\n\r\n\t'catch'<TResult>(onRejected:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.then(VOID0, onRejected)\r\n\t}\r\n\r\n\t'finally'<TResult>(fin:()=>Promise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.then(fin, fin);\r\n\t}\r\n\r\n\tfinallyThis(fin:()=>void):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tvar f = ()=>deferImmediate(fin);\r\n\t\tthis.thenThis(f, f);\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class Resolvable<T> extends PromiseBase<T>\r\n{\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tswitch(this.state)\r\n\t\t\t{\r\n\t\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\t\treturn onFulfilled\r\n\t\t\t\t\t\t? resolve(this._result, onFulfilled, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this; // Provided for catch cases.\r\n\t\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\t\treturn onRejected\r\n\t\t\t\t\t\t? resolve(this._error, onRejected, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn new Rejected<any>(ex);\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Invalid state for a resolved promise.\");\r\n\t}\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tswitch(this.state)\r\n\t\t{\r\n\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\tif(onFulfilled) onFulfilled(this._result);\r\n\t\t\t\tbreak;\r\n\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\tif(onRejected) onRejected(this._error);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The simplest usable version of a promise which returns synchronously the resolved state provided.\r\n */\r\nexport abstract class Resolved<T> extends Resolvable<T>\r\n{\r\n\tconstructor(state:Promise.State, result:T, error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._result = result;\r\n\t\tthis._error = error;\r\n\t\tthis._state = state;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * A fulfilled Resolved<T>.  Provided for readability.\r\n */\r\nclass Fulfilled<T> extends Resolved<T>\r\n{\r\n\tconstructor(value?:T)\r\n\t{\r\n\t\tsuper(Promise.State.Fulfilled, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * A rejected Resolved<T>.  Provided for readability.\r\n */\r\nclass Rejected<T> extends Resolved<T>\r\n{\r\n\tconstructor(error:any)\r\n\t{\r\n\t\tsuper(Promise.State.Rejected, VOID0, error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Provided as a means for extending the interface of other PromiseLike<T> objects.\r\n */\r\nclass PromiseWrapper<T> extends Resolvable<T>\r\n{\r\n\tconstructor(private _target:PromiseLike<T>)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(!_target)\r\n\t\t\tthrow new ArgumentNullException(TARGET);\r\n\r\n\t\tif(!isPromise(_target))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be a promise-like object.\");\r\n\r\n\t\t_target.then(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Fulfilled;\r\n\t\t\t\tthis._result = v;\r\n\t\t\t\tthis._error = VOID0;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t},\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Rejected;\r\n\t\t\t\tthis._error = e;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t})\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.thenSynchronous(onFulfilled, onRejected);\r\n\r\n\t\treturn new Promise<TResult>((resolve, reject)=>\r\n\t\t{\r\n\t\t\thandleDispatch(t,\r\n\t\t\t\tresult=>handleResolutionMethods(resolve, reject, result, onFulfilled),\r\n\t\t\t\terror=>onRejected\r\n\t\t\t\t\t? handleResolutionMethods(resolve, null, error, onRejected)\r\n\t\t\t\t\t: reject(error)\r\n\t\t\t);\r\n\t\t}, true);\r\n\t}\r\n\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.thenThis(onFulfilled, onRejected);\r\n\t\thandleDispatch(t, onFulfilled, onRejected);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._target = VOID0;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * This promise class that facilitates pending resolution.\r\n */\r\nexport class Promise<T> extends Resolvable<T>\r\n{\r\n\r\n\tprivate _waiting:IPromiseCallbacks<any>[];\r\n\r\n\t/*\r\n\t * A note about deferring:\r\n\t * The caller can set resolveImmediate to true if they intend to initialize code that will end up being deferred itself.\r\n\t * This eliminates the extra defer that will occur internally.\r\n\t * But for the most part, resolveImmediate = false (the default) will ensure the constructor will not block.\r\n\t *\r\n\t * resolveUsing allows for the same ability but does not defer by default: allowing the caller to take on the work load.\r\n\t * If calling resolve or reject and a deferred response is desired, then use deferImmediate with a closure to do so.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tresolver?:Promise.Executor<T>, forceSynchronous:boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(resolver) this.resolveUsing(resolver, forceSynchronous);\r\n\t}\r\n\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.thenSynchronous(onFulfilled, onRejected);\r\n\r\n\t\tvar p = new Promise<TResult>();\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.thenThis(onFulfilled, onRejected);\r\n\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolvedCalled = VOID0;\r\n\t}\r\n\r\n\t// Protects against double calling.\r\n\tprotected _resolvedCalled:boolean;\r\n\r\n\tresolveUsing(\r\n\t\tresolver:Promise.Executor<T>,\r\n\t\tforceSynchronous:boolean = false,\r\n\t\tthrowIfSettled:boolean = false)\r\n\t{\r\n\t\tif(!resolver)\r\n\t\t\tthrow new ArgumentNullException(\"resolver\");\r\n\t\tif(this._resolvedCalled)\r\n\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\tif(this.state)\r\n\t\t\tthrow new InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\r\n\r\n\t\tthis._resolvedCalled = true;\r\n\r\n\t\tvar state = 0;\r\n\t\tvar rejectHandler = (reason:any)=>\r\n\t\t{\r\n\t\t\tif(state) {\r\n\t\t\t\tconsole.warn(state==-1?\"Rejection called multiple times\":\"Rejection called after fulfilled.\");\r\n\t\t\t} else {\r\n\t\t\t\tstate = -1;\r\n\t\t\t\tthis._resolvedCalled = false;\r\n\t\t\t\tthis.reject(reason);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar fulfillHandler = (v:any)=>\r\n\t\t{\r\n\t\t\tif(state) {\r\n\t\t\t\tconsole.warn(state==1?\"Fulfill called multiple times\":\"Fulfill called after rejection.\");\r\n\t\t\t} else {\r\n\t\t\t\tstate = 1;\r\n\t\t\t\tthis._resolvedCalled = false;\r\n\t\t\t\tthis.resolve(v);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar r = ()=> resolver(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tif(v==this) throw new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\t\t\t\tif(isPromise(v)) // If the result is a promise, then it will defer downstream.\r\n\t\t\t\t\thandleDispatch(v, fulfillHandler, rejectHandler);\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tfulfillHandler(v);\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\t\t\trejectHandler);\r\n\r\n\t\t// There are some performance edge cases where there caller is not blocking upstream and does not need to defer.\r\n\t\tif(forceSynchronous)\r\n\t\t\tr();\r\n\t\telse\r\n\t\t\tdeferImmediate(r);\r\n\r\n\r\n\t}\r\n\r\n\tresolve(result?:T, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(<any>result==this)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Fulfilled && this._result===result) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._state = Promise.State.Fulfilled;\r\n\r\n\t\tthis._result = result;\r\n\t\tthis._error = VOID0;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = VOID0;\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onFulfilled, promise} = c, p = (<Promise<T>>promise);\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\thandleResolution(p, result, onFulfilled);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\treject(error:any, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Rejected && this._error===error) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._state = Promise.State.Rejected;\r\n\r\n\t\tthis._error = error;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = null; // null = finished. undefined = hasn't started.\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onRejected, promise} = c, p = (<Promise<T>>promise);\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\tif(onRejected) handleResolution(p, error, onRejected);\r\n\t\t\t\telse p.reject(error);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nmodule pools\r\n{\r\n\r\n\t// export module pending\r\n\t// {\r\n\t//\r\n\t//\r\n\t// \tvar pool:ObjectPool<Promise<any>>;\r\n\t//\r\n\t// \tfunction getPool()\r\n\t// \t{\r\n\t// \t\treturn pool || (pool = new ObjectPool<Promise<any>>(40, factory, c=>c.dispose()));\r\n\t// \t}\r\n\t//\r\n\t// \tfunction factory():Promise<any>\r\n\t// \t{\r\n\t// \t\treturn new Promise();\r\n\t// \t}\r\n\t//\r\n\t// \texport function get():Promise<any>\r\n\t// \t{\r\n\t// \t\tvar p:any = getPool().take();\r\n\t// \t\tp.__wasDisposed = false;\r\n\t// \t\tp._state = Promise.State.Pending;\r\n\t// \t\treturn p;\r\n\t// \t}\r\n\t//\r\n\t// \texport function recycle<T>(c:Promise<T>):void\r\n\t// \t{\r\n\t// \t\tif(c) getPool().add(c);\r\n\t// \t}\r\n\t//\r\n\t// }\r\n\t//\r\n\t// export function recycle<T>(c:PromiseBase<T>):void\r\n\t// {\r\n\t// \tif(!c) return;\r\n\t// \tif(c instanceof Promise && c.constructor==Promise) pending.recycle(c);\r\n\t// \telse c.dispose();\r\n\t// }\r\n\r\n\r\n\texport module PromiseCallbacks\r\n\t{\r\n\r\n\t\tvar pool:ObjectPool<IPromiseCallbacks<any>>;\r\n\r\n\t\tfunction getPool()\r\n\t\t{\r\n\t\t\treturn pool\r\n\t\t\t\t|| (pool = new ObjectPool<IPromiseCallbacks<any>>(40, factory, c=>\r\n\t\t\t\t{\r\n\t\t\t\t\tc.onFulfilled = null;\r\n\t\t\t\t\tc.onRejected = null;\r\n\t\t\t\t\tc.promise = null;\r\n\t\t\t\t}));\r\n\t\t}\r\n\r\n\t\tfunction factory():IPromiseCallbacks<any>\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tonFulfilled: null,\r\n\t\t\t\tonRejected: null,\r\n\t\t\t\tpromise: null\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\texport function init<T>(\r\n\t\t\tonFulfilled:Promise.Fulfill<T,any>,\r\n\t\t\tonRejected?:Promise.Reject<any>,\r\n\t\t\tpromise?:PromiseLike<any>):IPromiseCallbacks<T>\r\n\t\t{\r\n\r\n\t\t\tvar c = getPool().take();\r\n\t\t\tc.onFulfilled = onFulfilled;\r\n\t\t\tc.onRejected = onRejected;\r\n\t\t\tc.promise = promise;\r\n\t\t\treturn c;\r\n\t\t}\r\n\r\n\t\texport function recycle<T>(c:IPromiseCallbacks<T>):void\r\n\t\t{\r\n\t\t\tgetPool().add(c);\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport module Promise\r\n{\r\n\r\n\t/**\r\n\t * The state of a promise.\r\n\t * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\r\n\t * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.\r\n\t */\r\n\texport enum State {\r\n\t\tPending   = 0,\r\n\t\tFulfilled = 1,\r\n\t\tRejected  = -1\r\n\t}\r\n\tObject.freeze(State);\r\n\r\n\texport type Resolution<TResult> = PromiseLike<TResult>|TResult|void;\r\n\r\n\texport interface Fulfill<T, TResult>\r\n\t{\r\n\t\t(value:T):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Reject<TResult>\r\n\t{\r\n\t\t(err?:any):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Then<T,TResult>\r\n\t{\r\n\t\t(\r\n\t\t\tonFulfilled:Fulfill<T,TResult>,\r\n\t\t\tonRejected?:Reject<TResult>):PromiseBase<TResult>\r\n\t}\r\n\r\n\texport interface Executor<T>\r\n\t{\r\n\t\t(\r\n\t\t\tresolve:(value?:T | PromiseLike<T>) => void,\r\n\t\t\treject:(reason?:any) => void):void;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t */\r\n\texport function all<T>(promises:PromiseLike<T>[]):PromiseBase<T[]>\r\n\texport function all<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T[]>\r\n\texport function all(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any[]>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tvar promises = (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v=>!v)) return new Fulfilled<any[]>(promises); // it's a new empty, reuse it. :|\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\treturn new Promise<any[]>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet checkedAll = false;\r\n\t\t\tlet result:any[] = [];\r\n\t\t\tlet len = promises.length;\r\n\t\t\tresult.length = len;\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i)=>i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = null;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = ()=>\r\n\t\t\t{\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(result);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any, i:number)=>\r\n\t\t\t{\r\n\t\t\t\tif(resolve)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = v;\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onReject = (e?:any)=>\r\n\t\t\t{\r\n\t\t\t\tlet r = reject;\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(e);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v=>onFulfill(v, i), onReject);\r\n\t\t\t\telse remaining.remove(i);\r\n\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).\r\n\t * Unlike .all this method waits for all rejections as well as fulfillment.\r\n\t */\r\n\texport function waitAll<T>(promises:PromiseLike<T>[]):PromiseBase<PromiseLike<T>[]>\r\n\texport function waitAll<T>(\r\n\t\tpromise:PromiseLike<T>,\r\n\t\t...rest:PromiseLike<T>[]):PromiseBase<PromiseLike<T>[]>\r\n\texport function waitAll(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<PromiseLike<any>[]>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tvar promises = (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v=>!v)) return new Fulfilled<any[]>(promises); // it's a new empty, reuse it. :|\r\n\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\treturn new Promise<any[]>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet checkedAll = false;\r\n\t\t\tlet len = promises.length;\r\n\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i)=>i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = ()=>\r\n\t\t\t{\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(promises);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolved = (i:number)=>\r\n\t\t\t{\r\n\t\t\t\tif(remaining)\r\n\t\t\t\t{\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v=>onResolved(i), e=>onResolved(i));\r\n\t\t\t\telse onResolved(i);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t * or rejected.\r\n\t * @param promises An array of Promises.\r\n\t * @returns A new Promise.\r\n\t */\r\n\texport function race<T>(promises:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any>\r\n\t{\r\n\t\tvar promises = first && (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy?\r\n\t\tif(!promises || !promises.length || !(promises = promises.filter(v=>v!=null)).length)\r\n\t\t\tthrow new ArgumentException(\"Nothing to wait for.\");\r\n\r\n\t\tvar len = promises.length;\r\n\r\n\t\t// Only one?  Nothing to race.\r\n\t\tif(len==1) return wrap(promises[0]);\r\n\r\n\t\t// Look for already resolved promises and the first one wins.\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar p:any = promises[i];\r\n\t\t\tif(p instanceof PromiseBase && p.isSettled) return p;\r\n\t\t}\r\n\r\n\t\treturn new Promise((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolve = (r:(x:any)=>void, v:any)=>\r\n\t\t\t{\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(v);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any)=> onResolve(resolve, v);\r\n\t\t\tlet onReject = (e?:any)=> onResolve(reject, e);\r\n\r\n\t\t\tfor(let p of promises)\r\n\t\t\t{\r\n\t\t\t\tif(!resolve) break;\r\n\t\t\t\tp.then(onFulfill, onReject);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// // race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\r\n\r\n\t/**\r\n\t * Creates a new resolved promise .\r\n\t * @returns A resolved promise.\r\n\t */\r\n\texport function resolve():PromiseBase<void>\r\n\r\n\t/**\r\n\t * Creates a new resolved promise for the provided value.\r\n\t * @param value A value or promise.\r\n\t * @returns A promise whose internal state matches the provided promise.\r\n\t */\r\n\texport function resolve<T>(value:T | PromiseLike<T>):PromiseBase<T>;\r\n\texport function resolve(value?:any):PromiseBase<any>\r\n\t{\r\n\r\n\t\treturn isPromise(value) ? wrap(value) : new Fulfilled(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new rejected promise for the provided reason.\r\n\t * @param reason The reason the promise was rejected.\r\n\t * @returns A new rejected Promise.\r\n\t */\r\n\texport function reject<T>(reason:T):PromiseBase<T>\r\n\t{\r\n\t\treturn new Rejected<T>(reason);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes any Promise-Like object and ensures an extended version of it from this module.\r\n\t * @param target The Promise-Like object\r\n\t * @returns A new target that simply extends the target.\r\n\t */\r\n\texport function wrap<T>(target:PromiseLike<T>):PromiseBase<T>\r\n\t{\r\n\t\tif(!target) throw new ArgumentNullException(TARGET);\r\n\t\treturn target instanceof Promise ? this : new PromiseWrapper(target);\r\n\t}\r\n\r\n\t/**\r\n\t * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.\r\n\t * @param then\r\n\t * @returns {PromiseWrapper<T>}\r\n\t */\r\n\texport function createFrom<T,TResult>(then:Then<T,TResult>):PromiseBase<T>\r\n\t{\r\n\t\tif(!then) throw new ArgumentNullException(THEN);\r\n\t\treturn new PromiseWrapper({then: then});\r\n\t}\r\n\r\n}\r\n\r\n\r\ninterface IPromiseCallbacks<T>\r\n{\r\n\tonFulfilled:Promise.Fulfill<T,any>;\r\n\tonRejected:Promise.Reject<any>;\r\n\tpromise?:PromiseLike<any>;\r\n}\r\n"]}