{"version":3,"sources":["System/Tasks/TaskScheduler.js","System/Tasks/TaskScheduler.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","flush","entry","immediateQueue","first","e","value","domain","remove","enter","runSingle","task","laterQueue","dequeue","flushing","isNodeJS","exit","setTimeout","requestFlush","requestTick","TaskScheduler","Types_1","LinkedList_1","Queue_1","defer","delay","isNumber","timeout","cancel","clearTimeout","process","add","runAfterDeferred","enqueue","isObject","toString","nextTick","setImmediate","window","bind","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage","Object","defineProperty"],"mappings":";;;;;CAKA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,WAAY,4BAA6B,wBAAyBN,IAErG,SAAUI,EAASF,GAClB,YC2BJ,SAAAM,KAKC,IAFA,GAAIC,GAEEA,EAAQC,EAAeC,OAC7B,CACC,GAAIC,GAAIH,EAAMI,MAAOC,EAASF,EAAEE,MAChCL,GAAMM,SACHD,GAAQA,EAAOE,QAClBC,EAAUL,EAAEM,KAAMJ,GAInB,IADA,GAAII,GACEA,EAAOC,EAAWC,WAEvBH,EAAUC,EAGXG,IAAW,EAUZ,QAAAJ,GAAmBC,EAAeJ,GAEjC,IAECI,IAGD,MAAMN,GAEL,GAAGU,EAkBF,KAVGR,IAEFA,EAAOS,OAERC,WAAWhB,EAAO,GACfM,GAEFA,EAAOE,QAGFJ,CAONY,YAAW,WAEV,KAAMZ,IACJ,GAIFE,GAEFA,EAAOS,OAIT,QAAAE,KACKJ,IAEHA,GAAW,EACXK,KAlHF,GAyBIA,GA6FGC,EAtHPC,EAAAxB,EAAiB,YACjByB,EAAAzB,EAAuB,6BACvB0B,EAAA1B,EAAkB,wBAwBdkB,GAAmB,EACnBD,GAAmB,EA+BnBX,EAA4C,GAAImB,GAAAA,WAGhDV,EAA6B,GAAIW,GAAAA,UA6GrC,IApDA,SAAOH,GAGN,QAAAI,GAAsBb,EAAec,GAEpC,GAAGJ,EAAAA,WAAKK,SAASD,GAAM,IAAUA,GAAO,EAAG,CAE1C,GAAIE,GAAiB,EAEjBC,EAAS,WACZ,MAAGD,IACFE,aAAaF,GACbA,EAAU,GACH,IAED,EAQR,OALAA,GAAUV,WAAW,WACpBW,IACAjB,KACCc,GAEKG,EAGR,GAAI1B,IACHS,KAAKA,EACLJ,OAAOQ,GAAkBe,QAAiB,OAO3C,OAJA3B,GAAe4B,IAAI7B,GAEnBgB,IAEO,WAAI,QAAEf,EAAeK,OAAON,IAOpC,QAAA8B,GAAiCrB,GAEhCC,EAAWqB,QAAQtB,GACnBO,IA1CeE,EAAAI,MAAKA,EAuCLJ,EAAAY,iBAAgBA,GA1C1BZ,IAAAA,OAoDJC,EAAAA,WAAKa,SAASJ,UACQ,qBAArBA,QAAQK,YACRL,QAAQM,SAUXrB,GAAW,EAEXI,EAAc,WAEbW,QAAQM,SAASnC,QAId,IAAyB,kBAAfoC,cAKblB,EAFkB,mBAATmB,QAEKD,aAAaE,KAAKD,OAAQrC,GAI1B,WAEboC,aAAapC,QAKX,IAA2B,mBAAjBuC,gBACf,CAGC,GAAIC,GAAU,GAAID,eAGlBC,GAAQC,MAAMC,UAAY,WAEzBxB,EAAcyB,EACdH,EAAQC,MAAMC,UAAY1C,EAC1BA,IAED,IAAI2C,GAAkB,WAIrBH,EAAQI,MAAMC,YAAY,GAE3B3B,GAAc,WAEbF,WAAWhB,EAAO,GAClB2C,SAODzB,GAAc,WAEbF,WAAWhB,EAAO,GAIpB8C,QAAAC,eAAArD,EAAA,cAAAW,OAAA,IDzGIX,EAAAA,WCyGWyB","file":"System/Tasks/TaskScheduler.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\n(function (factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define([\"require\", \"exports\", '../Types', \"../Collections/LinkedList\", \"../Collections/Queue\"], factory);\r\n    }\r\n})(function (require, exports) {\r\n    \"use strict\";\r\n    var Types_1 = require('../Types');\r\n    var LinkedList_1 = require(\"../Collections/LinkedList\");\r\n    var Queue_1 = require(\"../Collections/Queue\");\r\n    \"use strict\";\r\n    var requestTick;\r\n    var isNodeJS = false;\r\n    var flushing = false;\r\n    function flush() {\r\n        var entry;\r\n        while (entry = immediateQueue.first) {\r\n            var e = entry.value, domain = e.domain;\r\n            entry.remove();\r\n            if (domain)\r\n                domain.enter();\r\n            runSingle(e.task, domain);\r\n        }\r\n        var task;\r\n        while (task = laterQueue.dequeue()) {\r\n            runSingle(task);\r\n        }\r\n        flushing = false;\r\n    }\r\n    var immediateQueue = new LinkedList_1.default();\r\n    var laterQueue = new Queue_1.default();\r\n    function runSingle(task, domain) {\r\n        try {\r\n            task();\r\n        }\r\n        catch (e) {\r\n            if (isNodeJS) {\r\n                if (domain) {\r\n                    domain.exit();\r\n                }\r\n                setTimeout(flush, 0);\r\n                if (domain) {\r\n                    domain.enter();\r\n                }\r\n                throw e;\r\n            }\r\n            else {\r\n                setTimeout(function () {\r\n                    throw e;\r\n                }, 0);\r\n            }\r\n        }\r\n        if (domain) {\r\n            domain.exit();\r\n        }\r\n    }\r\n    function requestFlush() {\r\n        if (!flushing) {\r\n            flushing = true;\r\n            requestTick();\r\n        }\r\n    }\r\n    var TaskScheduler;\r\n    (function (TaskScheduler) {\r\n        function defer(task, delay) {\r\n            if (Types_1.default.isNumber(delay, false) && delay >= 0) {\r\n                var timeout = 0;\r\n                var cancel = function () {\r\n                    if (timeout) {\r\n                        clearTimeout(timeout);\r\n                        timeout = 0;\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n                timeout = setTimeout(function () {\r\n                    cancel();\r\n                    task();\r\n                }, delay);\r\n                return cancel;\r\n            }\r\n            var entry = {\r\n                task: task,\r\n                domain: isNodeJS && process['domain']\r\n            };\r\n            immediateQueue.add(entry);\r\n            requestFlush();\r\n            return function () { return !!immediateQueue.remove(entry); };\r\n        }\r\n        TaskScheduler.defer = defer;\r\n        function runAfterDeferred(task) {\r\n            laterQueue.enqueue(task);\r\n            requestFlush();\r\n        }\r\n        TaskScheduler.runAfterDeferred = runAfterDeferred;\r\n    })(TaskScheduler || (TaskScheduler = {}));\r\n    if (Types_1.default.isObject(process)\r\n        && process.toString() === \"[object process]\"\r\n        && process.nextTick) {\r\n        isNodeJS = true;\r\n        requestTick = function () {\r\n            process.nextTick(flush);\r\n        };\r\n    }\r\n    else if (typeof setImmediate === \"function\") {\r\n        if (typeof window !== \"undefined\") {\r\n            requestTick = setImmediate.bind(window, flush);\r\n        }\r\n        else {\r\n            requestTick = function () {\r\n                setImmediate(flush);\r\n            };\r\n        }\r\n    }\r\n    else if (typeof MessageChannel !== \"undefined\") {\r\n        var channel = new MessageChannel();\r\n        channel.port1.onmessage = function () {\r\n            requestTick = requestPortTick;\r\n            channel.port1.onmessage = flush;\r\n            flush();\r\n        };\r\n        var requestPortTick = function () {\r\n            channel.port2.postMessage(0);\r\n        };\r\n        requestTick = function () {\r\n            setTimeout(flush, 0);\r\n            requestPortTick();\r\n        };\r\n    }\r\n    else {\r\n        requestTick = function () {\r\n            setTimeout(flush, 0);\r\n        };\r\n    }\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = TaskScheduler;\r\n});\r\n//# sourceMappingURL=TaskScheduler.js.map","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Based on code from: https://github.com/kriskowal/q\r\n */\r\n\r\nimport Type from '../Types';\r\nimport LinkedList from \"../Collections/LinkedList\";\r\nimport Queue from \"../Collections/Queue\";\r\n\r\ndeclare module process\r\n{\r\n\texport function nextTick(callback:Function):void;\r\n\texport function toString():string;\r\n}\r\n\r\ninterface IDomain\r\n{\r\n\tenter():void;\r\n\texit():void;\r\n}\r\n\r\ninterface TaskQueueEntry\r\n{\r\n\ttask:Function;\r\n\tdomain?:IDomain;\r\n}\r\n\r\n\r\n\"use strict\";\r\n\r\nvar requestTick:()=>void;\r\nvar isNodeJS:boolean = false;\r\nvar flushing:boolean = false;\r\n\r\n// Use the fastest possible means to execute a task in a future turn\r\n// of the event loop.\r\n\r\n\r\n\r\nfunction flush():void\r\n{\r\n\t/* jshint loopfunc: true */\r\n\tvar entry:ILinkedListNode<TaskQueueEntry>;\r\n\r\n\twhile(entry = immediateQueue.first)\r\n\t{\r\n\t\tlet e = entry.value, domain = e.domain;\r\n\t\tentry.remove();\r\n\t\tif(domain) domain.enter();\r\n\t\trunSingle(e.task, domain);\r\n\t}\r\n\r\n\tvar task:Function;\r\n\twhile(task = laterQueue.dequeue())\r\n\t{\r\n\t\trunSingle(task);\r\n\t}\r\n\r\n\tflushing = false;\r\n}\r\n\r\n\r\n// linked list of tasks.  Using a real linked list to allow for removal.\r\nvar immediateQueue:LinkedList<TaskQueueEntry> = new LinkedList<TaskQueueEntry>();\r\n\r\n// queue for late tasks, used by unhandled rejection tracking\r\nvar laterQueue:Queue<Function> = new Queue<Function>();\r\n\r\nfunction runSingle(task:Function, domain?:IDomain):void\r\n{\r\n\ttry\r\n\t{\r\n\t\ttask();\r\n\r\n\t}\r\n\tcatch(e)\r\n\t{\r\n\t\tif(isNodeJS)\r\n\t\t{\r\n\t\t\t// In node, uncaught exceptions are considered fatal errors.\r\n\t\t\t// Re-throw them synchronously to interrupt flushing!\r\n\r\n\t\t\t// Ensure continuation if the uncaught exception is suppressed\r\n\t\t\t// listening \"uncaughtException\" events (as domains does).\r\n\t\t\t// Continue in next event to avoid tick recursion.\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.exit();\r\n\t\t\t}\r\n\t\t\tsetTimeout(flush, 0);\r\n\t\t\tif(domain)\r\n\t\t\t{\r\n\t\t\t\tdomain.enter();\r\n\t\t\t}\r\n\r\n\t\t\tthrow e;\r\n\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// In browsers, uncaught exceptions are not fatal.\r\n\t\t\t// Re-throw them asynchronously to avoid slow-downs.\r\n\t\t\tsetTimeout(()=>\r\n\t\t\t{\r\n\t\t\t\tthrow e;\r\n\t\t\t}, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tif(domain)\r\n\t{\r\n\t\tdomain.exit();\r\n\t}\r\n}\r\n\r\nfunction requestFlush():void {\r\n\tif(!flushing)\r\n\t{\r\n\t\tflushing = true;\r\n\t\trequestTick();\r\n\t}\r\n}\r\n\r\nmodule TaskScheduler {\r\n\r\n\r\n\texport function defer(task:Function, delay?:number):()=>boolean\r\n\t{\r\n\t\tif(Type.isNumber(delay,false) && delay>=0) {\r\n\r\n\t\t\tvar timeout:number = 0;\r\n\r\n\t\t\tvar cancel = ()=>{\r\n\t\t\t\tif(timeout) {\r\n\t\t\t\t\tclearTimeout(timeout);\r\n\t\t\t\t\ttimeout = 0;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\ttimeout = setTimeout(()=>{\r\n\t\t\t\tcancel();\r\n\t\t\t\ttask();\r\n\t\t\t},delay);\r\n\r\n\t\t\treturn cancel;\r\n\t\t}\r\n\r\n\t\tvar entry = {\r\n\t\t\ttask:task,\r\n\t\t\tdomain:isNodeJS && (<any>process)['domain']\r\n\t\t};\r\n\r\n\t\timmediateQueue.add(entry);\r\n\r\n\t\trequestFlush();\r\n\r\n\t\treturn ()=>!!immediateQueue.remove(entry)\r\n\t}\r\n\r\n\r\n\t// runs a task after all other tasks have been run\r\n\t// this is useful for unhandled rejection tracking that needs to happen\r\n\t// after all `then`d tasks have been run.\r\n\texport function runAfterDeferred(task:Function):void\r\n\t{\r\n\t\tlaterQueue.enqueue(task);\r\n\t\trequestFlush();\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\nif(Type.isObject(process)\r\n\t&& process.toString()===\"[object process]\"\r\n\t&& process.nextTick)\r\n{\r\n\t// Ensure Q is in a real Node environment, with a `process.nextTick`.\r\n\t// To see through fake Node environments:\r\n\t// * Mocha test runner - exposes a `process` global without a `nextTick`\r\n\t// * Browserify - exposes a `process.nexTick` function that uses\r\n\t//   `setTimeout`. In this case `setImmediate` is preferred because\r\n\t//    it is faster. Browserify's `process.toString()` yields\r\n\t//   \"[object Object]\", while in a real Node environment\r\n\t//   `process.nextTick()` yields \"[object process]\".\r\n\tisNodeJS = true;\r\n\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tprocess.nextTick(flush);\r\n\t};\r\n\r\n}\r\nelse if(typeof setImmediate===\"function\")\r\n{\r\n\t// In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\r\n\tif(typeof window!==\"undefined\")\r\n\t{\r\n\t\trequestTick = setImmediate.bind(window, flush);\r\n\t}\r\n\telse\r\n\t{\r\n\t\trequestTick = ()=>\r\n\t\t{\r\n\t\t\tsetImmediate(flush);\r\n\t\t};\r\n\t}\r\n\r\n}\r\nelse if(typeof MessageChannel!==\"undefined\")\r\n{\r\n\t// modern browsers\r\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\r\n\tvar channel = new MessageChannel();\r\n\t// At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\r\n\t// working message ports the first time a page loads.\r\n\tchannel.port1.onmessage = function()\r\n\t{\r\n\t\trequestTick = requestPortTick;\r\n\t\tchannel.port1.onmessage = flush;\r\n\t\tflush();\r\n\t};\r\n\tvar requestPortTick = ()=>\r\n\t{\r\n\t\t// Opera requires us to provide a message payload, regardless of\r\n\t\t// whether we use it.\r\n\t\tchannel.port2.postMessage(0);\r\n\t};\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t\trequestPortTick();\r\n\t};\r\n\r\n}\r\nelse\r\n{\r\n\t// old browsers\r\n\trequestTick = ()=>\r\n\t{\r\n\t\tsetTimeout(flush, 0);\r\n\t};\r\n}\r\n\r\nexport default TaskScheduler;\r\n"]}