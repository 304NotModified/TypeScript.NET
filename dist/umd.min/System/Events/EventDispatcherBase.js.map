{"version":3,"sources":["System/Events/EventDispatcherBase.js","System/Events/EventDispatcherBase.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","entryFinalizer","params","dispatcher","removeEntry","shallowCopy_1","DisposableBase_1","AU","EventDispatcherEntry_1","dispose_1","DISPOSING","DISPOSED","EventDispatcherBase","_super","apply","arguments","_isDisposing","addEventListener","type","listener","priority","e","_entries","push","entry","remove","registerEventListener","hasEventListener","some","value","removeEventListener","these","filter","matches","dispatchEvent","_this","_","l","length","event","Event","cancellable","target","entries","sort","a","forEach","newEvent","dispatch","defineProperty","get","enumerable","configurable","dispose","wasDisposed","call"],"mappings":"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","file":"System/Events/EventDispatcherBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../Utility/shallowCopy\", \"../Disposable/DisposableBase\", \"../Collections/Array/Utility\", \"./EventDispatcherEntry\", \"../Disposable/dispose\"], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var shallowCopy_1 = require(\"../Utility/shallowCopy\");\n    var DisposableBase_1 = require(\"../Disposable/DisposableBase\");\n    var AU = require(\"../Collections/Array/Utility\");\n    var EventDispatcherEntry_1 = require(\"./EventDispatcherEntry\");\n    var dispose_1 = require(\"../Disposable/dispose\");\n    var DISPOSING = 'disposing', DISPOSED = 'disposed';\n    function entryFinalizer() {\n        var p = this.params;\n        p.dispatcher.removeEntry(this);\n        p.dispatcher = null;\n    }\n    var EventDispatcherBase = (function (_super) {\n        __extends(EventDispatcherBase, _super);\n        function EventDispatcherBase() {\n            _super.apply(this, arguments);\n            this._isDisposing = false;\n        }\n        EventDispatcherBase.prototype.addEventListener = function (type, listener, priority) {\n            if (priority === void 0) { priority = 0; }\n            var e = this._entries;\n            if (!e)\n                this._entries = e = [];\n            e.push(new EventDispatcherEntry_1.default(type, listener, {\n                priority: priority || 0,\n                dispatcher: this\n            }, entryFinalizer));\n        };\n        EventDispatcherBase.prototype.removeEntry = function (entry) {\n            return !!this._entries && AU.remove(this._entries, entry) != 0;\n        };\n        EventDispatcherBase.prototype.registerEventListener = function (type, listener, priority) {\n            if (priority === void 0) { priority = 0; }\n            if (!this.hasEventListener(type, listener))\n                this.addEventListener(type, listener, priority);\n        };\n        EventDispatcherBase.prototype.hasEventListener = function (type, listener) {\n            var e = this._entries;\n            return e && e.some(function (value) {\n                return type == value.type && (!listener || listener == value.listener);\n            });\n        };\n        EventDispatcherBase.prototype.removeEventListener = function (type, listener) {\n            dispose_1.default.these(this._entries.filter(function (entry) { return entry.matches(type, listener); }));\n        };\n        EventDispatcherBase.prototype.dispatchEvent = function (e, params) {\n            var _this = this;\n            var _ = this, l = _._entries;\n            if (!l || !l.length)\n                return false;\n            var event;\n            if (typeof e == \"string\") {\n                event = Event && Object.create(Event) || {};\n                if (!params)\n                    params = {};\n                if (params['cancellable'])\n                    event.cancellable = true;\n                event.target = _;\n                event.type = e;\n            }\n            else\n                event = e;\n            var type = event.type;\n            var entries = l.filter(function (e) { return e.type == type; });\n            if (!entries.length)\n                return false;\n            entries.sort(function (a, b) { return b.params.priority - a.params.priority; });\n            entries.forEach(function (entry) {\n                var newEvent = Object.create(Event);\n                shallowCopy_1.default(event, newEvent);\n                newEvent.target = _this;\n                entry.dispatch(newEvent);\n            });\n            return true;\n        };\n        Object.defineProperty(EventDispatcherBase, \"DISPOSING\", {\n            get: function () { return DISPOSING; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventDispatcherBase, \"DISPOSED\", {\n            get: function () { return DISPOSED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(EventDispatcherBase.prototype, \"isDisposing\", {\n            get: function () {\n                return this._isDisposing;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        EventDispatcherBase.prototype.dispose = function () {\n            var _ = this;\n            if (!_.wasDisposed && !_._isDisposing) {\n                _._isDisposing = true;\n                _.dispatchEvent(DISPOSING);\n                _super.prototype.dispose.call(this);\n                _.dispatchEvent(DISPOSED);\n                var l = _._entries;\n                if (l) {\n                    this._entries = null;\n                    l.forEach(function (e) { return e.dispose(); });\n                }\n            }\n        };\n        return EventDispatcherBase;\n    }(DisposableBase_1.default));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = EventDispatcherBase;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Disposable/IDisposable.d.ts\"/>\r\n///<reference path=\"IEventDispatcher.d.ts\"/>\r\n///<reference path=\"IEventDispatcher.d.ts\"/>\r\n\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\n\r\nimport shallowCopy from \"../Utility/shallowCopy\";\r\nimport DisposableBase from \"../Disposable/DisposableBase\";\r\nimport * as AU from \"../Collections/Array/Utility\";\r\nimport EventDispatcherEntry from \"./EventDispatcherEntry\";\r\nimport dispose from \"../Disposable/dispose\";\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string  = 'disposed';\r\n\r\n// The following interfaces are exported for sub class implementation.\r\n\r\nexport interface IEventBase<TTarget> {\r\n\ttype: string;\r\n\ttarget: TTarget;\r\n}\r\n\r\nexport interface IEvent extends IEventBase<any> {\r\n\r\n}\r\n\r\nexport interface IEntryParams\r\n{\r\n\tpriority:number;\r\n\tdispatcher:EventDispatcherBase;\r\n}\r\n\r\nfunction entryFinalizer()\r\n{\r\n\tvar p:IEntryParams = this.params;\r\n\tp.dispatcher.removeEntry(this);\r\n\tp.dispatcher = null;\r\n}\r\n\r\nexport default\r\nclass EventDispatcherBase extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tprotected _entries:EventDispatcherEntry<IEntryParams>[];\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void\r\n\t{\r\n\t\tvar e = this._entries;\r\n\t\tif(!e) this._entries = e = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\te.push(\r\n\t\t\tnew EventDispatcherEntry(type, listener, {\r\n\t\t\t\t\tpriority: priority || 0,\r\n\t\t\t\t\tdispatcher: this\r\n\t\t\t\t},\r\n\t\t\t\tentryFinalizer));\r\n\t}\r\n\r\n\tremoveEntry(entry:EventDispatcherEntry<IEntryParams>):boolean\r\n\t{\r\n\t\treturn !!this._entries && AU.remove(this._entries, entry)!=0;\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener))\r\n\t\t\tthis.addEventListener(type, listener, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:IEventListener):boolean\r\n\t{\r\n\t\tvar e = this._entries;\r\n\t\treturn e && e.some(\r\n\t\t\t\t(value:EventDispatcherEntry<IEntryParams>):boolean =>\r\n\t\t\t\ttype==value.type && (!listener || listener==value.listener)\r\n\t\t\t);\r\n\t}\r\n\r\n\tremoveEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener):void\r\n\t{\r\n\t\tdispose.these(this._entries.filter(entry=> entry.matches(type, listener)));\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:IEvent):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean\r\n\t{\r\n\r\n\t\tvar _ = this, l = _._entries;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tvar event:IEventBase<any>;\r\n\r\n\t\tif(typeof e==\"string\")\r\n\t\t{\r\n\t\t\tevent = Event && Object.create(Event) || {};\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tif(params['cancellable'])\r\n\t\t\t\t(<any>event).cancellable = true;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = e;\r\n\r\n\t\tvar type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tvar entries:EventDispatcherEntry<IEntryParams>[] = l.filter(e=>e.type==type);//, propagate = true, prevent = false;\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort((a, b)=> b.params.priority - a.params.priority);\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\tentry=>\r\n\t\t\t{\r\n\t\t\t\tvar newEvent = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.dispatch(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean\r\n\t{\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose()\r\n\t{\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tvar _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing)\r\n\t\t{\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tvar l = _._entries;\r\n\t\t\tif(l)\r\n\t\t\t{\r\n\t\t\t\tthis._entries = null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}