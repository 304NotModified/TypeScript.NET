{"version":3,"sources":["System/TypeValidator.js","System/TypeValidator.ts"],"names":["dependencies","factory","module","exports","v","require","undefined","define","amd","areInvalid","d","Compare_1","areEqual","memberType","TypeInfoHelper","contains","Types_1","extends_1","__extends","_super","value","call","this","self","_value","prototype","descriptor","Function","isFunction","Object","isObject","Array","isArray","String","isString","Number","isNumber","Boolean","isBoolean","type","isPrimitive","max","Math","min","length","i","targetKeys","keys","dKeys","_i","dKeys_1","key","indexOf","_a","dKeys_2","TypeInfo","TypeValidator","_typeDescriptor","freeze","isSubsetOf","o","defineProperty"],"mappings":"CAAA,SAAWA,EAAcC,GACrB,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,OAAOP,EAAcC,KAEzB,UAAW,UAAW,UAAW,YAAa,cAAe,SAAUI,EAASF,GAChF,YCiGJ,SAAAM,GAAoBL,EAAOM,GAE1B,IAAIC,EAAAC,SAASR,EAAGM,GAChB,CACC,GAAIG,GAAa,GAAIC,GAAeV,EACpC,KAAIS,EAAWE,SAASL,GACvB,OAAO,EAET,OAAO;;;;AA/FR,GAAAM,GAAAX,EAAA,WACAM,EAAAN,EAAA,aACAY,EAAAZ,EAAA,cAEMa,EAAYD,EAAAA,WAGlBH,EAAA,SAAAK,GAKC,QAAAL,GAAYM,GDKD,MCHVD,GAAAE,KAAAC,KAAMF,EAAO,SAAAG,GAAM,MAAAA,GAAKC,OAASJ,KAAME,KAuEzC,MA9EoCJ,GAAAJ,EAAAK,GAUnCL,EAAAW,UAAAV,SAAA,SAAsBW,GAGrB,GAAIN,GAAQE,KAAKE,MAEjB,IAAGJ,IAAQM,EACV,OAAO,CAER,QAAOA,GAEN,IAAKC,UACJ,MAAOL,MAAKM,UACb,KAAKC,QACJ,MAAOP,MAAKQ,QACb,KAAKC,OACJ,MAAOT,MAAKU,OACb,KAAKC,QACJ,MAAOX,MAAKY,QACb,KAAKC,QACJ,MAAOb,MAAKc,QACb,KAAKC,SACJ,MAAOf,MAAKgB,UAGd,GAAGhB,KAAKiB,YAAcb,IAAcJ,KAAKkB,cAAgB7B,EAAAC,SAASQ,EAAOM,GACxE,OAAO,CAGR,IAAGJ,KAAKU,SAAW,YAAsB,OACzC,CAGC,IAAI,GAFAS,GAAMC,KAAKC,IAAIjB,EAAWkB,OAAQxB,EAAMwB,QAEpCC,EAAI,EAAGA,EAAEJ,EAAKI,IAErB,GAAGpC,EAAWW,EAAMyB,GAAInB,EAAWmB,IAClC,OAAO,CAGT,QAAO,EAGR,GAAGvB,KAAKQ,SACR,CACC,GAAIgB,GAAajB,OAAOkB,KAAK3B,GACzB4B,EAAQnB,OAAOkB,KAAKrB,EAGxB,IAAGsB,EAAMJ,OAAOE,EAAWF,OAC1B,OAAO,CAGR,KAAe,GAAAK,GAAA,EAAAC,EAAAF,EAAAC,EAAAC,EAAAN,OAAAK,IAAK,CAAhB,GAAIE,GAAGD,EAAAD,EAEV,IAAGH,EAAWM,QAAQD,OACrB,OAAO,EAIT,IAAe,GAAAE,GAAA,EAAAC,EAAAN,EAAAK,EAAAC,EAAAV,OAAAS,IAAK,CAAhB,GAAIF,GAAGG,EAAAD,EAEV,IAAG5C,EAAWW,EAAM+B,GAAMzB,EAAWyB,IACpC,OAAO,GAIV,OAAO,GAGTrC,GA9EoCE,EAAAuC,SAApCpD,GAAAW,eAAAA,CA2FA,IAAA0C,GAAA,WAEC,QAAAA,GAA6BC,GAAAnC,KAAAmC,gBAAAA,EAE5B5B,OAAO6B,OAAOpC,MAQhB,MALCkC,GAAA/B,UAAAkC,WAAA,SAAWC,GAEV,MAAO,IAAK9C,GAAe8C,GACzB7C,SAASO,KAAKmC,kBAElBD,IAZArD,GAAAqD,cAAAA,EDNI3B,OAAOgC,eAAe1D,EAAS,cAAgBiB,OAAO,ICoB1DjB,EAAAA,WAAeqD","file":"TypeValidator.js","sourcesContent":["(function (dependencies, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(dependencies, factory);\n    }\n})([\"require\", \"exports\", \"./Types\", \"./Compare\", \"../extends\"], function (require, exports) {\n    \"use strict\";\n    /*!\n     * @author electricessence / https://github.com/electricessence/\n     * Licensing: MIT\n     */\n    /**\n     * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\n     *\n     * var descriptor = {\n     *      a : Object,\n     *      b : String,\n     *      c : {\n     *          d : true ,\n     *          e : Array,\n     *          f : []\n     *      },\n     *      g : \"literal\"\n     * }\n     */\n    var Types_1 = require(\"./Types\");\n    var Compare_1 = require(\"./Compare\");\n    var extends_1 = require(\"../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var TypeInfoHelper = (function (_super) {\n        __extends(TypeInfoHelper, _super);\n        function TypeInfoHelper(value) {\n            return _super.call(this, value, function (self) { return self._value = value; }) || this;\n        }\n        TypeInfoHelper.prototype.contains = function (descriptor) {\n            var value = this._value;\n            if (value === descriptor)\n                return true;\n            switch (descriptor) {\n                case Function:\n                    return this.isFunction;\n                case Object:\n                    return this.isObject;\n                case Array:\n                    return this.isArray;\n                case String:\n                    return this.isString;\n                case Number:\n                    return this.isNumber;\n                case Boolean:\n                    return this.isBoolean;\n            }\n            if (this.type != typeof descriptor || this.isPrimitive && !Compare_1.areEqual(value, descriptor))\n                return false;\n            // Check array contents and confirm intersections.\n            if (this.isArray && (descriptor) instanceof (Array)) {\n                var max = Math.min(descriptor.length, value.length);\n                for (var i = 0; i < max; i++) {\n                    if (areInvalid(value[i], descriptor[i]))\n                        return false;\n                }\n                return true;\n            }\n            if (this.isObject) {\n                var targetKeys = Object.keys(value);\n                var dKeys = Object.keys(descriptor);\n                // Quick check...\n                if (dKeys.length > targetKeys.length)\n                    return false;\n                // Quick check #2...\n                for (var _i = 0, dKeys_1 = dKeys; _i < dKeys_1.length; _i++) {\n                    var key = dKeys_1[_i];\n                    if (targetKeys.indexOf(key) == -1)\n                        return false;\n                }\n                // Final pass with recursive...\n                for (var _a = 0, dKeys_2 = dKeys; _a < dKeys_2.length; _a++) {\n                    var key = dKeys_2[_a];\n                    if (areInvalid(value[key], descriptor[key]))\n                        return false;\n                }\n            }\n            return true;\n        };\n        return TypeInfoHelper;\n    }(Types_1.TypeInfo));\n    exports.TypeInfoHelper = TypeInfoHelper;\n    function areInvalid(v, d) {\n        if (!Compare_1.areEqual(v, d)) {\n            var memberType = new TypeInfoHelper(v);\n            if (!memberType.contains(d))\n                return true;\n        }\n        return false;\n    }\n    var TypeValidator = (function () {\n        function TypeValidator(_typeDescriptor) {\n            this._typeDescriptor = _typeDescriptor;\n            Object.freeze(this);\n        }\n        TypeValidator.prototype.isSubsetOf = function (o) {\n            return (new TypeInfoHelper(o))\n                .contains(this._typeDescriptor);\n        };\n        return TypeValidator;\n    }());\n    exports.TypeValidator = TypeValidator;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = TypeValidator;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n/**\r\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\r\n *\r\n * var descriptor = {\r\n *      a : Object,\r\n *      b : String,\r\n *      c : {\r\n *          d : true ,\r\n *          e : Array,\r\n *          f : []\r\n *      },\r\n *      g : \"literal\"\r\n * }\r\n */\r\nimport {TypeInfo} from \"./Types\";\r\nimport {areEqual} from \"./Compare\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\nexport class TypeInfoHelper extends TypeInfo\r\n{\r\n\r\n\tprivate _value:any;\r\n\r\n\tconstructor(value:any)\r\n\t{\r\n\t\tsuper(value, self=>self._value = value);\r\n\t}\r\n\r\n\tcontains<TDescriptor>(descriptor:any):this is TDescriptor\r\n\t{\r\n\r\n\t\tlet value = this._value;\r\n\r\n\t\tif(value===descriptor)\r\n\t\t\treturn true;\r\n\r\n\t\tswitch(descriptor)\r\n\t\t{\r\n\t\t\tcase Function:\r\n\t\t\t\treturn this.isFunction;\r\n\t\t\tcase Object:\r\n\t\t\t\treturn this.isObject;\r\n\t\t\tcase Array:\r\n\t\t\t\treturn this.isArray;\r\n\t\t\tcase String:\r\n\t\t\t\treturn this.isString;\r\n\t\t\tcase Number:\r\n\t\t\t\treturn this.isNumber;\r\n\t\t\tcase Boolean:\r\n\t\t\t\treturn this.isBoolean;\r\n\t\t}\r\n\r\n\t\tif(this.type!= typeof descriptor || this.isPrimitive && !areEqual(value, descriptor))\r\n\t\t\treturn false;\r\n\r\n\t\t// Check array contents and confirm intersections.\r\n\t\tif(this.isArray && (descriptor)instanceof(Array))\r\n\t\t{\r\n\t\t\tlet max = Math.min(descriptor.length, value.length);\r\n\r\n\t\t\tfor(let i = 0; i<max; i++)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[i], descriptor[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(this.isObject)\r\n\t\t{\r\n\t\t\tlet targetKeys = Object.keys(value);\r\n\t\t\tlet dKeys = Object.keys(descriptor);\r\n\r\n\t\t\t// Quick check...\r\n\t\t\tif(dKeys.length>targetKeys.length)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Quick check #2...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(targetKeys.indexOf(key)== -1)\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Final pass with recursive...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[key], descriptor[key]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\nfunction areInvalid(v:any, d:any)\r\n{\r\n\tif(!areEqual(v, d))\r\n\t{\r\n\t\tlet memberType = new TypeInfoHelper(v);\r\n\t\tif(!memberType.contains(d))\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport class TypeValidator<T>\r\n{\r\n\tconstructor(private readonly _typeDescriptor:any)\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tisSubsetOf(o:any):o is T\r\n\t{\r\n\t\treturn (new TypeInfoHelper(o))\r\n\t\t\t.contains(this._typeDescriptor);\r\n\t}\r\n}\r\n\r\nexport default TypeValidator;\r\n\r\n"]}