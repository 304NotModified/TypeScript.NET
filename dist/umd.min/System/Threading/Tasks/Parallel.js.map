{"version":3,"sources":["System/Threading/Tasks/Parallel.js","System/Threading/Tasks/Parallel.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","extend","from","to","_i","_a","Object","keys","length","i","interact","w","onMessage","onError","message","onmessage","onerror","VOID0","postMessage","workers","Promise_1","Types_1","Worker_1","deferImmediate_1","Environment_1","ObjectPool_1","URL","self","Type","UNDEFINED","webkitURL","_supports","isNodeJS","Worker","defaults","evalPath","__dirname","maxConcurrency","cpus","navigator","hardwareConcurrency","allowSynchronous","env","envNamespace","WorkerPromise","_super","worker","data","call","this","resolve","reject","response","e","__extends","Promise","getPool","key","pool","workerPools","ObjectPool","autoClearTimeout","recycle","k","__key","add","deferImmediate","terminate","tryGet","tryTake","getNew","url","dispose","Parallel","options","_requiredScripts","_requiredFunctions","max","prototype","getWorkerSource","task","scripts","functions","preStr","join","functions_1","name_1","name","fn","source","toString","JSON","stringify","ns","required","arguments","requireThese","required_1","a","STRING","push","FUNCTION","OBJECT","TypeError","_spawnWorker","src","Error","blob","Blob","type","createObjectURL","startNew","_","finallyThis","map","_this","slice","ArrayPromise","result","len","error","taskString","resolved","_loop_1","all","d","r","j","ex","value","next","ii_1","wp_1","thenSynchronous","thenThis","Math","min","state_1","fulfilled","defineProperty","get","enumerable","configurable"],"mappings":"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","file":"System/Threading/Tasks/Parallel.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Originally based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../../Promises/Promise\", \"../../Types\", \"../Worker\", \"../deferImmediate\", \"../../Environment\", \"../../Disposable/ObjectPool\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Promise_1 = require(\"../../Promises/Promise\");\n    var Types_1 = require(\"../../Types\");\n    var Worker_1 = require(\"../Worker\");\n    var deferImmediate_1 = require(\"../deferImmediate\");\n    var Environment_1 = require(\"../../Environment\");\n    var ObjectPool_1 = require(\"../../Disposable/ObjectPool\");\n    var VOID0 = void 0, URL = typeof self !== Types_1.Type.UNDEFINED ? (self.URL ? self.URL : self.webkitURL) : null, _supports = (Environment_1.isNodeJS || self.Worker) ? true : false;\n    var defaults = {\n        evalPath: Environment_1.isNodeJS ? __dirname + '/eval.js' : null,\n        maxConcurrency: Environment_1.isNodeJS ? require('os').cpus().length : (navigator.hardwareConcurrency || 4),\n        allowSynchronous: true,\n        env: {},\n        envNamespace: 'env'\n    };\n    function extend(from, to) {\n        if (!to)\n            to = {};\n        for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\n            var i = _a[_i];\n            if (to[i] === void 0)\n                to[i] = from[i];\n        }\n        return to;\n    }\n    function interact(w, onMessage, onError, message) {\n        if (onMessage)\n            w.onmessage = onMessage;\n        if (onError)\n            w.onerror = onError;\n        if (message !== VOID0)\n            w.postMessage(message);\n    }\n    var WorkerPromise = (function (_super) {\n        __extends(WorkerPromise, _super);\n        function WorkerPromise(worker, data) {\n            _super.call(this, function (resolve, reject) {\n                interact(worker, function (response) {\n                    resolve(response.data);\n                }, function (e) {\n                    reject(e);\n                }, data);\n            }, true);\n        }\n        return WorkerPromise;\n    }(Promise_1.Promise));\n    var workers;\n    (function (workers) {\n        function getPool(key) {\n            var pool = workerPools[key];\n            if (!pool) {\n                workerPools[key] = pool = new ObjectPool_1.ObjectPool(8);\n                pool.autoClearTimeout = 1000;\n            }\n            return pool;\n        }\n        var workerPools = {};\n        function recycle(w) {\n            if (w) {\n                w.onerror = null;\n                w.onmessage = null;\n                var k = w.__key;\n                if (k) {\n                    getPool(k).add(w);\n                }\n                else {\n                    deferImmediate_1.deferImmediate(function () { return w.terminate(); });\n                }\n            }\n            return null;\n        }\n        workers.recycle = recycle;\n        function tryGet(key) {\n            return getPool(key).tryTake();\n        }\n        workers.tryGet = tryGet;\n        function getNew(key, url) {\n            var worker = new Worker_1.default(url);\n            worker.__key = key;\n            worker.dispose = function () {\n                worker.onmessage = null;\n                worker.onerror = null;\n                worker.dispose = null;\n                worker.terminate();\n            };\n            return worker;\n        }\n        workers.getNew = getNew;\n    })(workers || (workers = {}));\n    var Parallel = (function () {\n        function Parallel(options) {\n            this.options = extend(defaults, options);\n            this._requiredScripts = [];\n            this._requiredFunctions = [];\n        }\n        Parallel.maxConcurrency = function (max) {\n            return new Parallel({ maxConcurrency: max });\n        };\n        Parallel.prototype.getWorkerSource = function (task, env) {\n            var scripts = this._requiredScripts, functions = this._requiredFunctions;\n            var preStr = '';\n            if (!Environment_1.isNodeJS && scripts.length) {\n                preStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\n            }\n            for (var _i = 0, functions_1 = functions; _i < functions_1.length; _i++) {\n                var _a = functions_1[_i], name_1 = _a.name, fn = _a.fn;\n                var source = fn.toString();\n                preStr += name_1\n                    ? \"var \" + name_1 + \" = \" + source + \";\"\n                    : source;\n            }\n            env = JSON.stringify(env || {});\n            var ns = this.options.envNamespace;\n            return preStr + (Environment_1.isNodeJS\n                ? \"process.on(\\\"message\\\", function(e) {global.\" + ns + \" = \" + env + \";process.send(JSON.stringify((\" + task.toString() + \")(JSON.parse(e).data)))})\"\n                : \"self.onmessage = function(e) {var global = {}; global.\" + ns + \" = \" + env + \"';self.postMessage((\" + task.toString() + \")(e.data))}\");\n        };\n        Parallel.prototype.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i - 0] = arguments[_i];\n            }\n            return this.requireThese(required);\n        };\n        Parallel.prototype.requireThese = function (required) {\n            for (var _i = 0, required_1 = required; _i < required_1.length; _i++) {\n                var a = required_1[_i];\n                switch (typeof a) {\n                    case Types_1.Type.STRING:\n                        this._requiredScripts.push(a);\n                        break;\n                    case Types_1.Type.FUNCTION:\n                        this._requiredFunctions.push({ fn: a });\n                        break;\n                    case Types_1.Type.OBJECT:\n                        this._requiredFunctions.push(a);\n                        break;\n                    default:\n                        throw new TypeError(\"Invalid type.\");\n                }\n            }\n            return this;\n        };\n        Parallel.prototype._spawnWorker = function (task, env) {\n            var src = this.getWorkerSource(task, env);\n            if (Worker_1.default === VOID0)\n                return VOID0;\n            var worker = workers.tryGet(src);\n            if (worker)\n                return worker;\n            var scripts = this._requiredScripts, evalPath = this.options.evalPath;\n            if (!evalPath) {\n                if (Environment_1.isNodeJS)\n                    throw new Error(\"Can't use NodeJD without eval.js!\");\n                if (scripts.length)\n                    throw new Error(\"Can't use required scripts without eval.js!\");\n                if (!URL)\n                    throw new Error(\"Can't create a blob URL in this browser!\");\n            }\n            if (Environment_1.isNodeJS || scripts.length || !URL) {\n                worker = workers.getNew(src, evalPath);\n                worker.postMessage(src);\n            }\n            else if (URL) {\n                var blob = new Blob([src], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                worker = workers.getNew(src, url);\n            }\n            return worker;\n        };\n        Parallel.prototype.startNew = function (data, task, env) {\n            var _ = this;\n            var worker = _._spawnWorker(task, extend(_.options.env, env || {}));\n            if (worker)\n                return new WorkerPromise(worker, data)\n                    .finallyThis(function () { return workers.recycle(worker); });\n            if (_.options.allowSynchronous)\n                return new Promise_1.Promise(function (resolve, reject) {\n                    try {\n                        resolve(task(data));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            throw new Error('Workers do not exist and synchronous operation not allowed!');\n        };\n        Parallel.prototype.map = function (data, task, env) {\n            var _this = this;\n            if (!data || !data.length)\n                return Promise_1.ArrayPromise.fulfilled(data && []);\n            data = data.slice();\n            return new Promise_1.ArrayPromise(function (resolve, reject) {\n                var result = [], len = data.length;\n                result.length = len;\n                var taskString = task.toString();\n                var maxConcurrency = _this.options.maxConcurrency, error;\n                var i = 0, resolved = 0;\n                var _loop_1 = function(w) {\n                    var worker = _this._spawnWorker(taskString, env);\n                    if (!worker) {\n                        if (!_this.options.allowSynchronous)\n                            throw new Error('Workers do not exist and synchronous operation not allowed!');\n                        resolve(Promise_1.Promise\n                            .all(data.map(function (d) { return new Promise_1.Promise(function (r, j) {\n                            try {\n                                r(task(d));\n                            }\n                            catch (ex) {\n                                j(ex);\n                            }\n                        }); })));\n                        return { value: void 0 };\n                    }\n                    var next = function () {\n                        if (error) {\n                            worker = workers.recycle(worker);\n                        }\n                        if (worker) {\n                            if (i < len) {\n                                var ii_1 = i++;\n                                var wp_1 = new WorkerPromise(worker, data[ii_1]);\n                                wp_1\n                                    .thenSynchronous(function (r) {\n                                    result[ii_1] = r;\n                                    next();\n                                }, function (e) {\n                                    if (!error) {\n                                        error = e;\n                                        reject(e);\n                                        worker = workers.recycle(worker);\n                                    }\n                                })\n                                    .thenThis(function () {\n                                    resolved++;\n                                    if (resolved > len)\n                                        throw Error(\"Resolved count exceeds data length.\");\n                                    if (resolved === len)\n                                        resolve(result);\n                                })\n                                    .finallyThis(function () {\n                                    return wp_1.dispose();\n                                });\n                            }\n                            else {\n                                worker = workers.recycle(worker);\n                            }\n                        }\n                    };\n                    next();\n                };\n                for (var w = 0; !error && i < Math.min(len, maxConcurrency); w++) {\n                    var state_1 = _loop_1(w);\n                    if (typeof state_1 === \"object\") return state_1.value;\n                }\n            });\n        };\n        Object.defineProperty(Parallel, \"isSupported\", {\n            get: function () { return _supports; },\n            enumerable: true,\n            configurable: true\n        });\n        Parallel.options = function (options) {\n            return new Parallel(options);\n        };\n        Parallel.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i - 0] = arguments[_i];\n            }\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.requireThese = function (required) {\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.startNew = function (data, task, env) {\n            return (new Parallel()).startNew(data, task, env);\n        };\n        Parallel.map = function (data, task, env) {\n            return (new Parallel()).map(data, task, env);\n        };\n        return Parallel;\n    }());\n    exports.Parallel = Parallel;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Parallel;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Originally based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\r\n */\r\n\r\nimport {Promise, PromiseBase, ArrayPromise} from \"../../Promises/Promise\";\r\nimport {Type} from \"../../Types\";\r\nimport Worker from \"../Worker\";\r\nimport {WorkerLike} from \"../WorkerType\";\r\nimport {deferImmediate} from \"../deferImmediate\";\r\nimport {isNodeJS} from \"../../Environment\";\r\nimport {ObjectPool} from \"../../Disposable/ObjectPool\";\r\nimport {IMap} from \"../../Collections/Dictionaries/IDictionary\";\r\n\r\ndeclare const navigator:any;\r\ndeclare const require:any;\r\ndeclare const self:any;\r\ndeclare const __dirname:string;\r\n\r\n//noinspection JSUnusedAssignment\r\nconst\r\n\tVOID0:any = void 0,\r\n\tURL       = typeof self!==Type.UNDEFINED ? (self.URL ? self.URL : self.webkitURL) : null,\r\n\t_supports = (isNodeJS || self.Worker) ? true : false; // node always supports parallel\r\n\r\nexport interface ParallelOptions\r\n{\r\n\t/**\r\n\t * This is the path to the file eval.js.  This is required when running in node, and required for some browsers (IE 10) in order to work around cross-domain restrictions for web workers.  Defaults to the same location as parallel.js in node environments, and null in the browser.\r\n\t **/\r\n\tevalPath?:string;\r\n\r\n\t/**\r\n\t * The maximum number of permitted worker threads.  This will default to 4, or the number of CPUs on your computer if you're running node.\r\n\t **/\r\n\tmaxConcurrency?:number;\r\n\r\n\t/**\r\n\t * If WebWorkers are not available, whether or not to fall back to synchronous processing using setTimeout.  Defaults to true.\r\n\t **/\r\n\tallowSynchronous?:boolean;\r\n\r\n\tenv?:any\r\n\tenvNamespace?:string\r\n}\r\n\r\n//noinspection JSUnusedAssignment\r\nconst defaults:ParallelOptions = {\r\n\tevalPath: isNodeJS ? __dirname + '/eval.js' : null,\r\n\tmaxConcurrency: isNodeJS ? require('os').cpus().length : (navigator.hardwareConcurrency || 4),\r\n\tallowSynchronous: true,\r\n\tenv: {},\r\n\tenvNamespace: 'env'\r\n};\r\n\r\nfunction extend<T extends any>(from:T, to:T):T\r\n{\r\n\tif(!to) to = <any>{};\r\n\tfor(var i of Object.keys(from))\r\n\t{\r\n\t\tif(to[i]=== void 0) to[i] = from[i];\r\n\t}\r\n\treturn to;\r\n}\r\n\r\nfunction interact(\r\n\tw:WorkerLike,\r\n\tonMessage:(msg:{data:any})=>void,\r\n\tonError:(e:any)=>void,\r\n\tmessage?:any):void\r\n{\r\n\tif(onMessage) w.onmessage = onMessage;\r\n\tif(onError) w.onerror = onError;\r\n\tif(message!==VOID0) w.postMessage(message);\r\n}\r\n\r\nclass WorkerPromise<T> extends Promise<T>\r\n{\r\n\tconstructor(worker:WorkerLike, data:any)\r\n\t{\r\n\t\tsuper((resolve, reject)=>\r\n\t\t{\r\n\t\t\tinteract(\r\n\t\t\t\tworker,\r\n\t\t\t\t(response:{data:any})=>\r\n\t\t\t\t{\r\n\t\t\t\t\tresolve(response.data);\r\n\t\t\t\t},\r\n\t\t\t\t(e:any)=>\r\n\t\t\t\t{\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t},\r\n\t\t\t\tdata)\r\n\t\t}, true);\r\n\t}\r\n}\r\n\r\nexport type RequireType = string | Function | {name?:string,fn:Function};\r\n\r\nmodule workers\r\n{\r\n\r\n\tfunction getPool(key:string):ObjectPool<WorkerLike>\r\n\t{\r\n\t\tvar pool = workerPools[key];\r\n\t\tif(!pool)\r\n\t\t{\r\n\t\t\tworkerPools[key] = pool = new ObjectPool<WorkerLike>(8);\r\n\t\t\tpool.autoClearTimeout = 1000; // Fast cleanup... 1s.\r\n\t\t}\r\n\t\treturn pool;\r\n\t}\r\n\r\n\tvar workerPools:IMap<ObjectPool<WorkerLike>> = {};\r\n\r\n\texport function recycle(w:WorkerLike):WorkerLike\r\n\t{ // always returns null.\r\n\t\tif(w)\r\n\t\t{\r\n\t\t\tw.onerror = null;\r\n\t\t\tw.onmessage = null;\r\n\t\t\tvar k = (<any>w).__key;\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tgetPool(k).add(w);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdeferImmediate(()=>w.terminate());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\texport function tryGet(key:string):WorkerLike {\r\n\t\treturn getPool(key).tryTake();\r\n\t}\r\n\r\n\texport function getNew(key:string,url:string):WorkerLike {\r\n\t\tvar worker:any = new Worker(url);\r\n\t\tworker.__key = key;\r\n\t\tworker.dispose = ()=>{\r\n\t\t\tworker.onmessage = null;\r\n\t\t\tworker.onerror = null;\r\n\t\t\tworker.dispose = null;\r\n\t\t\tworker.terminate();\r\n\t\t};\r\n\t\treturn worker;\r\n\t}\r\n}\r\n\r\n\r\nexport class Parallel\r\n{\r\n\r\n\toptions:ParallelOptions;\r\n\t_requiredScripts:string[];\r\n\t_requiredFunctions:{name?:string,fn:Function}[];\r\n\r\n\tconstructor(options?:ParallelOptions)\r\n\t{\r\n\t\tthis.options = extend(defaults, options);\r\n\r\n\t\tthis._requiredScripts = [];\r\n\t\tthis._requiredFunctions = [];\r\n\t}\r\n\r\n\tstatic maxConcurrency(max:number):Parallel {\r\n\t\treturn new Parallel({maxConcurrency:max});\r\n\t}\r\n\r\n\tgetWorkerSource(task:Function|string, env?:any):string\r\n\t{\r\n\t\tvar scripts = this._requiredScripts, functions = this._requiredFunctions;\r\n\t\tvar preStr = '';\r\n\r\n\t\tif(!isNodeJS && scripts.length)\r\n\t\t{\r\n\t\t\tpreStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\r\n\t\t}\r\n\r\n\t\tfor(let {name, fn} of functions)\r\n\t\t{\r\n\t\t\tvar source = fn.toString();\r\n\t\t\tpreStr += name\r\n\t\t\t\t? `var ${name} = ${source};`\r\n\t\t\t\t: source;\r\n\t\t}\r\n\r\n\r\n\t\tenv = JSON.stringify(env || {});\r\n\r\n\t\tconst ns = this.options.envNamespace;\r\n\r\n\t\treturn preStr + (\r\n\t\t\t\tisNodeJS\r\n\t\t\t\t\t? `process.on(\"message\", function(e) {global.${ns} = ${env};process.send(JSON.stringify((${task.toString()})(JSON.parse(e).data)))})`\r\n\t\t\t\t\t: `self.onmessage = function(e) {var global = {}; global.${ns} = ${env}';self.postMessage((${task.toString()})(e.data))}`\r\n\t\t\t);\r\n\t}\r\n\r\n\trequire(...required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn this.requireThese(required);\r\n\t}\r\n\r\n\trequireThese(required:RequireType[]):Parallel\r\n\t{\r\n\t\tfor(let a of required)\r\n\t\t{\r\n\t\t\tswitch(typeof a)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\t\tthis._requiredScripts.push(<string>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.FUNCTION:\r\n\t\t\t\t\tthis._requiredFunctions.push({fn: <Function>a});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.OBJECT:\r\n\t\t\t\t\tthis._requiredFunctions.push(<{name?:string,fn:Function}>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new TypeError(\"Invalid type.\");\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _spawnWorker(task:Function|string, env?:any):WorkerLike\r\n\t{\r\n\t\tvar src = this.getWorkerSource(task, env);\r\n\r\n\t\tif(Worker===VOID0) return VOID0;\r\n\t\tvar worker = workers.tryGet(src);\r\n\t\tif(worker) return worker;\r\n\r\n\t\tvar scripts = this._requiredScripts, evalPath = this.options.evalPath;\r\n\r\n\t\tif(!evalPath)\r\n\t\t{\r\n\t\t\tif(isNodeJS)\r\n\t\t\t\tthrow new Error(\"Can't use NodeJD without eval.js!\");\r\n\t\t\tif(scripts.length)\r\n\t\t\t\tthrow new Error(\"Can't use required scripts without eval.js!\");\r\n\t\t\tif(!URL)\r\n\t\t\t\tthrow new Error(\"Can't create a blob URL in this browser!\");\r\n\t\t}\r\n\r\n\t\tif(isNodeJS || scripts.length || !URL)\r\n\t\t{\r\n\t\t\tworker = workers.getNew(src,evalPath);\r\n\t\t\tworker.postMessage(src);\r\n\t\t}\r\n\t\telse if(URL)\r\n\t\t{\r\n\t\t\tvar blob = new Blob([src], {type: 'text/javascript'});\r\n\t\t\tvar url = URL.createObjectURL(blob);\r\n\r\n\t\t\tworker = workers.getNew(src,url);\r\n\t\t}\r\n\r\n\t\treturn worker;\r\n\t}\r\n\r\n\tstartNew<T,U>(data:T, task:(data:T) => U, env?:any):PromiseBase<U>\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\tlet worker = _._spawnWorker(task, extend(_.options.env, env || {}));\r\n\t\tif(worker)\r\n\t\t\treturn new WorkerPromise<U>(worker, data)\r\n\t\t\t\t.finallyThis(()=>workers.recycle(worker));\r\n\r\n\t\tif(_.options.allowSynchronous)\r\n\t\t\treturn new Promise<U>(\r\n\t\t\t\t(resolve, reject)=>\r\n\t\t\t\t{\r\n\t\t\t\t\ttry\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresolve(task(data));\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\t}\r\n\r\n\r\n\tmap<T,U>(data:T[], task:(data:T) => U, env?:any):ArrayPromise<U>\r\n\t{\r\n\t\tif(!data || !data.length) return ArrayPromise.fulfilled(data && []);\r\n\r\n\t\tdata = data.slice(); // Never use the original.\r\n\t\treturn new ArrayPromise<U>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tvar result:U[] = [], len = data.length;\r\n\t\t\tresult.length = len;\r\n\r\n\t\t\tvar taskString = task.toString();\r\n\t\t\tvar {maxConcurrency} = this.options, error:any;\r\n\t\t\tlet i = 0, resolved = 0;\r\n\t\t\tfor(let w = 0; !error && i<Math.min(len, maxConcurrency); w++)\r\n\t\t\t{\r\n\t\t\t\tlet worker = this._spawnWorker(taskString, env);\r\n\r\n\t\t\t\tif(!worker)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!this.options.allowSynchronous)\r\n\t\t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\r\n\t\t\t\t\tresolve(Promise\r\n\t\t\t\t\t\t.all(data.map(d=>new Promise<U>((r, j)=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tr(task(d));\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch(ex)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tj(ex);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}))));\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet next = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(error)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(worker)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(i<len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet ii = i++;\r\n\t\t\t\t\t\t\tlet wp = new WorkerPromise<U>(worker, data[ii]);\r\n\t\t\t\t\t\t\twp\r\n\t\t\t\t\t\t\t\t.thenSynchronous(r=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresult[ii] = r;\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t}, e=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(!error)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\terror = e;\r\n\t\t\t\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.thenThis(()=>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresolved++;\r\n\t\t\t\t\t\t\t\t\tif(resolved>len) throw Error(\"Resolved count exceeds data length.\");\r\n\t\t\t\t\t\t\t\t\tif(resolved===len) resolve(result);\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.finallyThis(()=>\r\n\t\t\t\t\t\t\t\t\twp.dispose());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnext();\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tstatic get isSupported() { return _supports; }\r\n\r\n\tstatic options(options?:ParallelOptions):Parallel\r\n\t{\r\n\t\treturn new Parallel(options);\r\n\t}\r\n\r\n\tstatic require(...required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic requireThese(required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic startNew<T,U>(data:T, task:(data:T) => U, env?:any):PromiseBase<U>\r\n\t{\r\n\t\treturn (new Parallel()).startNew(data, task, env);\r\n\t}\r\n\r\n\t//\r\n\t// forEach<T>(data:T[], task:(data:T) => void, env?:any):PromiseBase<void>\r\n\t// {}\r\n\r\n\tstatic map<T,U>(data:T[], task:(data:T) => U, env?:any):ArrayPromise<U>\r\n\t{\r\n\t\treturn (new Parallel()).map(data, task, env);\r\n\t}\r\n}\r\n\r\n//\r\n// export class ParallelExtended<TEntry, T extends Array<TEntry>> extends Parallel<T>\r\n// {\r\n//\r\n// \tprivate _spawnMapWorker<N>(\r\n// \t\tdata:T,\r\n// \t\ttask:(data:N) => N,\r\n// \t\tdone:(e?:any, w?:WorkerLike)=>void,\r\n// \t\tenv:any,\r\n// \t\tworker?:WorkerLike):Promise<N>\r\n// \t{\r\n// \t\tconst _ = this;\r\n//\r\n// \t\tif(!worker) worker = _._spawnWorker(task, env);\r\n// \t\tif(worker)\r\n//\r\n// \t\t\treturn new Promise<N>(resolve=>\r\n// \t\t\t{\r\n// \t\t\t\tif(worker!==VOID0)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tinteract(\r\n// \t\t\t\t\t\tworker,\r\n// \t\t\t\t\t\t(msg:{data:any})=>\r\n// \t\t\t\t\t\t{\r\n// \t\t\t\t\t\t\tresolve(msg.data);\r\n// \t\t\t\t\t\t\tdone(null, worker);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\t(e:any)=>\r\n// \t\t\t\t\t\t{\r\n// \t\t\t\t\t\t\tdeferImmediate(()=>worker.terminate());\r\n// \t\t\t\t\t\t\tdone(e);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\t_.data[i]);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.options.allowSynchronous)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tdeferImmediate(()=>\r\n// \t\t\t\t\t{\r\n// \t\t\t\t\t\t_.data[i] = task(_.data[i]);\r\n// \t\t\t\t\t\tdone();\r\n// \t\t\t\t\t});\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n// \t\t\t\t}\r\n// \t\t\t}, true);\r\n//\r\n//\r\n// \t}\r\n//\r\n// \tprivate _spawnReduceWorker<N>(\r\n// \t\tdata:any,\r\n// \t\tcb:(data:N) => N,\r\n// \t\tdone:(err?:any, wrk?:WorkerLike)=>void,\r\n// \t\tenv?:any,\r\n// \t\twrk?:WorkerLike)\r\n// \t{\r\n// \t\tconst _ = this;\r\n// \t\tif(!wrk) wrk = _._spawnWorker(cb, env);\r\n//\r\n// \t\tif(wrk!==VOID0)\r\n// \t\t{\r\n// \t\t\tinteract(wrk,\r\n// \t\t\t\tmsg=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\t_.data[_.data.length] = msg.data;\r\n// \t\t\t\t\tdone(null, wrk);\r\n// \t\t\t\t},\r\n// \t\t\t\te=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\twrk.terminate();\r\n// \t\t\t\t\tdone(e, null);\r\n// \t\t\t\t},\r\n// \t\t\t\tdata);\r\n// \t\t}\r\n// \t\telse if(_.options.allowSynchronous)\r\n// \t\t{\r\n// \t\t\tdeferImmediate(()=>\r\n// \t\t\t{\r\n// \t\t\t\t_.data[_.data.length] = cb(data);\r\n// \t\t\t\tdone();\r\n// \t\t\t});\r\n// \t\t}\r\n// \t\telse\r\n// \t\t{\r\n// \t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n// \t\t}\r\n// \t}\r\n//\r\n//\r\n// \tmap<N>(callback:(data:N) => N, env?:any)\r\n// \t{\r\n// \t\tenv = extend(this.options.env, env || {});\r\n// \t\tconst _ = this;\r\n// \t\tif(!Array.isArray(_.data))\r\n// \t\t{\r\n// \t\t\treturn _.start(callback, env);\r\n// \t\t}\r\n//\r\n// \t\tvar startedOps = 0;\r\n// \t\tvar doneOps = 0;\r\n//\r\n// \t\t_._operation = new Promise<any>((resolve, reject)=>\r\n// \t\t{\r\n//\r\n// \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\r\n// \t\t\t{\r\n// \t\t\t\tif(err)\r\n// \t\t\t\t{\r\n// \t\t\t\t\treject(err);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(++doneOps===_.data.length)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tresolve(_.data);\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(startedOps<_.data.length)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t_._spawnMapWorker(startedOps++, callback, done, env, wrk);\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n//\r\n// \t\t\tfor(\r\n// \t\t\t\t; startedOps - doneOps<_.options.maxConcurrency && startedOps<_.data.length;\r\n// \t\t\t\t  ++startedOps\r\n// \t\t\t)\r\n// \t\t\t{\r\n// \t\t\t\t_._spawnMapWorker(startedOps, callback, done, env);\r\n// \t\t\t}\r\n// \t\t}, true);\r\n// \t\treturn this;\r\n// \t}\r\n//\r\n//\r\n// \treduce<N>(cb:(data:N[]) => N, env?:any):Parallel<T>\r\n// \t{\r\n// \t\tenv = extend(this.options.env, env || {});\r\n//\r\n// \t\tvar runningWorkers = 0;\r\n// \t\tconst _ = this;\r\n//\r\n//\r\n// \t\t_._operation = new Promise<any>((resolve, reject)=>\r\n// \t\t{\r\n//\r\n// \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\r\n// \t\t\t{\r\n// \t\t\t\t--runningWorkers;\r\n// \t\t\t\tif(err)\r\n// \t\t\t\t{\r\n// \t\t\t\t\treject(err);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length===1 && runningWorkers===0)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tresolve(_.data = _.data[0]);\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length>1)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[0], _.data[1]], cb, done, env, wrk);\r\n// \t\t\t\t\t_.data.splice(0, 2);\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n//\r\n// \t\t\tif(_.data.length===1)\r\n// \t\t\t{\r\n// \t\t\t\tresolve(_.data[0]);\r\n// \t\t\t}\r\n// \t\t\telse\r\n// \t\t\t{\r\n// \t\t\t\tfor(var i = 0; i<_.options.maxConcurrency && i<Math.floor(_.data.length/2); ++i)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[i*2], _.data[i*2 + 1]], cb, done, env);\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\t_.data.splice(0, i*2);\r\n// \t\t\t}\r\n// \t\t}, true);\r\n// \t\treturn this;\r\n//\r\n// \t}\r\n//\r\n//\r\n// }\r\n\r\nexport default Parallel;\r\n"]}