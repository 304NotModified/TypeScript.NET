{"version":3,"sources":["System/Integer.js","System/Integer.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Integer","n","Types_1","ArgumentException_1","ArgumentOutOfRangeException_1","r","max","Math","random","assert","is","isNumber","isFinite","argumentName","i","assertZeroOrGreater","assertPositive","under","boundary","select","source","length","Object","defineProperty","value"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,UAAW,iCAAkC,4CAA6CN,IAE7H,SAAUI,EAASF,GAClB,YCHJ,SAAAM,GAAiBC,GAEhB,MAAW,GAAJA,EANR,GASOD,GATPE,EAAAN,EAAiB,WACjBO,EAAAP,EAA8B,kCAC9BQ,EAAAR,EAAwC,6CAOxC,SAAOI,GAGN,QAAAK,GAAWC,GAEV,MAAQC,MAAKC,SAASF,EAAO,EAc9B,QAAAE,GAAuBF,GAGtB,MADAG,GAAOH,EAAK,OACJ,GAALA,EAAe,GAClBA,GAAOA,EAAI,EAAI,EAAI,GACZD,EAAEC,IA+BV,QAAAI,GAAmBT,GAElB,MAAOC,GAAAA,WAAKS,SAASV,GAAG,IAAUW,SAASX,IAAMA,IAAQ,EAAJA,GAGtD,QAAAQ,GAAuBR,EAAUY,GAEhC,GAAIC,GAAIJ,EAAGT,EACX,KAAIa,EACH,KAAM,IAAIX,GAAAA,WAAkBU,GAAgB,IAAK,qBAClD,OAAOC,GAGR,QAAAC,GAAoCd,EAAUY,GAE7C,GAAIC,GAAIL,EAAOR,EAAGY,IAAiBZ,GAAG,CACtC,KAAIa,EACH,KAAM,IAAIV,GAAAA,WAA4BS,GAAgB,IAAKZ,EAAG,4BAC/D,OAAOa,GAGR,QAAAE,GAA+Bf,EAAUY,GAExC,GAAIC,GAAIL,EAAOR,EAAGY,IAAiBZ,EAAE,CACrC,KAAIa,EACH,KAAM,IAAIV,GAAAA,WAA4BS,GAAgB,IAAKZ,EAAG,6BAC/D,OAAOa,GA9DQd,EAAAQ,OAAMA,CAQtB,IAAcA,IAAd,SAAcA,GAcb,QAAAS,GAAsBC,GAErB,MAAOb,GAAEa,GAGV,QAAAC,GAA0BC,GAEzB,MAAOA,IAAUA,EAAOC,OACrBD,EAAOf,EAAEe,EAAOC,SAChB,OATYb,EAAAS,MAAKA,EAKLT,EAAAW,OAAMA,GAnBTX,EAAAR,EAAAQ,SAAAR,EAAAQ,YA4BER,EAAAU,GAAEA,EAKFV,EAAAS,OAAMA,EAQNT,EAAAe,oBAAmBA,EAQnBf,EAAAgB,eAAcA,GA5ExBhB,IAAAA,OAsFPsB,OAAAC,eAAA7B,EAAA,cAAA8B,OAAA,ID5BI9B,EAAAA,WC4BWM","file":"System/Integer.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"./Types\", \"./Exceptions/ArgumentException\", \"./Exceptions/ArgumentOutOfRangeException\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Types_1 = require(\"./Types\");\n    var ArgumentException_1 = require(\"./Exceptions/ArgumentException\");\n    var ArgumentOutOfRangeException_1 = require(\"./Exceptions/ArgumentOutOfRangeException\");\n    function Integer(n) {\n        return n | 0;\n    }\n    var Integer;\n    (function (Integer) {\n        function r(max) {\n            return (Math.random() * max) | 0;\n        }\n        function random(max) {\n            assert(max, 'max');\n            if (max == 0)\n                return 0;\n            max += max > 0 ? 1 : -1;\n            return r(max);\n        }\n        Integer.random = random;\n        var random;\n        (function (random) {\n            function under(boundary) {\n                return r(boundary);\n            }\n            random.under = under;\n            function select(source) {\n                return source && source.length\n                    ? source[r(source.length)]\n                    : void (0);\n            }\n            random.select = select;\n        })(random = Integer.random || (Integer.random = {}));\n        function is(n) {\n            return Types_1.default.isNumber(n, false) && isFinite(n) && n == (n | 0);\n        }\n        Integer.is = is;\n        function assert(n, argumentName) {\n            var i = is(n);\n            if (!i)\n                throw new ArgumentException_1.default(argumentName || 'n', \"Must be a integer.\");\n            return i;\n        }\n        Integer.assert = assert;\n        function assertZeroOrGreater(n, argumentName) {\n            var i = assert(n, argumentName) && n >= 0;\n            if (!i)\n                throw new ArgumentOutOfRangeException_1.default(argumentName || 'n', n, \"Cannot be less than zero.\");\n            return i;\n        }\n        Integer.assertZeroOrGreater = assertZeroOrGreater;\n        function assertPositive(n, argumentName) {\n            var i = assert(n, argumentName) && n > 0;\n            if (!i)\n                throw new ArgumentOutOfRangeException_1.default(argumentName || 'n', n, \"Must be greater than zero.\");\n            return i;\n        }\n        Integer.assertPositive = assertPositive;\n    })(Integer || (Integer = {}));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Integer;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport Type from \"./Types\";\r\nimport ArgumentException from \"./Exceptions/ArgumentException\";\r\nimport ArgumentOutOfRangeException from \"./Exceptions/ArgumentOutOfRangeException\";\r\n\r\nfunction Integer(n:number):number\r\n{\r\n\treturn n | 0;\r\n}\r\n\r\nmodule Integer\r\n{\r\n\r\n\tfunction r(max:number):number\r\n\t{\r\n\t\treturn (Math.random()*max) | 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random integer from zero to the max.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * Examples:<br/>\r\n\t * ```Integer.random(1)``` will return 0 or 1.<br/>\r\n\t * ```Integer.random(-2)``` will return 0, -1, or -2.<br/>\r\n\t *\r\n\t * @param max\r\n\t * @returns {number}\r\n\t */\r\n\texport function random(max:number):number\r\n\t{\r\n\t\tassert(max, 'max');\r\n\t\tif(max==0) return 0;\r\n\t\tmax += max>0 ? 1 : -1;\r\n\t\treturn r(max);\r\n\t}\r\n\r\n\texport module random\r\n\t{\r\n\r\n\t\t/**\r\n\t\t * Returns a random integer from zero up to the boundary value.\r\n\t\t * Negative and fractional numbers are allowed.\r\n\t\t *\r\n\t\t * Example:<br/>\r\n\t\t * ```Integer.random(-2)``` will return 0, or -1.<br/>\r\n\t\t * ```Integer.random(5)``` will return 0, 1, 2, 3 or 4.<br/>\r\n\t\t *\r\n\t\t * @param boundary\r\n\t\t * @returns {number}\r\n\t\t */\r\n\t\texport function under(boundary:number):number\r\n\t\t{\r\n\t\t\treturn r(boundary)\r\n\t\t}\r\n\r\n\t\texport function select<T>(source:T[]):T\r\n\t\t{\r\n\t\t\treturn source && source.length\r\n\t\t\t\t? source[r(source.length)]\r\n\t\t\t\t: void(0);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport function is(n:number):boolean\r\n\t{\r\n\t\treturn Type.isNumber(n, false) && isFinite(n) && n==(n | 0);\r\n\t}\r\n\r\n\texport function assert(n:number, argumentName?:string):boolean\r\n\t{\r\n\t\tvar i = is(n);\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentException(argumentName || 'n', \"Must be a integer.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n\texport function assertZeroOrGreater(n:number, argumentName?:string):boolean\r\n\t{\r\n\t\tvar i = assert(n, argumentName) && n>=0;\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentOutOfRangeException(argumentName || 'n', n, \"Cannot be less than zero.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n\texport function assertPositive(n:number, argumentName?:string):boolean\r\n\t{\r\n\t\tvar i = assert(n, argumentName) && n>0;\r\n\t\tif(!i)\r\n\t\t\tthrow new ArgumentOutOfRangeException(argumentName || 'n', n, \"Must be greater than zero.\");\r\n\t\treturn i;\r\n\t}\r\n\r\n}\r\n\r\nexport default Integer;\r\n"]}