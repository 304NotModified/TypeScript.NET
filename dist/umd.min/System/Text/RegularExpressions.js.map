{"version":3,"sources":["System/Text/RegularExpressions.js","System/Text/RegularExpressions.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","RegexOptions","EMPTY","UNDEFINED","IGNORE_CASE","GLOBAL","MULTI_LINE","UNICODE","STICKY","Regex","pattern","options","Error","patternString","flags","join","RegExp","ignoreCase","indexOf","multiline","source","replace","keys","k","match","i","len","length","_keys","_re","freeze","input","_","r","exec","Match","Empty","loc","index","groups","groupMap","text","String","g","Group","push","m","matches","success","substring","isMatch","test","e","Capture","value","defineProperty","get","enumerable","configurable","_super","call","EmptyGroup","namedGroups","slice","EmptyMatch"],"mappings":"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","file":"System/Text/RegularExpressions.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var EMPTY = \"\";\n    var UNDEFINED = \"undefined\";\n    var RegexOptions;\n    (function (RegexOptions) {\n        RegexOptions.IGNORE_CASE = 'i';\n        RegexOptions.GLOBAL = 'g';\n        RegexOptions.MULTI_LINE = 'm';\n        RegexOptions.UNICODE = 'u';\n        RegexOptions.STICKY = 'y';\n    })(RegexOptions = exports.RegexOptions || (exports.RegexOptions = {}));\n    var Regex = (function () {\n        function Regex(pattern, options) {\n            if (!pattern)\n                throw new Error(\"'pattern' cannot be null or empty.\");\n            var patternString, flags = options && options.join(EMPTY) || EMPTY;\n            if (pattern instanceof RegExp) {\n                var p = pattern;\n                if (p.ignoreCase && flags.indexOf(RegexOptions.IGNORE_CASE) === -1)\n                    flags\n                        += RegexOptions.IGNORE_CASE;\n                if (p.multiline && flags.indexOf(RegexOptions.MULTI_LINE) === -1)\n                    flags\n                        += RegexOptions.MULTI_LINE;\n                patternString = p.source;\n            }\n            else {\n                patternString = pattern;\n            }\n            flags = flags.replace(RegexOptions.GLOBAL, EMPTY);\n            var keys = [];\n            {\n                var k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\n                if (k) {\n                    for (var i = 0, len = k.length; i < len; i++) {\n                        keys[i + 1] = k[i];\n                    }\n                    this._keys = keys;\n                    this._re = new RegExp(patternString.replace(/\\?<\\w+>/g, EMPTY), flags);\n                }\n                else {\n                    this._keys = null;\n                    this._re = new RegExp(patternString, flags);\n                }\n            }\n            Object.freeze(this);\n        }\n        Regex.prototype.match = function (input) {\n            var _ = this;\n            var r = this._re.exec(input);\n            if (!r)\n                return Match.Empty;\n            var loc = r.index, groups = [], groupMap = {};\n            for (var i = 0, len = r.length; i < len; ++i) {\n                var text = typeof r[i] !== UNDEFINED && r[i].constructor === String ? r[i] : EMPTY;\n                var g = new Group(text, loc);\n                g.freeze();\n                if (i && _._keys && i < _._keys.length)\n                    groupMap[_._keys[i]] = g;\n                groups.push(g);\n                if (i !== 0)\n                    loc += text.length;\n            }\n            var m = new Match(r[0], r.index, groups, groupMap);\n            m.freeze();\n            return m;\n        };\n        Regex.prototype.matches = function (input) {\n            var matches = [], m;\n            while ((m = this.match(input)) && m.success) {\n                matches.push(m);\n                input = input.substring(m.index + m.length);\n            }\n            return matches;\n        };\n        Regex.prototype.replace = function (input, r) {\n            return input.replace(this._re, r);\n        };\n        Regex.prototype.isMatch = function (input) {\n            return this._re.test(input);\n        };\n        Regex.isMatch = function (input, pattern, options) {\n            var r = new Regex(pattern, options);\n            return r.isMatch(input);\n        };\n        Regex.replace = function (input, pattern, e, options) {\n            var r = new Regex(pattern, options);\n            return r.replace(input, e);\n        };\n        return Regex;\n    }());\n    exports.Regex = Regex;\n    var Capture = (function () {\n        function Capture(value, index) {\n            if (value === void 0) { value = EMPTY; }\n            if (index === void 0) { index = -1; }\n            this.value = value;\n            this.index = index;\n        }\n        Object.defineProperty(Capture.prototype, \"length\", {\n            get: function () {\n                var v = this.value;\n                return v && v.length || 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Capture.prototype.freeze = function () {\n            Object.freeze(this);\n        };\n        return Capture;\n    }());\n    exports.Capture = Capture;\n    var Group = (function (_super) {\n        __extends(Group, _super);\n        function Group(value, index) {\n            if (value === void 0) { value = EMPTY; }\n            if (index === void 0) { index = -1; }\n            _super.call(this, value, index);\n        }\n        Object.defineProperty(Group.prototype, \"success\", {\n            get: function () {\n                return this.index != -1;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Group, \"Empty\", {\n            get: function () {\n                return EmptyGroup;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return Group;\n    }(Capture));\n    exports.Group = Group;\n    var EmptyGroup = new Group();\n    var Match = (function (_super) {\n        __extends(Match, _super);\n        function Match(value, index, groups, namedGroups) {\n            if (value === void 0) { value = EMPTY; }\n            if (index === void 0) { index = -1; }\n            if (groups === void 0) { groups = []; }\n            if (namedGroups === void 0) { namedGroups = {}; }\n            _super.call(this, value, index);\n            this.groups = groups;\n            this.namedGroups = namedGroups;\n        }\n        Match.prototype.freeze = function () {\n            if (!this.groups)\n                throw new Error(\"'groups' cannot be null.\");\n            if (!this.namedGroups)\n                throw new Error(\"'groupMap' cannot be null.\");\n            Object.freeze(this.groups.slice());\n            Object.freeze(this.namedGroups);\n            _super.prototype.freeze.call(this);\n        };\n        Object.defineProperty(Match, \"Empty\", {\n            get: function () {\n                return EmptyMatch;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return Match;\n    }(Group));\n    exports.Match = Match;\n    var EmptyMatch = new Match();\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Regex;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Named groups based on: http://trentrichardson.com/2011/08/02/javascript-regexp-match-named-captures/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"../Collections/Dictionaries/IDictionary\"/>\r\n\r\n// NOTE: Avoid dependencies so this class can be used cleanly.\r\n\r\nconst EMPTY:string = \"\";\r\nconst UNDEFINED:string = \"undefined\";\r\n\r\n\r\n/**\r\n * https://msdn.microsoft.com/en-us/library/system.text.regularexpressions.regexoptions%28v=vs.110%29.aspx\r\n */\r\nexport module RegexOptions\r\n{\r\n\t/**\r\n\t * Specifies case-insensitive matching. For more information, see the \"Case-Insensitive Matching \" section in the Regular Expression Options topic.\r\n\t */\r\n\texport const IGNORE_CASE:string = 'i';\r\n\r\n\t/**\r\n\t * Specifies global matching instead of single.\r\n\t */\r\n\texport const GLOBAL:string = 'g';\r\n\r\n\t/**\r\n\t * treat beginning and end characters (^ and $) as working over multiple lines (i.e., match the beginning or end of each line (delimited by \\n or \\r), not only the very beginning or end of the whole input string)\r\n\t */\r\n\texport const MULTI_LINE:string = 'm';\r\n\r\n\t/**\r\n\t * treat pattern as a sequence of unicode code points\r\n\t */\r\n\texport const UNICODE:string = 'u';\r\n\r\n\t/**\r\n\t * matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\r\n\t */\r\n\texport const STICKY:string = 'y';\r\n\r\n\texport type Global = 'g';\r\n\texport type IgnoreCase = 'i';\r\n\texport type MultiLine = 'm';\r\n\texport type Unicode = 'u';\r\n\texport type Sticky = 'y';\r\n\r\n\texport type Literal = Global | IgnoreCase | MultiLine | Unicode | Sticky;\r\n}\r\n\r\nexport interface MatchEvaluator\r\n{\r\n\t//(match:Match):string;\r\n\t(substring:string, ...args:any[]):string;\r\n}\r\n\r\nexport class Regex\r\n{\r\n\tprivate _re:RegExp;\r\n\tprivate _keys:string[];\r\n\r\n\tconstructor(\r\n\t\tpattern:string|RegExp,\r\n\t\toptions?:RegexOptions.Literal[])\r\n\t{\r\n\t\tif(!pattern) throw new Error(\"'pattern' cannot be null or empty.\");\r\n\t\tvar patternString:string, flags:string = options && options.join(EMPTY) || EMPTY;\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tlet p = <RegExp>pattern;\r\n\t\t\tif(p.ignoreCase && flags.indexOf(RegexOptions.IGNORE_CASE)=== -1) flags\r\n\t\t\t\t+= RegexOptions.IGNORE_CASE;\r\n\t\t\tif(p.multiline && flags.indexOf(RegexOptions.MULTI_LINE)=== -1) flags\r\n\t\t\t\t+= RegexOptions.MULTI_LINE;\r\n\t\t\tpatternString = p.source;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpatternString = pattern;\r\n\t\t}\r\n\r\n\t\t// For the majority of expected behavior, we need to eliminate global.\r\n\t\tflags = flags.replace(RegexOptions.GLOBAL, EMPTY);\r\n\r\n\t\t// find the keys inside the pattern, and place in mapping array {0:'key1', 1:'key2', ...}\r\n\t\tvar keys:string[] = [];\r\n\t\t{\r\n\t\t\tlet k = patternString.match(/(?!\\(\\?<)(\\w+)(?=>)/g);\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tfor(let i = 0, len = k.length; i<len; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys[i+1] = k[i];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._keys = keys;\r\n\t\t\t\t// remove keys from regexp leaving standard regexp\r\n\t\t\t\tthis._re = new RegExp(patternString.replace(/\\?<\\w+>/g, EMPTY), flags);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis._keys = null;\r\n\t\t\t\tthis._re = new RegExp(patternString, flags);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tmatch(input:string):Match\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar r = this._re.exec(input);\r\n\t\tif(!r) return Match.Empty;\r\n\r\n\t\tvar loc                  = r.index,\r\n\t\t    groups:Group[]       = [],\r\n\t\t    groupMap:IMap<Group> = {};\r\n\r\n\t\tfor(let i = 0, len = r.length; i<len; ++i)\r\n\t\t{\r\n\t\t\tlet text = typeof r[i]!==UNDEFINED && r[i].constructor===String ? r[i] : EMPTY;\r\n\t\t\tlet g = new Group(text, loc);\r\n\t\t\tg.freeze();\r\n\t\t\tif(i && _._keys && i<_._keys.length) groupMap[_._keys[i]] = g;\r\n\t\t\tgroups.push(g);\r\n\t\t\tif(i!==0) loc += text.length;\r\n\t\t}\r\n\r\n\t\tvar m = new Match(r[0], r.index, groups, groupMap);\r\n\t\tm.freeze();\r\n\t\treturn m;\r\n\t}\r\n\r\n\tmatches(input:string):Match[]\r\n\t{\r\n\t\tvar matches:Match[] = [], m:Match;\r\n\t\twhile((m = this.match(input)) && m.success) {\r\n\t\t\tmatches.push(m);\r\n\t\t\tinput = input.substring(m.index+m.length);\r\n\t\t}\r\n\r\n\t\treturn matches;\r\n\t}\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\treplacement:string):string;\r\n\r\n\treplace(\r\n\t\tinput:string,\r\n\t\tevaluator:MatchEvaluator):string;\r\n\r\n\treplace(\r\n\t\tinput:string, r:any):string\r\n\t{\r\n\t\treturn input.replace(this._re, r);\r\n\t}\r\n\r\n\tisMatch(input:string):boolean\r\n\t{\r\n\t\treturn this._re.test(input);\r\n\t}\r\n\r\n\tstatic isMatch(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\toptions?:RegexOptions.Literal[]):boolean\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.isMatch(input);\r\n\t}\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\treplacement:string,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\tevaluator:MatchEvaluator,\r\n\t\toptions?:RegexOptions.Literal[]):string;\r\n\r\n\tstatic replace(\r\n\t\tinput:string,\r\n\t\tpattern:string,\r\n\t\te:any,\r\n\t\toptions?:RegexOptions.Literal[]):string\r\n\t{\r\n\t\tvar r = new Regex(pattern, options);\r\n\t\treturn r.replace(input, e);\r\n\t}\r\n}\r\n\r\nexport class Capture\r\n{\r\n\r\n\tget length():number\r\n\t{\r\n\t\tvar v = this.value;\r\n\t\treturn v && v.length || 0;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tpublic value:string = EMPTY,\r\n\t\tpublic index:number = -1)\r\n\t{\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n}\r\n\r\nexport class Group extends Capture\r\n{\r\n\tget success():boolean\r\n\t{\r\n\t\treturn this.index!= -1;\r\n\t}\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1)\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tstatic get Empty():Group\r\n\t{\r\n\t\treturn EmptyGroup;\r\n\t}\r\n\r\n}\r\nconst EmptyGroup = new Group();\r\n\r\nexport class Match extends Group\r\n{\r\n\r\n\tconstructor(\r\n\t\tvalue:string = EMPTY,\r\n\t\tindex:number = -1,\r\n\t\tpublic groups:Group[] = [],\r\n\t\tpublic namedGroups:IMap<Group> = {})\r\n\t{\r\n\t\tsuper(value, index);\r\n\t}\r\n\r\n\tfreeze():void\r\n\t{\r\n\t\tif(!this.groups) throw new Error(\"'groups' cannot be null.\");\r\n\t\tif(!this.namedGroups) throw new Error(\"'groupMap' cannot be null.\");\r\n\t\tObject.freeze(this.groups.slice());\r\n\t\tObject.freeze(this.namedGroups);\r\n\t\tsuper.freeze();\r\n\t}\r\n\r\n\tstatic get Empty():Match\r\n\t{\r\n\t\treturn EmptyMatch;\r\n\t}\r\n}\r\nconst EmptyMatch = new Match();\r\n\r\n\r\n\r\n\r\nexport default Regex;"]}