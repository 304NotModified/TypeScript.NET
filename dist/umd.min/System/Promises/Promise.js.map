{"version":3,"sources":["System/Promises/Promise.js","System/Promises/Promise.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","isPromise","value","Types_1","hasMemberOfType","THEN","FUNCTION","resolve","resolver","promiseFactory","nextValue","Promise","wrap","pass","source","dest","then","e","reject","handleResolution","ex","handleDispatch","onFulfilled","onRejected","thenThis","deferImmediate_1","defer_1","DisposableBase_1","InvalidOperationException_1","ArgumentException_1","ArgumentNullException_1","ObjectPool_1","Set_1","VOID0","PROMISE","PROMISE_STATE","TARGET","PromiseState","_super","_state","_result","_error","call","_disposableObjectName","_onDispose","getState","defineProperty","get","enumerable","configurable","State","Pending","Fulfilled","Rejected","getResult","throwIfDisposed","getError","DisposableBase","PromiseBase","deferAll","SubsequentDeferred","defer","pending","deferImmediate","delay","milliseconds","fin","finallyThis","Resolvable","apply","arguments","state","Error","Resolved","result","error","PromiseWrapper","_target","_this","ArgumentNullException","ArgumentException","t","resolveImmediate","resolveUsing","_waiting","push","pools","PromiseCallbacks","init","_resolvedCalled","deferResolution","throwIfSettled","InvalidOperationException","rejectHandler","reason","fulfillHandler","r","o","_i","o_1","length","c","promise","recycle","o_2","_parent","_onDisposed","LazyResolved","_factory","LazyPromise","_resolver","_onThen","dispose","getPool","pool","ObjectPool","take","__wasDisposed","add","all","first","rest","promises","Array","isArray","concat","every","len","i","parent","remaining","Set","map","cleanup","checkIfShouldResolve","count","onFulfill","remove","onReject","_loop_1","p_1","race","filter","isResolved","isSettled","onResolve","promises_1","p_2","target","createFrom","freeze","lazy"],"mappings":"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","file":"System/Promises/Promise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n * Although most of the following code is written from scratch, it is\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../Types\", \"../Tasks/deferImmediate\", \"../Tasks/defer\", \"../Disposable/DisposableBase\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentException\", \"../Exceptions/ArgumentNullException\", \"../Disposable/ObjectPool\", \"../Collections/Set\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Types_1 = require(\"../Types\");\n    var deferImmediate_1 = require(\"../Tasks/deferImmediate\");\n    var defer_1 = require(\"../Tasks/defer\");\n    var DisposableBase_1 = require(\"../Disposable/DisposableBase\");\n    var InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\n    var ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\n    var ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\n    var ObjectPool_1 = require(\"../Disposable/ObjectPool\");\n    var Set_1 = require(\"../Collections/Set\");\n    var VOID0 = void 0, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\n    function isPromise(value) {\n        return Types_1.default.hasMemberOfType(value, THEN, Types_1.default.FUNCTION);\n    }\n    function resolve(value, resolver, promiseFactory) {\n        var nextValue = resolver\n            ? resolver(value)\n            : value;\n        return nextValue && isPromise(nextValue)\n            ? Promise.wrap(nextValue)\n            : promiseFactory(nextValue);\n    }\n    function pass(source, dest) {\n        return function () {\n            source.then(function (v) {\n                dest.resolve(v);\n                return dest;\n            }, function (e) {\n                dest.reject(e);\n                return dest;\n            });\n        };\n    }\n    function handleResolution(p, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (p)\n                p.resolve(v);\n        }\n        catch (ex) {\n            p.reject(ex);\n        }\n    }\n    function handleDispatch(p, onFulfilled, onRejected) {\n        if (p instanceof Promise)\n            p.thenThis(onFulfilled, onRejected);\n        else\n            p.then(onFulfilled, onRejected);\n    }\n    var PromiseState = (function (_super) {\n        __extends(PromiseState, _super);\n        function PromiseState(_state, _result, _error) {\n            _super.call(this);\n            this._state = _state;\n            this._result = _result;\n            this._error = _error;\n            this._disposableObjectName = PROMISE_STATE;\n        }\n        PromiseState.prototype._onDispose = function () {\n            this._state = VOID0;\n            this._result = VOID0;\n            this._error = VOID0;\n        };\n        PromiseState.prototype.getState = function () {\n            return this._state;\n        };\n        Object.defineProperty(PromiseState.prototype, \"state\", {\n            get: function () {\n                return this._state;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isPending\", {\n            get: function () {\n                return this.getState() === Promise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isSettled\", {\n            get: function () {\n                return this.getState() != Promise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isFulfilled\", {\n            get: function () {\n                return this.getState() === Promise.State.Fulfilled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isRejected\", {\n            get: function () {\n                return this.getState() === Promise.State.Rejected;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getResult = function () {\n            return this._result;\n        };\n        Object.defineProperty(PromiseState.prototype, \"result\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getResult();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getError = function () {\n            return this._error;\n        };\n        Object.defineProperty(PromiseState.prototype, \"error\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getError();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return PromiseState;\n    }(DisposableBase_1.DisposableBase));\n    exports.PromiseState = PromiseState;\n    var PromiseBase = (function (_super) {\n        __extends(PromiseBase, _super);\n        function PromiseBase() {\n            _super.call(this, Promise.State.Pending);\n            this._disposableObjectName = PROMISE;\n        }\n        PromiseBase.prototype.deferAll = function () {\n            this.throwIfDisposed();\n            return new SubsequentDeferred(this);\n        };\n        PromiseBase.prototype.defer = function () {\n            this.throwIfDisposed();\n            var p = Promise.pending();\n            deferImmediate_1.deferImmediate(pass(this, p));\n            return p;\n        };\n        PromiseBase.prototype.delay = function (milliseconds) {\n            this.throwIfDisposed();\n            var p = Promise.pending();\n            defer_1.defer(pass(this, p), milliseconds);\n            return p;\n        };\n        PromiseBase.prototype['catch'] = function (onRejected) {\n            this.throwIfDisposed();\n            return this.then(VOID0, onRejected);\n        };\n        PromiseBase.prototype['finally'] = function (fin) {\n            this.throwIfDisposed();\n            return this.then(fin, fin);\n        };\n        PromiseBase.prototype.finallyThis = function (fin) {\n            this.thenThis(fin, fin);\n            return this;\n        };\n        return PromiseBase;\n    }(PromiseState));\n    exports.PromiseBase = PromiseBase;\n    var Resolvable = (function (_super) {\n        __extends(Resolvable, _super);\n        function Resolvable() {\n            _super.apply(this, arguments);\n        }\n        Resolvable.prototype.then = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            try {\n                switch (this.state) {\n                    case Promise.State.Fulfilled:\n                        return onFulfilled\n                            ? resolve(this._result, onFulfilled, Promise.resolve)\n                            : this;\n                    case Promise.State.Rejected:\n                        return onRejected\n                            ? resolve(this._error, onRejected, Promise.resolve)\n                            : this;\n                }\n            }\n            catch (ex) {\n                return new Rejected(ex);\n            }\n            throw new Error(\"Invalid state for a resolved promise.\");\n        };\n        Resolvable.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            switch (this.state) {\n                case Promise.State.Fulfilled:\n                    if (onFulfilled)\n                        onFulfilled(this._result);\n                    break;\n                case Promise.State.Rejected:\n                    if (onRejected)\n                        onRejected(this._error);\n                    break;\n            }\n            return this;\n        };\n        return Resolvable;\n    }(PromiseBase));\n    exports.Resolvable = Resolvable;\n    var Resolved = (function (_super) {\n        __extends(Resolved, _super);\n        function Resolved(state, result, error) {\n            _super.call(this);\n            this._result = result;\n            this._error = error;\n            this._state = state;\n        }\n        return Resolved;\n    }(Resolvable));\n    exports.Resolved = Resolved;\n    var Fulfilled = (function (_super) {\n        __extends(Fulfilled, _super);\n        function Fulfilled(value) {\n            _super.call(this, Promise.State.Fulfilled, value);\n        }\n        return Fulfilled;\n    }(Resolved));\n    var Rejected = (function (_super) {\n        __extends(Rejected, _super);\n        function Rejected(error) {\n            _super.call(this, Promise.State.Rejected, VOID0, error);\n        }\n        return Rejected;\n    }(Resolved));\n    var PromiseWrapper = (function (_super) {\n        __extends(PromiseWrapper, _super);\n        function PromiseWrapper(_target) {\n            var _this = this;\n            _super.call(this);\n            this._target = _target;\n            if (!_target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            if (!isPromise(_target))\n                throw new ArgumentException_1.ArgumentException(TARGET, \"Must be a promise-like object.\");\n            _target.then(function (v) {\n                _this._state = Promise.State.Fulfilled;\n                _this._result = v;\n                _this._error = VOID0;\n                _this._target = VOID0;\n            }, function (e) {\n                _this._state = Promise.State.Rejected;\n                _this._error = e;\n                _this._target = VOID0;\n            });\n        }\n        PromiseWrapper.prototype.then = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.then.call(this, onFulfilled, onRejected);\n            var p = Promise.pending();\n            handleDispatch(t, function (result) { return handleResolution(p, result, onFulfilled); }, function (error) { return onRejected ? handleResolution(p, error, onRejected) : p.reject(error); });\n            return p;\n        };\n        PromiseWrapper.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n            handleDispatch(t, onFulfilled, onRejected);\n            return this;\n        };\n        PromiseWrapper.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._target = VOID0;\n        };\n        return PromiseWrapper;\n    }(Resolvable));\n    var Promise = (function (_super) {\n        __extends(Promise, _super);\n        function Promise(resolver, resolveImmediate) {\n            if (resolveImmediate === void 0) { resolveImmediate = false; }\n            _super.call(this);\n            if (resolver)\n                this.resolveUsing(resolver, !resolveImmediate);\n        }\n        Promise.prototype.then = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            if (this._state)\n                return _super.prototype.then.call(this, onFulfilled, onRejected);\n            var p = new Promise();\n            (this._waiting || (this._waiting = []))\n                .push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\n            return p;\n        };\n        Promise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            if (this._state)\n                return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n            (this._waiting || (this._waiting = []))\n                .push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\n            return this;\n        };\n        Promise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolvedCalled = VOID0;\n        };\n        Promise.prototype.resolveUsing = function (resolver, deferResolution, throwIfSettled) {\n            var _this = this;\n            if (deferResolution === void 0) { deferResolution = false; }\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            if (!resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            if (this._resolvedCalled)\n                throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n            if (this.state)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\n            this._resolvedCalled = true;\n            var rejectHandler = function (reason) {\n                _this._resolvedCalled = false;\n                _this.reject(reason);\n            };\n            var fulfillHandler = function (v) {\n                _this._resolvedCalled = false;\n                _this.resolve(v);\n            };\n            var r = function () { return resolver(function (v) {\n                if (v == _this)\n                    throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n                if (isPromise(v))\n                    handleDispatch(v, fulfillHandler, rejectHandler);\n                else\n                    fulfillHandler(v);\n            }, rejectHandler); };\n            if (deferResolution)\n                deferImmediate_1.deferImmediate(r);\n            else\n                r();\n        };\n        Promise.prototype.resolve = function (result, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (result == this)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n            if (this._state) {\n                if (!throwIfSettled || this._state == Promise.State.Fulfilled && this._result === result)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._state = Promise.State.Fulfilled;\n            this._result = result;\n            this._error = VOID0;\n            var o = this._waiting;\n            if (o) {\n                this._waiting = VOID0;\n                for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n                    var c = o_1[_i];\n                    var onFulfilled = c.onFulfilled, promise = c.promise, p = promise;\n                    pools.PromiseCallbacks.recycle(c);\n                    handleResolution(p, result, onFulfilled);\n                }\n                o.length = 0;\n            }\n        };\n        Promise.prototype.reject = function (error, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (this._state) {\n                if (!throwIfSettled || this._state == Promise.State.Rejected && this._error === error)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._state = Promise.State.Rejected;\n            this._error = error;\n            var o = this._waiting;\n            if (o) {\n                this._waiting = null;\n                for (var _i = 0, o_2 = o; _i < o_2.length; _i++) {\n                    var c = o_2[_i];\n                    var onRejected = c.onRejected, promise = c.promise, p = promise;\n                    pools.PromiseCallbacks.recycle(c);\n                    if (onRejected)\n                        handleResolution(p, error, onRejected);\n                    else\n                        p.reject(error);\n                }\n                o.length = 0;\n            }\n        };\n        return Promise;\n    }(Resolvable));\n    exports.Promise = Promise;\n    var SubsequentDeferred = (function (_super) {\n        __extends(SubsequentDeferred, _super);\n        function SubsequentDeferred(_parent) {\n            _super.call(this);\n            this._parent = _parent;\n            if (!_parent || !(_parent instanceof PromiseBase))\n                throw new ArgumentException_1.ArgumentException(TARGET, \"Must be of type Promise.\");\n        }\n        SubsequentDeferred.prototype._onDisposed = function () {\n            _super.prototype._onDispose.call(this);\n            this._parent = VOID0;\n        };\n        SubsequentDeferred.prototype.getState = function () {\n            return this._parent.state;\n        };\n        SubsequentDeferred.prototype.getResult = function () {\n            return this._parent.result;\n        };\n        SubsequentDeferred.prototype.getError = function () {\n            return this._parent.error;\n        };\n        SubsequentDeferred.prototype.then = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var d = this._parent.defer();\n            var p = d.then(onFulfilled, onRejected);\n            d.finally(function () { return pools.recycle(d); });\n            return p;\n        };\n        SubsequentDeferred.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var d = this._parent.defer();\n            d.thenThis(onFulfilled, onRejected);\n            d.finally(function () { return pools.recycle(d); });\n            return this;\n        };\n        SubsequentDeferred.prototype.defer = function () {\n            this.throwIfDisposed();\n            return this;\n        };\n        SubsequentDeferred.prototype.deferAll = function () {\n            this.throwIfDisposed();\n            return this;\n        };\n        Object.defineProperty(SubsequentDeferred.prototype, \"parent\", {\n            get: function () {\n                return this._parent;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return SubsequentDeferred;\n    }(PromiseBase));\n    var LazyResolved = (function (_super) {\n        __extends(LazyResolved, _super);\n        function LazyResolved(_factory) {\n            _super.call(this, Promise.State.Pending, VOID0);\n            this._factory = _factory;\n            if (!_factory)\n                throw new ArgumentNullException_1.ArgumentNullException(\"factory\");\n        }\n        LazyResolved.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._factory = VOID0;\n        };\n        LazyResolved.prototype.getState = function () {\n            this.getResult();\n            return this._state;\n        };\n        LazyResolved.prototype.getResult = function () {\n            if (!this._state) {\n                try {\n                    this._result = this._factory();\n                    this._state = Promise.State.Fulfilled;\n                }\n                catch (ex) {\n                    this._error = ex;\n                    this._state = Promise.State.Rejected;\n                }\n                this._factory = VOID0;\n            }\n            return this._result;\n        };\n        LazyResolved.prototype.getError = function () {\n            this.getResult();\n            return this._error;\n        };\n        LazyResolved.prototype.then = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            this.getResult();\n            return _super.prototype.then.call(this, onFulfilled, onRejected);\n        };\n        LazyResolved.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            this.getResult();\n            return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n        };\n        LazyResolved.prototype.resolve = function () {\n            this.getResult();\n            return this;\n        };\n        Object.defineProperty(LazyResolved.prototype, \"isResolved\", {\n            get: function () {\n                return !this._factory;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return LazyResolved;\n    }(Resolved));\n    exports.LazyResolved = LazyResolved;\n    var LazyPromise = (function (_super) {\n        __extends(LazyPromise, _super);\n        function LazyPromise(_resolver) {\n            _super.call(this);\n            this._resolver = _resolver;\n            if (!_resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            this._resolvedCalled = true;\n        }\n        LazyPromise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolver = VOID0;\n        };\n        LazyPromise.prototype._onThen = function () {\n            var r = this._resolver;\n            if (r) {\n                this._resolver = VOID0;\n                this._resolvedCalled = false;\n                this.resolveUsing(r, true);\n            }\n        };\n        LazyPromise.prototype.then = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.then.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n        };\n        return LazyPromise;\n    }(Promise));\n    exports.LazyPromise = LazyPromise;\n    var pools;\n    (function (pools) {\n        var pending;\n        (function (pending) {\n            var pool;\n            function getPool() {\n                return pool || (pool = new ObjectPool_1.ObjectPool(40, factory));\n            }\n            function factory() {\n                return new Promise();\n            }\n            function get() {\n                var p = getPool().take();\n                p.__wasDisposed = false;\n                p._state = Promise.State.Pending;\n                return p;\n            }\n            pending.get = get;\n            function recycle(c) {\n                if (!c)\n                    return;\n                c.dispose();\n                getPool().add(c);\n            }\n            pending.recycle = recycle;\n        })(pending = pools.pending || (pools.pending = {}));\n        function recycle(c) {\n            if (!c)\n                return;\n            if (c instanceof Promise)\n                pending.recycle(c);\n            else\n                c.dispose();\n        }\n        pools.recycle = recycle;\n        var PromiseCallbacks;\n        (function (PromiseCallbacks) {\n            var pool;\n            function getPool() {\n                return pool || (pool = new ObjectPool_1.ObjectPool(40, factory));\n            }\n            function factory() {\n                return {\n                    onFulfilled: null,\n                    onRejected: null,\n                    promise: null\n                };\n            }\n            function init(onFulfilled, onRejected, promise) {\n                var c = getPool().take();\n                c.onFulfilled = onFulfilled;\n                c.onRejected = onRejected;\n                c.promise = promise;\n                return c;\n            }\n            PromiseCallbacks.init = init;\n            function recycle(c) {\n                c.onFulfilled = null;\n                c.onRejected = null;\n                c.promise = null;\n                getPool().add(c);\n            }\n            PromiseCallbacks.recycle = recycle;\n        })(PromiseCallbacks = pools.PromiseCallbacks || (pools.PromiseCallbacks = {}));\n    })(pools || (pools = {}));\n    var Promise;\n    (function (Promise) {\n        (function (State) {\n            State[State[\"Pending\"] = 0] = \"Pending\";\n            State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n            State[State[\"Rejected\"] = -1] = \"Rejected\";\n        })(Promise.State || (Promise.State = {}));\n        var State = Promise.State;\n        Object.freeze(State);\n        function all(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new Fulfilled(promises);\n            var len = promises.length;\n            for (var i = 0; i < len; i++) {\n                var p = promises[i];\n                if (p instanceof SubsequentDeferred)\n                    promises[i] = p.parent;\n            }\n            return pending(function (resolve, reject) {\n                var checkedAll = false;\n                var result = [];\n                result.length = len;\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; }));\n                var cleanup = function () {\n                    reject = null;\n                    resolve = null;\n                    promises.length = 0;\n                    promises = null;\n                    remaining.dispose();\n                    remaining = null;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(result);\n                    }\n                };\n                var onFulfill = function (v, i) {\n                    if (resolve) {\n                        result[i] = v;\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var onReject = function (e) {\n                    var r = reject;\n                    if (r) {\n                        cleanup();\n                        r(e);\n                    }\n                };\n                var _loop_1 = function(i) {\n                    var p_1 = promises[i];\n                    if (p_1)\n                        p_1.then(function (v) { return onFulfill(v, i); }, onReject);\n                    else\n                        remaining.remove(i);\n                    checkIfShouldResolve();\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_1(i);\n                }\n            });\n        }\n        Promise.all = all;\n        function race(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            var promises = first && (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises || !promises.length || !(promises = promises.filter(function (v) { return v != null; })).length)\n                throw new ArgumentException_1.ArgumentException(\"Nothing to wait for.\");\n            var len = promises.length;\n            if (len == 1)\n                return wrap(promises[0]).defer();\n            for (var i = 0; i < len; i++) {\n                var p = promises[i];\n                if (p instanceof SubsequentDeferred)\n                    p = p.parent;\n                if (p instanceof LazyResolved) {\n                    if (p.isResolved)\n                        return p.defer();\n                }\n                else if (p instanceof Resolved || p instanceof PromiseBase && p.isSettled) {\n                    return p.defer();\n                }\n            }\n            return pending(function (resolve, reject) {\n                var cleanup = function () {\n                    reject = null;\n                    resolve = null;\n                    promises.length = 0;\n                    promises = null;\n                };\n                var onResolve = function (r, v) {\n                    if (r) {\n                        cleanup();\n                        r(v);\n                    }\n                };\n                var onFulfill = function (v) { return onResolve(resolve, v); };\n                var onReject = function (e) { return onResolve(reject, e); };\n                for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {\n                    var p_2 = promises_1[_i];\n                    if (!resolve)\n                        break;\n                    p_2.then(onFulfill, onReject);\n                }\n            });\n        }\n        Promise.race = race;\n        function resolve(value) {\n            return isPromise(value) ? wrap(value) : new Fulfilled(value);\n        }\n        Promise.resolve = resolve;\n        function reject(reason) {\n            return new Rejected(reason);\n        }\n        Promise.reject = reject;\n        var lazy;\n        (function (lazy) {\n            function resolve(factory) {\n                return new LazyResolved(factory);\n            }\n            lazy.resolve = resolve;\n            function pending(resolver) {\n                return new LazyPromise(resolver);\n            }\n            lazy.pending = pending;\n        })(lazy = Promise.lazy || (Promise.lazy = {}));\n        function wrap(target) {\n            if (!target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            return target instanceof Promise ? this : new PromiseWrapper(target);\n        }\n        Promise.wrap = wrap;\n        function createFrom(then) {\n            if (!then)\n                throw new ArgumentNullException_1.ArgumentNullException(THEN);\n            return new PromiseWrapper({ then: then });\n        }\n        Promise.createFrom = createFrom;\n        function pending(resolver) {\n            var p = pools.pending.get();\n            if (resolver)\n                p.resolveUsing(resolver);\n            return p;\n        }\n        Promise.pending = pending;\n    })(Promise = exports.Promise || (exports.Promise = {}));\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n * Although most of the following code is written from scratch, it is\r\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\r\n */\r\n\r\n/*\r\n * Note: The Promise herein does NOT defer by default.\r\n * If you require a promise to defer its result then use the .defer() or .delay(ms) methods.\r\n * The API attempts to follow ES6 style promises.\r\n */\r\n\r\nimport Type from \"../Types\";\r\nimport {Closure, Func} from \"../FunctionTypes\";\r\nimport {deferImmediate} from \"../Tasks/deferImmediate\";\r\nimport {defer} from \"../Tasks/defer\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\nimport {Set} from \"../Collections/Set\";\r\n\r\n\r\nconst VOID0:any = void 0, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\r\n\r\nfunction isPromise<T>(value:any):value is PromiseLike<T>\r\n{\r\n\treturn Type.hasMemberOfType(value, THEN, Type.FUNCTION);\r\n}\r\n\r\nfunction resolve<T>(\r\n\tvalue:Promise.Resolution<T>, resolver:(v:Promise.Resolution<T>)=>any,\r\n\tpromiseFactory:(v:any)=>PromiseBase<any>):PromiseBase<any>\r\n{\r\n\tlet nextValue = resolver\r\n\t\t? resolver(value)\r\n\t\t: value;\r\n\r\n\treturn nextValue && isPromise(nextValue)\r\n\t\t? Promise.wrap(nextValue)\r\n\t\t: promiseFactory(nextValue);\r\n}\r\n\r\nfunction pass<T>(source:PromiseBase<T>, dest:Promise<T>):Closure\r\n{\r\n\treturn ()=>\r\n\t{\r\n\t\tsource.then(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tdest.resolve(v);\r\n\t\t\t\treturn dest;\r\n\t\t\t},\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tdest.reject(e);\r\n\t\t\t\treturn dest;\r\n\t\t\t});\r\n\t}\r\n}\r\n\r\nfunction handleResolution(\r\n\tp:Promise<any>,\r\n\tvalue:Promise.Resolution<any>,\r\n\tresolver?:(v:Promise.Resolution<any>)=>any):void\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(p) p.resolve(v);\r\n\t}\r\n\tcatch(ex)\r\n\t{ p.reject(ex); }\r\n}\r\n\r\nfunction handleDispatch<T,TResult>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\tonRejected?:Promise.Reject<TResult>):void\r\n{\r\n\tif(p instanceof Promise)\r\n\t\tp.thenThis(onFulfilled, onRejected);\r\n\telse\r\n\t\tp.then(<any>onFulfilled, onRejected);\r\n}\r\n\r\nexport class PromiseState<T>\r\nextends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tprotected _state:Promise.State,\r\n\t\tprotected _result?:T,\r\n\t\tprotected _error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = PROMISE_STATE;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._state = VOID0;\r\n\t\tthis._result = VOID0;\r\n\t\tthis._error = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget state():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget isPending():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Pending;\r\n\t}\r\n\r\n\tget isSettled():boolean\r\n\t{\r\n\t\treturn this.getState()!=Promise.State.Pending; // Will also include undefined==0 aka disposed!=resolved.\r\n\t}\r\n\r\n\tget isFulfilled():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Fulfilled;\r\n\t}\r\n\r\n\tget isRejected():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Rejected;\r\n\t}\r\n\r\n\t/*\r\n\t * Providing overrides allows for special defer or lazy sub classes.\r\n\t */\r\n\tprotected getResult():T\r\n\t{\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tget result():T\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getResult();\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class PromiseBase<T>\r\nextends PromiseState<T> implements PromiseLike<T>\r\n{\r\n\tconstructor()\r\n\t{\r\n\t\tsuper(Promise.State.Pending);\r\n\t\tthis._disposableObjectName = PROMISE;\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the respective handlers once the promise is resolved.\r\n\t * For simplicity and performance this can happen synchronously unless you call .defer() before calling .then().\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract then<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>;\r\n\r\n\r\n\t/**\r\n\t * Same as then but does not return the result.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * Errors are not trapped.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>;\r\n\r\n\t/**\r\n\t * Ensures all subsequent then requests are resolved asynchronously.\r\n\t * @returns A promise that defers all subsequent then requests..\r\n\t */\r\n\tdeferAll():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new SubsequentDeferred(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Ensures any immediately following then requests will occur on next cycle or later.\r\n\t * @returns A promise that yields to the current execution and executes after.\r\n\t */\r\n\tdefer():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar p = Promise.pending<T>();\r\n\t\tdeferImmediate(pass(this, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tdelay(milliseconds?:number):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar p = Promise.pending<T>();\r\n\t\tdefer(pass(this, p), milliseconds);\r\n\t\treturn p;\r\n\t}\r\n\r\n\t'catch'<TResult>(onRejected:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this.then(VOID0, onRejected)\r\n\t}\r\n\r\n\t'finally'<TResult>(fin:()=>Promise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this.then(fin, fin);\r\n\t}\r\n\r\n\tfinallyThis(fin:()=>void):PromiseBase<T>\r\n\t{\r\n\t\tthis.thenThis(fin, fin);\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class Resolvable<T> extends PromiseBase<T>\r\n{\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tswitch(this.state)\r\n\t\t\t{\r\n\t\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\t\treturn onFulfilled\r\n\t\t\t\t\t\t? resolve(this._result, onFulfilled, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this; // Provided for catch cases.\r\n\t\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\t\treturn onRejected\r\n\t\t\t\t\t\t? resolve(this._error, onRejected, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn new Rejected<any>(ex);\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Invalid state for a resolved promise.\");\r\n\t}\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tswitch(this.state)\r\n\t\t{\r\n\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\tif(onFulfilled) onFulfilled(this._result);\r\n\t\t\t\tbreak;\r\n\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\tif(onRejected) onRejected(this._error);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The simplest usable version of a promise which returns synchronously the resolved state provided.\r\n */\r\nexport abstract class Resolved<T> extends Resolvable<T>\r\n{\r\n\tconstructor(state:Promise.State, result:T, error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._result = result;\r\n\t\tthis._error = error;\r\n\t\tthis._state = state;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * A fulfilled Resolved<T>.  Provided for readability.\r\n */\r\nclass Fulfilled<T> extends Resolved<T>\r\n{\r\n\tconstructor(value?:T)\r\n\t{\r\n\t\tsuper(Promise.State.Fulfilled, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * A rejected Resolved<T>.  Provided for readability.\r\n */\r\nclass Rejected<T> extends Resolved<T>\r\n{\r\n\tconstructor(error:any)\r\n\t{\r\n\t\tsuper(Promise.State.Rejected, VOID0, error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Provided as a means for extending the interface of other PromiseLike<T> objects.\r\n */\r\nclass PromiseWrapper<T> extends Resolvable<T>\r\n{\r\n\tconstructor(private _target:PromiseLike<T>)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(!_target)\r\n\t\t\tthrow new ArgumentNullException(TARGET);\r\n\r\n\t\tif(!isPromise(_target))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be a promise-like object.\");\r\n\r\n\t\t_target.then(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Fulfilled;\r\n\t\t\t\tthis._result = v;\r\n\t\t\t\tthis._error = VOID0;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t},\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Rejected;\r\n\t\t\t\tthis._error = e;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t})\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.then(onFulfilled, onRejected);\r\n\r\n\t\tvar p = Promise.pending<TResult>();\r\n\t\thandleDispatch(t,\r\n\t\t\tresult=>handleResolution(p, result, onFulfilled),\r\n\t\t\terror=>onRejected ? handleResolution(p, error, onRejected) : p.reject(error));\r\n\t\treturn p;\r\n\t}\r\n\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.thenThis(onFulfilled, onRejected);\r\n\t\thandleDispatch(t, onFulfilled, onRejected);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._target = VOID0;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * This promise class that facilitates pending resolution.\r\n */\r\nexport class Promise<T> extends Resolvable<T>\r\n{\r\n\r\n\tprivate _waiting:IPromiseCallbacks<any>[];\r\n\r\n\t/*\r\n\t * A note about deferring:\r\n\t * The caller can set resolveImmediate to true if they intend to initialize code that will end up being deferred itself.\r\n\t * This eliminates the extra defer that will occur internally.\r\n\t * But for the most part, resolveImmediate = false (the default) will ensure the constructor will not block.\r\n\t *\r\n\t * resolveUsing allows for the same ability but does not defer by default: allowing the caller to take on the work load.\r\n\t * If calling resolve or reject and a deferred response is desired, then use deferImmediate with a closure to do so.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tresolver?:Promise.Executor<T>,\r\n\t\tresolveImmediate:boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(resolver) this.resolveUsing(resolver, !resolveImmediate);\r\n\t}\r\n\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.then(onFulfilled, onRejected);\r\n\r\n\t\tvar p = new Promise<TResult>();\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.thenThis(onFulfilled, onRejected);\r\n\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolvedCalled = VOID0;\r\n\t}\r\n\r\n\t// Protects against double calling.\r\n\tprotected _resolvedCalled:boolean;\r\n\r\n\tresolveUsing(\r\n\t\tresolver:Promise.Executor<T>,\r\n\t\tdeferResolution:boolean = false,\r\n\t\tthrowIfSettled:boolean = false)\r\n\t{\r\n\t\tif(!resolver)\r\n\t\t\tthrow new ArgumentNullException(\"resolver\");\r\n\t\tif(this._resolvedCalled)\r\n\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\tif(this.state)\r\n\t\t\tthrow new InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\r\n\r\n\t\tthis._resolvedCalled = true;\r\n\r\n\t\tvar rejectHandler = (reason:any)=>\r\n\t\t{\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.reject(reason);\r\n\t\t};\r\n\r\n\t\tvar fulfillHandler = (v:any)=>\r\n\t\t{\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolve(v);\r\n\t\t};\r\n\r\n\t\tvar r = ()=>resolver(\r\n\t\t\tv=>\r\n\t\t\t{\r\n\t\t\t\tif(v==this) throw new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\t\t\t\tif(isPromise(v))\r\n\t\t\t\t\thandleDispatch(v, fulfillHandler, rejectHandler);\r\n\t\t\t\telse\r\n\t\t\t\t\tfulfillHandler(v);\r\n\t\t\t},\r\n\t\t\trejectHandler);\r\n\r\n\t\tif(deferResolution) deferImmediate(r);\r\n\t\telse r();\r\n\t}\r\n\r\n\tresolve(result?:T, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(<any>result==this)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Fulfilled && this._result===result) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._state = Promise.State.Fulfilled;\r\n\r\n\t\tthis._result = result;\r\n\t\tthis._error = VOID0;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = VOID0;\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onFulfilled, promise} = c, p = (<Promise<T>>promise);\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\thandleResolution(p, result, onFulfilled);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\treject(error:any, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Rejected && this._error===error) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis._state = Promise.State.Rejected;\r\n\r\n\t\tthis._error = error;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = null; // null = finished. undefined = hasn't started.\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onRejected, promise} = c, p = (<Promise<T>>promise);\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\tif(onRejected) handleResolution(p, error, onRejected);\r\n\t\t\t\telse p.reject(error);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * This promise class ensures that all subsequent then calls resolve in a deferred/async manner.\r\n * This is not intended as a promise generator.  Use Pending for deferring results.\r\n */\r\nclass SubsequentDeferred<T> extends PromiseBase<T>\r\n{\r\n\tconstructor(private _parent:PromiseBase<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_parent || !(_parent instanceof PromiseBase))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be of type Promise.\");\r\n\t}\r\n\r\n\tprotected _onDisposed():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._parent = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\treturn this._parent.state;\r\n\t}\r\n\r\n\tprotected getResult():T\r\n\t{\r\n\t\treturn this._parent.result;\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._parent.error;\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar d = this._parent.defer();\r\n\t\tvar p = d.then(onFulfilled, onRejected);\r\n\t\t// Since there is only 1 'then' for the deferred promise, cleanup immediately after.\r\n\t\td.finally(()=>pools.recycle(d));\r\n\t\treturn p;\r\n\t}\r\n\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar d = this._parent.defer();\r\n\t\td.thenThis(onFulfilled, onRejected);\r\n\t\t// Since there is only 1 'then' for the deferred promise, cleanup immediately after.\r\n\t\td.finally(()=>pools.recycle(d));\r\n\t\treturn this;\r\n\t}\r\n\r\n\tdefer():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tdeferAll():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tget parent():PromiseBase<T>\r\n\t{\r\n\t\treturn this._parent;\r\n\t}\r\n}\r\n\r\n/**\r\n * This promise class only resolves the provided factory if values are requested or state is queried.\r\n * It is considered resolved since the resolution will be generated synchronously.\r\n */\r\nexport class LazyResolved<T> extends Resolved<T>\r\n{\r\n\tconstructor(private _factory:Func<T>)\r\n\t{\r\n\t\tsuper(Promise.State.Pending, VOID0);\r\n\t\tif(!_factory) throw new ArgumentNullException(\"factory\");\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._factory = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\tthis.getResult();\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tprotected getResult():T\r\n\t{\r\n\t\tif(!this._state)\r\n\t\t{\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tthis._result = this._factory();\r\n\t\t\t\tthis._state = Promise.State.Fulfilled;\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\tthis._error = ex;\r\n\t\t\t\tthis._state = Promise.State.Rejected;\r\n\t\t\t}\r\n\t\t\tthis._factory = VOID0;\r\n\t\t}\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\tthis.getResult();\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tthis.getResult();\r\n\t\treturn super.then(onFulfilled, onRejected);\r\n\t}\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tthis.getResult();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t/**\r\n\t * This allows for synchronously triggering the factory ahead of time since calling .defer() shouldn't trigger it.\r\n\t * @returns {LazyResolved}\r\n\t */\r\n\tresolve():PromiseBase<T>\r\n\t{\r\n\t\tthis.getResult();\r\n\t\treturn this;\r\n\t}\r\n\r\n\tget isResolved():boolean\r\n\t{\r\n\t\treturn !this._factory;\r\n\t}\r\n}\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends Promise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:Promise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tvar r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r, true);\r\n\t\t}\r\n\t}\r\n\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.then(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tthenThis<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<T>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n}\r\n\r\nmodule pools\r\n{\r\n\r\n\texport module pending\r\n\t{\r\n\r\n\r\n\t\tvar pool:ObjectPool<Promise<any>>;\r\n\r\n\t\tfunction getPool()\r\n\t\t{\r\n\t\t\treturn pool || (pool = new ObjectPool<Promise<any>>(40, factory));\r\n\t\t}\r\n\r\n\t\tfunction factory():Promise<any>\r\n\t\t{\r\n\t\t\treturn new Promise();\r\n\t\t}\r\n\r\n\t\texport function get():Promise<any>\r\n\t\t{\r\n\t\t\tvar p:any = getPool().take();\r\n\t\t\tp.__wasDisposed = false;\r\n\t\t\tp._state = Promise.State.Pending;\r\n\t\t\treturn p;\r\n\t\t}\r\n\r\n\t\texport function recycle<T>(c:Promise<T>):void\r\n\t\t{\r\n\t\t\tif(!c) return;\r\n\t\t\tc.dispose();\r\n\t\t\tgetPool().add(c);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport function recycle<T>(c:PromiseBase<T>):void\r\n\t{\r\n\t\tif(!c) return;\r\n\t\tif(c instanceof Promise) pending.recycle(c);\r\n\t\telse c.dispose();\r\n\t}\r\n\r\n\r\n\texport module PromiseCallbacks\r\n\t{\r\n\r\n\t\tvar pool:ObjectPool<IPromiseCallbacks<any>>;\r\n\r\n\t\tfunction getPool()\r\n\t\t{\r\n\t\t\treturn pool || (pool = new ObjectPool<IPromiseCallbacks<any>>(40, factory));\r\n\t\t}\r\n\r\n\t\tfunction factory():IPromiseCallbacks<any>\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tonFulfilled: null,\r\n\t\t\t\tonRejected: null,\r\n\t\t\t\tpromise: null\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\texport function init<T>(\r\n\t\t\tonFulfilled:Promise.Fulfill<T,any>,\r\n\t\t\tonRejected?:Promise.Reject<any>,\r\n\t\t\tpromise?:PromiseLike<any>):IPromiseCallbacks<T>\r\n\t\t{\r\n\r\n\t\t\tvar c = getPool().take();\r\n\t\t\tc.onFulfilled = onFulfilled;\r\n\t\t\tc.onRejected = onRejected;\r\n\t\t\tc.promise = promise;\r\n\t\t\treturn c;\r\n\t\t}\r\n\r\n\t\texport function recycle<T>(c:IPromiseCallbacks<T>):void\r\n\t\t{\r\n\t\t\tc.onFulfilled = null;\r\n\t\t\tc.onRejected = null;\r\n\t\t\tc.promise = null;\r\n\t\t\tgetPool().add(c);\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport module Promise\r\n{\r\n\r\n\t/**\r\n\t * The state of a promise.\r\n\t * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\r\n\t * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.\r\n\t */\r\n\texport enum State {\r\n\t\tPending   = 0,\r\n\t\tFulfilled = 1,\r\n\t\tRejected  = -1\r\n\t}\r\n\tObject.freeze(State);\r\n\r\n\texport type Resolution<TResult> = PromiseLike<TResult>|TResult|void;\r\n\r\n\texport interface Fulfill<T, TResult>\r\n\t{\r\n\t\t(value:T):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Reject<TResult>\r\n\t{\r\n\t\t(err?:any):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Then<T,TResult>\r\n\t{\r\n\t\t(\r\n\t\t\tonFulfilled:Fulfill<T,TResult>,\r\n\t\t\tonRejected?:Reject<TResult>):PromiseBase<TResult>\r\n\t}\r\n\r\n\texport interface Executor<T>\r\n\t{\r\n\t\t(\r\n\t\t\tresolve:(value?:T | PromiseLike<T>) => void,\r\n\t\t\treject:(reason?:any) => void):void;\r\n\t}\r\n\r\n\t// /**\r\n\t//  * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t//  * or rejected.\r\n\t//  * @param values An array of Promises.\r\n\t//  * @returns A new Promise.\r\n\t//  */\r\n\t// // race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\r\n\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t */\r\n\texport function all<T>(promises:PromiseLike<T>[]):PromiseBase<T[]>\r\n\texport function all<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T[]>\r\n\texport function all(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any[]>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tvar promises = (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v=>!v)) return new Fulfilled<any[]>(promises); // it's a new empty, reuse it. :|\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\tvar len = promises.length;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar p = promises[i];\r\n\t\t\tif(p instanceof SubsequentDeferred) promises[i] = p.parent;\r\n\t\t}\r\n\r\n\t\treturn pending<any[]>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet checkedAll = false;\r\n\t\t\tlet result:any[] = [];\r\n\t\t\tresult.length = len;\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i)=>i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = null;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = ()=>\r\n\t\t\t{\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(result);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any, i:number)=>\r\n\t\t\t{\r\n\t\t\t\tif(resolve)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = v;\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onReject = (e?:any)=>\r\n\t\t\t{\r\n\t\t\t\tlet r = reject;\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(e);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v=>onFulfill(v, i), onReject);\r\n\t\t\t\telse remaining.remove(i);\r\n\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise for the first of an array of promises to become settled.\r\n\t */\r\n\texport function race<T>(promises:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any>\r\n\t{\r\n\t\tvar promises = first && (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy?\r\n\t\tif(!promises || !promises.length || !(promises = promises.filter(v=>v!=null)).length)\r\n\t\t\tthrow new ArgumentException(\"Nothing to wait for.\");\r\n\r\n\t\tvar len = promises.length;\r\n\r\n\t\t// Only one?  Nothing to race.\r\n\t\tif(len==1) return wrap(promises[0]).defer();\r\n\r\n\t\t// Look for already resolved promises and the first one wins.\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar p:any = promises[i];\r\n\t\t\tif(p instanceof SubsequentDeferred) p = p.parent;\r\n\t\t\tif(p instanceof LazyResolved)\r\n\t\t\t{\r\n\t\t\t\t// If a a LazyResolved has resolved, then it wins otherwise let it defer and not (potentially) block.\r\n\t\t\t\tif(p.isResolved) return p.defer();\r\n\t\t\t}\r\n\t\t\telse if(p instanceof Resolved || p instanceof PromiseBase && p.isSettled)\r\n\t\t\t{\r\n\t\t\t\treturn p.defer();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn pending((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = null;\r\n\t\t\t\tresolve = null;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = null;\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolve = (r:(x:any)=>void, v:any)=>\r\n\t\t\t{\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(v);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any)=> onResolve(resolve, v);\r\n\t\t\tlet onReject = (e?:any)=> onResolve(reject, e);\r\n\r\n\t\t\tfor(let p of promises)\r\n\t\t\t{\r\n\t\t\t\tif(!resolve) break;\r\n\t\t\t\tp.then(onFulfill, onReject);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new resolved promise .\r\n\t * @returns A resolved promise.\r\n\t */\r\n\texport function resolve():PromiseBase<void>\r\n\r\n\t/**\r\n\t * Creates a new resolved promise for the provided value.\r\n\t * @param value A value or promise.\r\n\t * @returns A promise whose internal state matches the provided promise.\r\n\t */\r\n\texport function resolve<T>(value:T | PromiseLike<T>):PromiseBase<T>;\r\n\texport function resolve(value?:any):PromiseBase<any>\r\n\t{\r\n\r\n\t\treturn isPromise(value) ? wrap(value) : new Fulfilled(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new rejected promise for the provided reason.\r\n\t * @param reason The reason the promise was rejected.\r\n\t * @returns A new rejected Promise.\r\n\t */\r\n\texport function reject<T>(reason:T):PromiseBase<T>\r\n\t{\r\n\t\treturn new Rejected<T>(reason);\r\n\t}\r\n\r\n\r\n\texport module lazy\r\n\t{\r\n\t\t/**\r\n\t\t * Provides a promise that will be resolved immediately at the first 'then' request.\r\n\t\t * @param factory\r\n\t\t */\r\n\t\texport function resolve<T>(factory:Func<T>):LazyResolved<T>\r\n\t\t{\r\n\t\t\treturn new LazyResolved<T>(factory);\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Provides a promise that will trigger the resolver at the first 'then' request.\r\n\t\t * @param resolver\r\n\t\t * @returns {Promise<T>}\r\n\t\t */\r\n\t\texport function pending<T>(resolver:Promise.Executor<T>):LazyPromise<T>\r\n\t\t{\r\n\t\t\treturn new LazyPromise(resolver);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes any Promise-Like object and ensures an extended version of it from this module.\r\n\t * @param target The Promise-Like object\r\n\t * @returns A new target that simply extends the target.\r\n\t */\r\n\texport function wrap<T>(target:PromiseLike<T>):PromiseBase<T>\r\n\t{\r\n\t\tif(!target) throw new ArgumentNullException(TARGET);\r\n\t\treturn target instanceof Promise ? this : new PromiseWrapper(target);\r\n\t}\r\n\r\n\t/**\r\n\t * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.\r\n\t * @param then\r\n\t * @returns {PromiseWrapper<T>}\r\n\t */\r\n\texport function createFrom<T,TResult>(then:Then<T,TResult>):PromiseBase<T>\r\n\t{\r\n\t\tif(!then) throw new ArgumentNullException(THEN);\r\n\t\treturn new PromiseWrapper({then: then});\r\n\t}\r\n\r\n\t/**\r\n\t * Provides a promise that can be resolved later.\r\n\t * @returns {Promise<T>}\r\n\t */\r\n\texport function pending<T>(resolver?:Promise.Executor<T>):Promise<T>\r\n\t{\r\n\t\tvar p = pools.pending.get();\r\n\t\tif(resolver) p.resolveUsing(resolver);\r\n\t\treturn p;\r\n\t}\r\n\r\n\t//export function all()\r\n\r\n}\r\n\r\n\r\ninterface IPromiseCallbacks<T>\r\n{\r\n\tonFulfilled:Promise.Fulfill<T,any>;\r\n\tonRejected:Promise.Reject<any>;\r\n\tpromise?:PromiseLike<any>;\r\n}\r\n"]}