{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.js","System/Collections/Dictionaries/DictionaryBase.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","Compare_1","Enumerator_1","CollectionBase_1","EnumeratorBase_1","ArgumentNullException_1","InvalidOperationException_1","KeyValueExtract_1","VOID0","DictionaryBase","_super","source","call","_onValueModified","key","value","old","_addInternal","item","_this","addByKeyValue","_clearInternal","_","count","_i","_a","keys","length","removeByKey","contains","getCount","getValue","areEqual","_removeInternal","defineProperty","get","getKeys","enumerable","configurable","getValues","containsKey","ex","data","setValue","assertModifiable","changed","_setValueInternal","_signalModification","_getEntry","containsValue","e","getEnumerator","equal","moveNext","current","dispose","removeByValue","importEntries","pairs","_importEntries","forEach","pair","ver","len","i","_version","yielder","assertVersion","yieldReturn","yieldBreak"],"mappings":"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","file":"System/Collections/Dictionaries/DictionaryBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../../Compare\", \"../Enumeration/Enumerator\", \"../CollectionBase\", \"../Enumeration/EnumeratorBase\", \"../../Exceptions/ArgumentNullException\", \"../../Exceptions/InvalidOperationException\", \"../../KeyValueExtract\"], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var Compare_1 = require(\"../../Compare\");\n    var Enumerator_1 = require(\"../Enumeration/Enumerator\");\n    var CollectionBase_1 = require(\"../CollectionBase\");\n    var EnumeratorBase_1 = require(\"../Enumeration/EnumeratorBase\");\n    var ArgumentNullException_1 = require(\"../../Exceptions/ArgumentNullException\");\n    var InvalidOperationException_1 = require(\"../../Exceptions/InvalidOperationException\");\n    var KeyValueExtract_1 = require(\"../../KeyValueExtract\");\n    var VOID0 = void (0);\n    var DictionaryBase = (function (_super) {\n        __extends(DictionaryBase, _super);\n        function DictionaryBase(source) {\n            _super.call(this, source);\n        }\n        DictionaryBase.prototype._onValueModified = function (key, value, old) {\n        };\n        DictionaryBase.prototype._addInternal = function (item) {\n            var _this = this;\n            if (!item)\n                throw new ArgumentNullException_1.default('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\n            return KeyValueExtract_1.default(item, function (key, value) { return _this.addByKeyValue(key, value); });\n        };\n        DictionaryBase.prototype._clearInternal = function () {\n            var _ = this, count = 0;\n            for (var _i = 0, _a = _.keys; _i < _a.length; _i++) {\n                var key = _a[_i];\n                if (_.removeByKey(key))\n                    count++;\n            }\n            return count;\n        };\n        DictionaryBase.prototype.contains = function (item) {\n            var _this = this;\n            if (!item || !this.getCount())\n                return false;\n            return KeyValueExtract_1.default(item, function (key, value) {\n                var v = _this.getValue(key);\n                return Compare_1.areEqual(value, v);\n            });\n        };\n        DictionaryBase.prototype._removeInternal = function (item) {\n            var _this = this;\n            if (!item)\n                return 0;\n            return KeyValueExtract_1.default(item, function (key, value) {\n                var v = _this.getValue(key);\n                return (Compare_1.areEqual(value, v) && _this.removeByKey(key))\n                    ? 1 : 0;\n            });\n        };\n        Object.defineProperty(DictionaryBase.prototype, \"keys\", {\n            get: function () { return this.getKeys(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DictionaryBase.prototype, \"values\", {\n            get: function () { return this.getValues(); },\n            enumerable: true,\n            configurable: true\n        });\n        DictionaryBase.prototype.addByKeyValue = function (key, value) {\n            if (value === VOID0)\n                throw new InvalidOperationException_1.default(\"Cannot add 'undefined' as a value.\");\n            var _ = this;\n            if (_.containsKey(key)) {\n                var ex = new InvalidOperationException_1.default(\"Adding a key/value when the key already exists.\");\n                ex.data['key'] = key;\n                ex.data['value'] = value;\n                throw ex;\n            }\n            return _.setValue(key, value);\n        };\n        DictionaryBase.prototype.setValue = function (key, value) {\n            var _ = this;\n            _.assertModifiable();\n            var changed = false, old = _.getValue(key);\n            if (!Compare_1.areEqual(value, old) && _._setValueInternal(key, value)) {\n                changed = true;\n                _._onValueModified(key, value, old);\n            }\n            _._signalModification(changed);\n            return changed;\n        };\n        DictionaryBase.prototype.containsKey = function (key) {\n            return !!this._getEntry(key);\n        };\n        DictionaryBase.prototype.containsValue = function (value) {\n            var e = this.getEnumerator(), equal = Compare_1.areEqual;\n            while (e.moveNext()) {\n                if (equal(e.current, value, true)) {\n                    e.dispose();\n                    return true;\n                }\n            }\n            return false;\n        };\n        DictionaryBase.prototype.removeByKey = function (key) {\n            return this.setValue(key, VOID0);\n        };\n        DictionaryBase.prototype.removeByValue = function (value) {\n            var _ = this, count = 0, equal = Compare_1.areEqual;\n            for (var _i = 0, _a = _.getKeys(); _i < _a.length; _i++) {\n                var key = _a[_i];\n                if (equal(_.getValue(key), value, true)) {\n                    _.removeByKey(key);\n                    count++;\n                }\n            }\n            return count;\n        };\n        DictionaryBase.prototype.importEntries = function (pairs) {\n            return _super.prototype.importEntries.call(this, pairs);\n        };\n        DictionaryBase.prototype._importEntries = function (pairs) {\n            var _ = this;\n            if (!pairs)\n                return 0;\n            var changed = 0;\n            Enumerator_1.forEach(pairs, function (pair) { return KeyValueExtract_1.default(pair, function (key, value) {\n                if (_._setValueInternal(key, value))\n                    changed++;\n            }); });\n            return changed;\n        };\n        DictionaryBase.prototype.getEnumerator = function () {\n            var _ = this;\n            var ver, keys, len, i = 0;\n            return new EnumeratorBase_1.default(function () {\n                ver = _._version;\n                keys = _.getKeys();\n                len = keys.length;\n            }, function (yielder) {\n                _.assertVersion(ver);\n                while (i < len) {\n                    var key = keys[i++], value = _.getValue(key);\n                    if (value !== VOID0)\n                        return yielder.yieldReturn({ key: key, value: value });\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        return DictionaryBase;\n    }(CollectionBase_1.default));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = DictionaryBase;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDictionary.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport {forEach} from \"../Enumeration/Enumerator\";\r\nimport CollectionBase from \"../CollectionBase\";\r\nimport EnumeratorBase from \"../Enumeration/EnumeratorBase\";\r\nimport ArgumentNullException from \"../../Exceptions/ArgumentNullException\";\r\nimport InvalidOperationException from \"../../Exceptions/InvalidOperationException\";\r\nimport extractKeyValue from \"../../KeyValueExtract\";\r\n\r\nconst VOID0:any = void(0);\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nabstract class DictionaryBase<TKey, TValue>\r\nextends CollectionBase<IKeyValuePair<TKey,TValue>> implements IDictionary<TKey, TValue>\r\n{\r\n\tconstructor(source?:IEnumerableOrArray<IKeyValuePair<TKey,TValue>>)\r\n\t{\r\n\t\tsuper(source);\r\n\t}\r\n\r\n\r\n\tprotected _onValueModified(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t}\r\n\r\n\tprotected _addInternal(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tvar _ = this, count = 0;\r\n\r\n\t\tfor(let key of _.keys)\r\n\t\t{\r\n\t\t\tif(_.removeByKey(key)) count++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item || !this.getCount()) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tprotected _removeInternal(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot add 'undefined' as a value.\");\r\n\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\treturn _.setValue(key, value);\r\n\t}\r\n\r\n\tprotected abstract _getEntry(key:TKey):IKeyValuePair<TKey,TValue>;\r\n\r\n\tabstract getValue(key:TKey):TValue;\r\n\r\n\tprotected abstract _setValueInternal(key:TKey, value:TValue):boolean;\r\n\r\n\tsetValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\t// setValue shouldn't need to worry about recursion...\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\tvar changed = false, old = _.getValue(key); // get the old value here and pass to internal.\r\n\t\tif(!areEqual(value, old) && _._setValueInternal(key, value))\r\n\t\t{\r\n\t\t\tchanged = true;\r\n\t\t\t_._onValueModified(key, value, old)\r\n\t\t}\r\n\r\n\t\t_._signalModification(changed);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\treturn !!this._getEntry(key);\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, VOID0);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\tfor(let key of _.getKeys())\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>):number\r\n\t{\r\n\t\t// Allow piping through to trigger onModified properly.\r\n\t\treturn super.importEntries(<any>pairs);\r\n\t}\r\n\r\n\tprotected _importEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>):number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(!pairs) return 0;\r\n\t\tlet changed:number = 0;\r\n\t\tforEach(pairs,\r\n\t\t\tpair=>extractKeyValue(pair, (key, value)=>\r\n\t\t\t{\r\n\t\t\t\tif(_._setValueInternal(key, value))\r\n\t\t\t\t\tchanged++;\r\n\t\t\t})\r\n\t\t);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar ver:number, keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tver = _._version; // Track the version since getKeys is a copy.\r\n\t\t\t\tkeys = _.getKeys();\r\n\t\t\t\tlen = keys.length;\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\t_.assertVersion(ver);\r\n\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}