{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.js","System/Collections/Dictionaries/DictionaryBase.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Compare_1","EnumeratorBase_1","ArgumentNullException_1","InvalidOperationException_1","KeyValueExtract_1","Enumerator_1","VOID0","DictionaryBase","DictionaryBase.constructor","get","DictionaryBase.isUpdating","enumerable","configurable","DictionaryBase._onValueUpdate","DictionaryBase._onUpdated","DictionaryBase.handleUpdate","DictionaryBase.isReadOnly","DictionaryBase.count","DictionaryBase.add","DictionaryBase.clear","DictionaryBase.contains","DictionaryBase.copyTo","DictionaryBase.toArray","DictionaryBase.remove","DictionaryBase.keys","DictionaryBase.values","DictionaryBase.addByKeyValue","DictionaryBase.containsKey","DictionaryBase.containsValue","DictionaryBase.removeByKey","DictionaryBase.removeByValue","DictionaryBase.importPairs","DictionaryBase.getEnumerator","Object","defineProperty","value"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,gBAAiB,gCAAiC,yCAA0C,6CAA8C,wBAAyB,6BAA8BN,IAEpO,SAAUI,EAASF,GCLtB,YAEA,IAAAM,GAAAJ,EAAuB,iBACvBK,EAAAL,EAA2B,iCAE3BM,EAAAN,EAAkC,0CAClCO,EAAAP,EAAsC,8CACtCQ,EAAAR,EAA4B,yBAC5BS,EAAAT,EAAsB,6BAEhBU,EAAY,OAGlBC,EAAA,WAMCA,QAAAA,KAECC,KAAKA,iBAAmBA,EA4Q1BD,MAzQCA,QAAAA,eAAIA,EAAAA,UAAAA,cDLOE,ICKXF,WAA2BG,MAA8BA,IAAvBA,KAAKA,kBDJ5BC,YAAY,EACZC,cAAc,ICQfL,EAAAA,UAAAA,eAAVA,SAAyBA,EAAUA,EAAcA,GAEhDM,IAAIA,EAAAA,SAASA,EAAOA,GAAKA,GACzBA,CAECA,GAAIA,GAAIA,IACLA,GAAEA,gBACJA,EAAEA,eAAeA,EAAKA,EAAOA,GAGPA,GAApBA,EAAEA,kBACJA,EAAEA,eASGN,EAAAA,UAAAA,WAARA,WAECO,GAAIA,GAAIA,IACLA,GAAEA,WACJA,EAAEA,aAIJP,EAAAA,UAAAA,aAAAA,SAAaA,GAEZQ,GAAcA,GAAVA,EAAIA,IACRA,IAAGA,EACHA,CACCA,EAAEA,kBAEFA,KAECA,EAASA,IDtBG,QC0BZA,EAAEA,wBAIHA,GAA6BA,GAApBA,EAAEA,gBAKZA,OAHGA,IAA8BA,GAApBA,EAAEA,kBACdA,EAAEA,aAEIA,GAMRR,OAAAA,eAAIA,EAAAA,UAAAA,cD9BOE,IC8BXF,WAA2BS,OAAOA,GD7BvBL,YAAY,EACZC,cAAc,ICgCzBL,OAAAA,eAAIA,EAAAA,UAAAA,SD7BOE,IC6BXF,WAAqBU,MAAOA,MAAKA,YD5BtBN,YAAY,EACZC,cAAc,IC6BzBL,EAAAA,UAAAA,IAAAA,SAAIA,GAAJW,GAAAA,GAAAA,IAECA,KAAIA,EACHA,KAAMA,IAAIA,GAAAA,WACTA,OAAQA,kDAAqDA,EAAOA,oBAGtEA,GAAAA,WAAgBA,EACfA,SAACA,EAAKA,GAAQA,MAAAA,GAAKA,cAAcA,EAAKA,MAGxCX,EAAAA,UAAAA,MAAAA,WAECY,GAAIA,GAAIA,KAAMA,EAAOA,EAAEA,KAAMA,EAAQA,EAAKA,MAc1CA,OAZGA,IACFA,EAAEA,aACDA,WAGCA,MADAA,GAAKA,QAAQA,SAAAA,GAAQA,EAAEA,YAAYA,MAC5BA,IAIEA,GAATA,EAAEA,OACJA,QAAQA,KAAKA,mDAEPA,GAGRZ,EAAAA,UAAAA,SAAAA,SAASA,GAATa,GAAAA,GAAAA,IAGCA,OAAIA,GAEGA,EAAAA,WAAgBA,EACtBA,SAACA,EAAKA,GAGLA,GAAIA,GAAIA,EAAKA,SAASA,EACtBA,OAAOA,GAAAA,SAASA,EAAOA,MAPRA,GAYlBb,EAAAA,UAAAA,OAAAA,SAAOA,EAAqCA,GAE3Cc,GAF2CA,SAAAA,IAAAA,EAAAA,IAEvCA,EAAOA,KAAMA,IAAIA,GAAAA,WAAsBA,QAK3CA,KADAA,GAAIA,GAAIA,KAAKA,gBACPA,EAAEA,YAEPA,EAAMA,KAAWA,EAAEA,OAEpBA,OAAOA,IAIRd,EAAAA,UAAAA,QAAAA,WAECe,MAAOA,MAAKA,UAAWA,IAGxBf,EAAAA,UAAAA,OAAAA,SAAOA,GAAPgB,GAAAA,GAAAA,IAECA,OAAIA,GAEGA,EAAAA,WAAgBA,EACtBA,SAACA,EAAKA,GAGLA,GAAIA,GAAIA,EAAKA,SAASA,EACtBA,OAAQA,GAAAA,SAASA,EAAOA,IAAMA,EAAKA,YAAYA,GAC5CA,EAAIA,IARQA,GAoBlBhB,OAAAA,eAAIA,EAAAA,UAAAA,QDhEOE,ICgEXF,WAAoBiB,MAAOA,MAAKA,WD/DrBb,YAAY,EACZC,cAAc,ICkEzBL,OAAAA,eAAIA,EAAAA,UAAAA,UD/DOE,IC+DXF,WAAwBkB,MAAOA,MAAKA,aD9DzBd,YAAY,EACZC,cAAc,ICgEzBL,EAAAA,UAAAA,cAAAA,SAAcA,EAAUA,GAEvBmB,GAAIA,GAAIA,IACRA,IAAGA,EAAEA,YAAYA,GACjBA,CACCA,GAAIA,GAAKA,GAAIA,GAAAA,WAA0BA,kDAGvCA,MAFAA,GAAGA,KAAUA,IAAIA,EACjBA,EAAGA,KAAYA,MAAIA,EACbA,EAGPA,EAAEA,SAASA,EAAKA,IAOjBnB,EAAAA,UAAAA,YAAAA,SAAYA,GAEXoB,GAAIA,GAAQA,KAAKA,SAASA,EAC1BA,OAAOA,KAAQA,GAGhBpB,EAAAA,UAAAA,cAAAA,SAAcA,GAIbqB,IAFAA,GAAIA,GAAIA,KAAKA,gBAAiBA,EAAmDA,EAAAA,SAE3EA,EAAEA,YAEPA,GAAGA,EAAMA,EAAEA,QAASA,GAAOA,GAG1BA,MADAA,GAAEA,WACKA,CAGTA,QAAOA,GAGRrB,EAAAA,UAAAA,YAAAA,SAAYA,GAEXsB,MAAOA,MAAKA,SAASA,EAAKA,SAG3BtB,EAAAA,UAAAA,cAAAA,SAAcA,GAEbuB,GAAIA,GAAIA,KAAMA,EAAQA,EAAGA,EAAmDA,EAAAA,QAS5EA,OARAA,GAAEA,KAAKA,QAAQA,SAAAA,GAEXA,EAAMA,EAAEA,SAASA,GAAMA,GAAOA,KAEhCA,EAAEA,YAAYA,KACZA,KAGGA,GAGRvB,EAAAA,UAAAA,YAAAA,SAAYA,GAEXwB,GAAIA,GAAIA,IACRA,OAAIA,GACGA,EAAEA,aACRA,WAECA,GAAIA,IAAkBA,CAQtBA,OAPAA,GAAAA,QAAQA,EACPA,SAAAA,GAAMA,MAAAA,GAAAA,WAAgBA,EAAMA,SAACA,EAAKA,GAEjCA,EAAEA,SAASA,EAAKA,GAChBA,GAAUA,MAGLA,KAZSA,GAiBnBxB,EAAAA,UAAAA,cAAAA,WAECyB,GACIA,GAAaA,EADbA,EAAIA,KACqBA,EAAIA,CACjCA,OAAOA,IAAIA,GAAAA,WACVA,WAECA,EAAOA,EAAEA,KACTA,EAAMA,EAAKA,QAGZA,SAACA,GAEAA,KAAQA,EAAFA,GACNA,CACCA,GAAIA,GAAMA,EAAKA,KAAMA,EAAQA,EAAEA,SAASA,EACxCA,IAAGA,IAAQA,EACVA,MAAOA,GAAQA,aAAaA,IAAKA,EAAKA,MAAOA,IAG/CA,MAAOA,GAAQA,gBAMnBzB,IAGA0B,QAAAC,eAAAxC,EAAA,cAAAyC,OAAA,IDrGIzC,EAAAA,WCqGWa","file":"System/Collections/Dictionaries/DictionaryBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../../Compare', '../Enumeration/EnumeratorBase', '../../Exceptions/ArgumentNullException', '../../Exceptions/InvalidOperationException', '../../KeyValueExtract', '../Enumeration/Enumerator'], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var Compare_1 = require('../../Compare');\n    var EnumeratorBase_1 = require('../Enumeration/EnumeratorBase');\n    var ArgumentNullException_1 = require('../../Exceptions/ArgumentNullException');\n    var InvalidOperationException_1 = require('../../Exceptions/InvalidOperationException');\n    var KeyValueExtract_1 = require('../../KeyValueExtract');\n    var Enumerator_1 = require('../Enumeration/Enumerator');\n    var VOID0 = void (0);\n    var DictionaryBase = (function () {\n        function DictionaryBase() {\n            this._updateRecursion = 0;\n        }\n        Object.defineProperty(DictionaryBase.prototype, \"isUpdating\", {\n            get: function () { return this._updateRecursion != 0; },\n            enumerable: true,\n            configurable: true\n        });\n        DictionaryBase.prototype._onValueUpdate = function (key, value, old) {\n            if (!Compare_1.areEqual(value, old, true)) {\n                var _ = this;\n                if (_.onValueChanged)\n                    _.onValueChanged(key, value, old);\n                if (_._updateRecursion == 0)\n                    _._onUpdated();\n            }\n        };\n        DictionaryBase.prototype._onUpdated = function () {\n            var _ = this;\n            if (_.onUpdated)\n                _.onUpdated();\n        };\n        DictionaryBase.prototype.handleUpdate = function (closure) {\n            var _ = this, result;\n            if (closure) {\n                _._updateRecursion++;\n                try {\n                    result = closure();\n                }\n                finally {\n                    _._updateRecursion--;\n                }\n            }\n            else\n                result = _._updateRecursion == 0;\n            if (result && _._updateRecursion == 0)\n                _._onUpdated();\n            return result;\n        };\n        Object.defineProperty(DictionaryBase.prototype, \"isReadOnly\", {\n            get: function () { return false; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DictionaryBase.prototype, \"count\", {\n            get: function () { return this.getCount(); },\n            enumerable: true,\n            configurable: true\n        });\n        DictionaryBase.prototype.add = function (item) {\n            var _this = this;\n            if (!item)\n                throw new ArgumentNullException_1.default('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\n            KeyValueExtract_1.default(item, function (key, value) { return _this.addByKeyValue(key, value); });\n        };\n        DictionaryBase.prototype.clear = function () {\n            var _ = this, keys = _.keys, count = keys.length;\n            if (count)\n                _.handleUpdate(function () {\n                    keys.forEach(function (key) { _.removeByKey(key); });\n                    return true;\n                });\n            if (_.count != 0)\n                console.warn(\"Dictionary clear() results in mismatched count.\");\n            return count;\n        };\n        DictionaryBase.prototype.contains = function (item) {\n            var _this = this;\n            if (!item)\n                return false;\n            return KeyValueExtract_1.default(item, function (key, value) {\n                var v = _this.getValue(key);\n                return Compare_1.areEqual(value, v);\n            });\n        };\n        DictionaryBase.prototype.copyTo = function (array, index) {\n            if (index === void 0) { index = 0; }\n            if (!array)\n                throw new ArgumentNullException_1.default('array');\n            var e = this.getEnumerator();\n            while (e.moveNext()) {\n                array[index++] = e.current;\n            }\n            return array;\n        };\n        DictionaryBase.prototype.toArray = function () {\n            return this.copyTo([], 0);\n        };\n        DictionaryBase.prototype.remove = function (item) {\n            var _this = this;\n            if (!item)\n                return 0;\n            return KeyValueExtract_1.default(item, function (key, value) {\n                var v = _this.getValue(key);\n                return (Compare_1.areEqual(value, v) && _this.removeByKey(key))\n                    ? 1 : 0;\n            });\n        };\n        Object.defineProperty(DictionaryBase.prototype, \"keys\", {\n            get: function () { return this.getKeys(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(DictionaryBase.prototype, \"values\", {\n            get: function () { return this.getValues(); },\n            enumerable: true,\n            configurable: true\n        });\n        DictionaryBase.prototype.addByKeyValue = function (key, value) {\n            var _ = this;\n            if (_.containsKey(key)) {\n                var ex = new InvalidOperationException_1.default(\"Adding a key/value when the key already exists.\");\n                ex.data['key'] = key;\n                ex.data['value'] = value;\n                throw ex;\n            }\n            _.setValue(key, value);\n        };\n        DictionaryBase.prototype.containsKey = function (key) {\n            var value = this.getValue(key);\n            return value !== VOID0;\n        };\n        DictionaryBase.prototype.containsValue = function (value) {\n            var e = this.getEnumerator(), equal = Compare_1.areEqual;\n            while (e.moveNext()) {\n                if (equal(e.current, value, true)) {\n                    e.dispose();\n                    return true;\n                }\n            }\n            return false;\n        };\n        DictionaryBase.prototype.removeByKey = function (key) {\n            return this.setValue(key, undefined);\n        };\n        DictionaryBase.prototype.removeByValue = function (value) {\n            var _ = this, count = 0, equal = Compare_1.areEqual;\n            _.keys.forEach(function (key) {\n                if (equal(_.getValue(key), value, true)) {\n                    _.removeByKey(key);\n                    ++count;\n                }\n            });\n            return count;\n        };\n        DictionaryBase.prototype.importPairs = function (pairs) {\n            var _ = this;\n            if (!pairs)\n                return false;\n            return _.handleUpdate(function () {\n                var changed = false;\n                Enumerator_1.forEach(pairs, function (pair) { return KeyValueExtract_1.default(pair, function (key, value) {\n                    _.setValue(key, value);\n                    changed = true;\n                }); });\n                return changed;\n            });\n        };\n        DictionaryBase.prototype.getEnumerator = function () {\n            var _ = this;\n            var keys, len, i = 0;\n            return new EnumeratorBase_1.default(function () {\n                keys = _.keys;\n                len = keys.length;\n            }, function (yielder) {\n                while (i < len) {\n                    var key = keys[i++], value = _.getValue(key);\n                    if (value !== VOID0)\n                        return yielder.yieldReturn({ key: key, value: value });\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        return DictionaryBase;\n    })();\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = DictionaryBase;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IDictionary.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport {areEqual} from '../../Compare';\r\nimport EnumeratorBase from '../Enumeration/EnumeratorBase';\r\nimport ArgumentException from '../../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../../Exceptions/ArgumentNullException';\r\nimport InvalidOperationException from '../../Exceptions/InvalidOperationException';\r\nimport extractKeyValue from '../../KeyValueExtract';\r\nimport {forEach} from '../Enumeration/Enumerator';\r\n\r\nconst VOID0:any = void(0);\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nabstract class DictionaryBase<TKey, TValue>\r\nimplements IDictionary<TKey, TValue>\r\n{\r\n\t// This allows for batch updates in order to improve the efficiency of responsive systems.\r\n\tprivate _updateRecursion:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._updateRecursion = 0;\r\n\t}\r\n\r\n\tget isUpdating():boolean { return this._updateRecursion!=0; }\r\n\r\n\t// Could implement an event dispatcher pattern here easily...\r\n\tonValueChanged:(key:TKey, value:TValue, old:TValue) => void;\r\n\r\n\tprotected _onValueUpdate(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t\tif(!areEqual(value, old, true))\r\n\t\t{\r\n\r\n\t\t\tvar _ = this;\r\n\t\t\tif(_.onValueChanged)\r\n\t\t\t\t_.onValueChanged(key, value, old);\r\n\r\n\t\t\t// If the update recursion is zero, then we are finished with updates.\r\n\t\t\tif(_._updateRecursion==0)\r\n\t\t\t\t_._onUpdated();\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// Listening to every value update can get noisy.  Here we allow for batch update signaling.\r\n\t// The consumer of this class can also wire up their own event system.\r\n\tonUpdated:() => void;\r\n\r\n\tprivate _onUpdated():void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.onUpdated)\r\n\t\t\t_.onUpdated();\r\n\t}\r\n\r\n\t// Takes a closure that if returning true will propagate an update signal.\r\n\thandleUpdate(closure?:() => boolean):boolean\r\n\t{\r\n\t\tvar _ = this, result:boolean;\r\n\t\tif(closure)\r\n\t\t{\r\n\t\t\t_._updateRecursion++;\r\n\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tresult = closure();\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._updateRecursion--;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t\tresult = _._updateRecursion==0;\r\n\r\n\t\tif(result && _._updateRecursion==0)\r\n\t\t\t_._onUpdated();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// ICollection<T>\r\n\t/////////////////////////////////////////\r\n\tget isReadOnly():boolean { return false; }\r\n\r\n\tprotected abstract getCount():number;\r\n\r\n\tget count():number { return this.getCount(); }\r\n\r\n\tadd(item:KeyValuePair<TKey, TValue>):void\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\textractKeyValue(item,\r\n\t\t\t(key, value)=>this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, keys = _.keys, count = keys.length;\r\n\r\n\t\tif(count)\r\n\t\t\t_.handleUpdate(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tkeys.forEach(key=> { _.removeByKey(key); });\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\tif(_.count!=0) // After they've all been removed, then should be zero.\r\n\t\t\tconsole.warn(\"Dictionary clear() results in mismatched count.\");\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tcopyTo(array:IKeyValuePair<TKey, TValue>[], index:number = 0):IKeyValuePair<TKey, TValue>[]\r\n\t{\r\n\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t// This is a generic implementation that will work for all derived classes.\r\n\t\t// It can be overridden and optimized.\r\n\t\tvar e = this.getEnumerator();\r\n\t\twhile(e.moveNext()) // Disposes when finished.\r\n\t\t{\r\n\t\t\tarray[index++] = e.current;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\r\n\ttoArray():IKeyValuePair<TKey,TValue>[]\r\n\t{\r\n\t\treturn this.copyTo([], 0);\r\n\t}\r\n\r\n\tremove(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\r\n\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\t_.setValue(key, value);\r\n\t}\r\n\r\n\tabstract getValue(key:TKey):TValue;\r\n\r\n\tabstract setValue(key:TKey, value:TValue):boolean;\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\tvar value = this.getValue(key);\r\n\t\treturn value!==VOID0;\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, undefined);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\t_.keys.forEach(key=>\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportPairs(pairs:KeyValuePair<TKey, TValue>[]|IEnumerable<KeyValuePair<TKey, TValue>>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(!pairs) return false;\r\n\t\treturn _.handleUpdate(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet changed:boolean = false;\r\n\t\t\t\tforEach(pairs,\r\n\t\t\t\t\tpair=>extractKeyValue(pair, (key, value)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t_.setValue(key, value);\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t\treturn changed;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tkeys = _.keys;\r\n\t\t\t\tlen = keys.length\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}