{"version":3,"sources":["System/Collections/Dictionaries/Dictionary.js","System/Collections/Dictionaries/Dictionary.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","linkedNodeList","recycle","linkedListPool","ObjectPool_1","ObjectPool","LinkedNodeList_1","LinkedNodeList","r","clear","add","take","callHasOwnProperty","target","key","Object","prototype","hasOwnProperty","call","getHashString","obj","NULL","VOID0","Types_1","Type","UNDEFINED","hasMemberOfType","GET_HASH_CODE","FUNCTION","getHashCode","toString","Compare_1","Functions_1","EnumeratorBase_1","DictionaryBase_1","extends_1","__extends","HashEntry","value","previous","next","this","Dictionary","_super","_keyComparer","Functions","Identity","_entries","_buckets","_onDispose","getCount","unsafeCount","_getBucket","hash","createIfMissing","buckets","bucket","_getBucketEntry","_","comparer","compareKey","find","e","_getEntry","getValue","_setValueInternal","entries","bucketEntry","b","old","areEqual","x","removeNode","y","count","Error","entry","addNode","_clearInternal","getEnumerator","throwIfDisposed","ver","currentEntry","EnumeratorBase","_version","first","yielder","assertVersion","result","yieldReturn","yieldBreak","getKeys","push","getValues","defineProperty"],"mappings":"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","file":"Dictionary.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Original: http://linqjs.codeplex.com/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../../Compare\", \"../../Types\", \"../../Functions\", \"../Enumeration/EnumeratorBase\", \"../LinkedNodeList\", \"../../Disposable/ObjectPool\", \"./DictionaryBase\", \"../../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Compare_1 = require(\"../../Compare\");\n    var Types_1 = require(\"../../Types\");\n    var Functions_1 = require(\"../../Functions\");\n    var EnumeratorBase_1 = require(\"../Enumeration/EnumeratorBase\");\n    var LinkedNodeList_1 = require(\"../LinkedNodeList\");\n    var ObjectPool_1 = require(\"../../Disposable/ObjectPool\");\n    var DictionaryBase_1 = require(\"./DictionaryBase\");\n    var extends_1 = require(\"../../../extends\");\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    var HashEntry = (function () {\n        function HashEntry(key, value, previous, next) {\n            this.key = key;\n            this.value = value;\n            this.previous = previous;\n            this.next = next;\n        }\n        return HashEntry;\n    }());\n    var linkedListPool;\n    function linkedNodeList(recycle) {\n        if (!linkedListPool)\n            linkedListPool\n                = new ObjectPool_1.ObjectPool(20, function () { return new LinkedNodeList_1.LinkedNodeList(); }, function (r) { return r.clear(); });\n        if (!recycle)\n            return linkedListPool.take();\n        linkedListPool.add(recycle);\n    }\n    function callHasOwnProperty(target, key) {\n        return Object.prototype.hasOwnProperty.call(target, key);\n    }\n    var NULL = \"null\", GET_HASH_CODE = \"getHashCode\";\n    function getHashString(obj) {\n        if (obj === null)\n            return NULL;\n        if (obj === VOID0)\n            return Types_1.Type.UNDEFINED;\n        if (Types_1.Type.hasMemberOfType(obj, GET_HASH_CODE, Types_1.Type.FUNCTION)) {\n            return obj.getHashCode();\n        }\n        return (typeof obj.toString == Types_1.Type.FUNCTION)\n            ? obj.toString()\n            : Object.prototype.toString.call(obj);\n    }\n    var Dictionary = (function (_super) {\n        __extends(Dictionary, _super);\n        function Dictionary(_keyComparer) {\n            if (_keyComparer === void 0) { _keyComparer = Functions_1.Functions.Identity; }\n            _super.call(this);\n            this._keyComparer = _keyComparer;\n            this._entries = linkedNodeList();\n            this._buckets = {};\n        }\n        Dictionary.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._entries = null;\n            this._buckets = null;\n        };\n        Dictionary.prototype.getCount = function () {\n            return this._entries && this._entries.unsafeCount || 0;\n        };\n        Dictionary.prototype._getBucket = function (hash, createIfMissing) {\n            if (hash === null || hash === VOID0 || !createIfMissing && !this.getCount())\n                return null;\n            var buckets = this._buckets;\n            var bucket = callHasOwnProperty(buckets, hash) ? buckets[hash] : VOID0;\n            if (createIfMissing && !bucket)\n                buckets[hash]\n                    = bucket\n                        = linkedNodeList();\n            return bucket || null;\n        };\n        Dictionary.prototype._getBucketEntry = function (key, hash, bucket) {\n            if (key === null || key === VOID0 || !this.getCount())\n                return null;\n            var _ = this, comparer = _._keyComparer, compareKey = comparer(key);\n            if (!bucket)\n                bucket = _._getBucket(hash || getHashString(compareKey));\n            return bucket\n                && bucket.find(function (e) { return comparer(e.key) === compareKey; });\n        };\n        Dictionary.prototype._getEntry = function (key) {\n            var e = this._getBucketEntry(key);\n            return e && e.value;\n        };\n        Dictionary.prototype.getValue = function (key) {\n            var e = this._getEntry(key);\n            return e ? e.value : VOID0;\n        };\n        Dictionary.prototype._setValueInternal = function (key, value) {\n            var _ = this;\n            var buckets = _._buckets, entries = _._entries, comparer = _._keyComparer, compareKey = comparer(key), hash = getHashString(compareKey), bucket = _._getBucket(hash), bucketEntry = bucket && _._getBucketEntry(key, hash, bucket);\n            if (bucketEntry) {\n                var b = bucket;\n                if (value === VOID0) {\n                    var x = b.removeNode(bucketEntry), y = entries.removeNode(bucketEntry.value);\n                    if (x && !b.count) {\n                        delete buckets[hash];\n                        linkedNodeList(b);\n                        bucket = null;\n                    }\n                    if (x !== y)\n                        throw \"Entries and buckets are out of sync.\";\n                    if (x)\n                        return true;\n                }\n                else {\n                    var old = bucketEntry.value.value;\n                    bucketEntry.value.value = value;\n                    return !Compare_1.areEqual(value, old);\n                }\n            }\n            else if (value !== VOID0) {\n                if (!bucket)\n                    bucket = _._getBucket(hash, true);\n                if (!bucket)\n                    throw new Error(\"\\\"\" + hash + \"\\\" cannot be added to lookup table.\");\n                var entry = new HashEntry(key, value);\n                entries.addNode(entry);\n                bucket.addNode(new HashEntry(key, entry));\n                return true;\n            }\n            return false;\n        };\n        Dictionary.prototype._clearInternal = function () {\n            var _ = this;\n            var buckets = _._buckets;\n            for (var key in buckets) {\n                if (buckets.hasOwnProperty(key)) {\n                    var bucket = buckets[key];\n                    delete buckets[key];\n                    linkedNodeList(bucket);\n                }\n            }\n            return _._entries.clear();\n        };\n        Dictionary.prototype.getEnumerator = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var ver, currentEntry;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                _.throwIfDisposed();\n                ver = _._version;\n                currentEntry = _._entries.first;\n            }, function (yielder) {\n                if (currentEntry) {\n                    _.throwIfDisposed();\n                    _.assertVersion(ver);\n                    var result = { key: currentEntry.key, value: currentEntry.value };\n                    currentEntry = currentEntry.next || null;\n                    return yielder.yieldReturn(result);\n                }\n                return yielder.yieldBreak();\n            });\n        };\n        Dictionary.prototype.getKeys = function () {\n            var _ = this;\n            var result = [];\n            var e = _._entries && _._entries.first;\n            while (e) {\n                result.push(e.key);\n                e = e.next;\n            }\n            return result;\n        };\n        Dictionary.prototype.getValues = function () {\n            var _ = this;\n            var result = [];\n            var e = _._entries && _._entries.first;\n            while (e) {\n                result.push(e.value);\n                e = e.next;\n            }\n            return result;\n        };\n        return Dictionary;\n    }(DictionaryBase_1.default));\n    exports.Dictionary = Dictionary;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Dictionary;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Original: http://linqjs.codeplex.com/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport {Type} from \"../../Types\";\r\nimport {Functions} from \"../../Functions\";\r\nimport {EnumeratorBase} from \"../Enumeration/EnumeratorBase\";\r\nimport {LinkedNodeList} from \"../LinkedNodeList\";\r\nimport {ObjectPool} from \"../../Disposable/ObjectPool\";\r\nimport {IMap} from \"./IDictionary\";\r\nimport {IKeyValuePair} from \"../../KeyValuePair\";\r\nimport {IEnumerator} from \"../Enumeration/IEnumerator\";\r\nimport {ILinkedNode} from \"../ILinkedListNode\";\r\nimport {Selector} from \"../../FunctionTypes\";\r\nimport DictionaryBase from \"./DictionaryBase\";\r\nimport __extendsImport from \"../../../extends\";\r\nimport {EmptyEnumerator} from \"../Enumeration/EmptyEnumerator\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\n\r\nexport interface IHashEntry<TKey, TValue>\r\nextends ILinkedNode<IHashEntry<TKey, TValue>>, IKeyValuePair<TKey,TValue>\r\n{\r\n\r\n}\r\n// LinkedList for Dictionary\r\nclass HashEntry<TKey, TValue>\r\nimplements IHashEntry<TKey, TValue>\r\n{\r\n\tconstructor(\r\n\t\tpublic key:TKey,\r\n\t\tpublic value:TValue,\r\n\t\tpublic previous?:IHashEntry<TKey, TValue>|null,\r\n\t\tpublic next?:IHashEntry<TKey, TValue>|null)\r\n\t{\r\n\r\n\t}\r\n}\r\n\r\ntype HashEntryLinkedList<TKey,TValue> = LinkedNodeList<IHashEntry<TKey,IHashEntry<TKey,TValue>>>;\r\n\r\nvar linkedListPool:ObjectPool<LinkedNodeList<any>>;\r\nfunction linkedNodeList():LinkedNodeList<any>;\r\nfunction linkedNodeList(recycle?:LinkedNodeList<any>):void;\r\nfunction linkedNodeList(recycle?:LinkedNodeList<any>):LinkedNodeList<any>|void\r\n{\r\n\tif(!linkedListPool)\r\n\t\tlinkedListPool\r\n\t\t\t= new ObjectPool<LinkedNodeList<any>>(20, ()=>new LinkedNodeList<any>(), r=>r.clear());\r\n\tif(!recycle) return linkedListPool.take();\r\n\tlinkedListPool.add(recycle);\r\n}\r\n\r\n// static utility methods\r\nfunction callHasOwnProperty(target:any, key:string)\r\n{\r\n\treturn Object.prototype.hasOwnProperty.call(target, key);\r\n}\r\n\r\nconst NULL = \"null\", GET_HASH_CODE = \"getHashCode\";\r\nfunction getHashString(obj:any):string\r\n{\r\n\tif(obj===null) return NULL;\r\n\tif(obj===VOID0) return Type.UNDEFINED;\r\n\r\n\t// See IHashable.\r\n\tif(Type.hasMemberOfType(obj, GET_HASH_CODE, Type.FUNCTION))\r\n\t{\r\n\t\treturn (<any>obj).getHashCode();\r\n\t}\r\n\r\n\treturn (typeof obj.toString==Type.FUNCTION)\r\n\t\t? obj.toString()\r\n\t\t: Object.prototype.toString.call(obj);\r\n}\r\n\r\n\r\nexport class Dictionary<TKey, TValue> extends DictionaryBase<TKey, TValue>\r\n{\r\n\t// Retains the order...\r\n\tprivate readonly _entries:LinkedNodeList<IHashEntry<TKey, TValue>>;\r\n\tprivate readonly _buckets:IMap<LinkedNodeList<IHashEntry<TKey, IHashEntry<TKey, TValue>>>>;\r\n\r\n\tconstructor(\r\n\t\tprivate _keyComparer:Selector<TKey,any> = Functions.Identity)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._entries = linkedNodeList();\r\n\t\tthis._buckets = {};\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\t(<any>this)._entries = null;\r\n\t\t(<any>this)._buckets = null;\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\treturn this._entries && this._entries.unsafeCount || 0;\r\n\t}\r\n\r\n\tprivate _getBucket(\r\n\t\thash:string,\r\n\t\tcreateIfMissing?:boolean):HashEntryLinkedList<TKey,TValue>|null\r\n\t{\r\n\t\tif(hash===null || hash===VOID0 || !createIfMissing && !this.getCount())\r\n\t\t\treturn null;\r\n\r\n\t\tvar buckets = this._buckets;\r\n\t\tvar bucket = callHasOwnProperty(buckets, hash) ? buckets[hash] : VOID0;\r\n\r\n\t\tif(createIfMissing && !bucket)\r\n\t\t\tbuckets[hash]\r\n\t\t\t\t= bucket\r\n\t\t\t\t= linkedNodeList();\r\n\r\n\t\treturn bucket || null;\r\n\t}\r\n\r\n\tprivate _getBucketEntry(\r\n\t\tkey:TKey,\r\n\t\thash?:string,\r\n\t\tbucket?:HashEntryLinkedList<TKey,TValue>|null):IHashEntry<TKey,IHashEntry<TKey,TValue>>|null\r\n\t{\r\n\t\tif(key===null || key===VOID0 || !this.getCount())\r\n\t\t\treturn null;\r\n\r\n\t\tvar _          = this,\r\n\t\t    comparer   = _._keyComparer,\r\n\t\t    compareKey = comparer(key);\r\n\r\n\t\tif(!bucket) bucket = _._getBucket(hash || getHashString(compareKey));\r\n\r\n\t\treturn bucket\r\n\t\t\t&& bucket.find(e=>comparer(e.key)===compareKey);\r\n\t}\r\n\r\n\tprotected _getEntry(key:TKey):IHashEntry<TKey,TValue>|null\r\n\t{\r\n\t\tvar e = this._getBucketEntry(key);\r\n\t\treturn e && e.value;\r\n\t}\r\n\r\n\tgetValue(key:TKey):TValue|undefined\r\n\t{\r\n\t\tvar e = this._getEntry(key);\r\n\t\treturn e ? e.value : VOID0;\r\n\t}\r\n\r\n\tprotected _setValueInternal(key:TKey, value:TValue|undefined):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar buckets     = _._buckets,\r\n\t\t    entries     = _._entries,\r\n\t\t    comparer    = _._keyComparer,\r\n\t\t    compareKey  = comparer(key),\r\n\t\t    hash        = getHashString(compareKey),\r\n\t\t    bucket      = _._getBucket(hash),\r\n\t\t    bucketEntry = bucket && _._getBucketEntry(key, hash, bucket);\r\n\r\n\t\t// Entry exits? Delete or update\r\n\t\tif(bucketEntry)\r\n\t\t{\r\n\t\t\tvar b = <HashEntryLinkedList<TKey,TValue>>bucket;\r\n\t\t\tif(value===VOID0)\r\n\t\t\t{\r\n\t\t\t\tlet x = b.removeNode(bucketEntry),\r\n\t\t\t\t    y = entries.removeNode(bucketEntry.value);\r\n\r\n\t\t\t\tif(x && !b.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tdelete buckets[hash];\r\n\t\t\t\t\tlinkedNodeList(b);\r\n\t\t\t\t\tbucket = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(x!==y) throw \"Entries and buckets are out of sync.\";\r\n\r\n\t\t\t\tif(x) return true;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// We don't expose the internal hash entries so replacing the value is ok.\r\n\t\t\t\tvar old = bucketEntry.value.value;\r\n\t\t\t\tbucketEntry.value.value = value;\r\n\t\t\t\treturn !areEqual(value, old);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse if(value!==VOID0)\r\n\t\t{\r\n\t\t\tif(!bucket) bucket = _._getBucket(hash, true);\r\n\t\t\tif(!bucket) throw new Error(`\"${hash}\" cannot be added to lookup table.`);\r\n\t\t\tlet entry = new HashEntry(key, value);\r\n\t\t\tentries.addNode(entry);\r\n\t\t\tbucket.addNode(new HashEntry(key, entry));\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar buckets = _._buckets;\r\n\r\n\t\t// Ensure reset and clean...\r\n\t\tfor(let key in buckets)\r\n\t\t{\r\n\t\t\tif(buckets.hasOwnProperty(key))\r\n\t\t\t{\r\n\t\t\t\tlet bucket = buckets[key];\r\n\t\t\t\tdelete buckets[key];\r\n\t\t\t\tlinkedNodeList(bucket);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn _._entries.clear();\r\n\t}\r\n\r\n\t/*\r\n\t * Note: super.getEnumerator() works perfectly well,\r\n\t * but enumerating the internal linked node list is much more efficient.\r\n\t */\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar ver:number, currentEntry:IHashEntry<TKey, TValue>|null;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\tver = _._version;\r\n\t\t\t\tcurrentEntry = _._entries.first;\r\n\t\t\t},\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\tif(currentEntry)\r\n\t\t\t\t{\r\n\t\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t\t_.assertVersion(ver);\r\n\t\t\t\t\tvar result = {key: currentEntry.key, value: currentEntry.value};\r\n\t\t\t\t\tcurrentEntry = currentEntry.next || null;\r\n\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t}\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tprotected getKeys():TKey[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar result:TKey[] = [];\r\n\t\tvar e:any = _._entries && _._entries.first;\r\n\t\twhile(e)\r\n\t\t{\r\n\t\t\tresult.push(e.key);\r\n\t\t\te = e.next;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tprotected getValues():TValue[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar result:TValue[] = [];\r\n\t\tvar e:any = _._entries && _._entries.first;\r\n\t\twhile(e)\r\n\t\t{\r\n\t\t\tresult.push(e.value);\r\n\t\t\te = e.next;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n}\r\n\r\nexport default Dictionary;"]}