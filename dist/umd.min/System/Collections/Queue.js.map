{"version":3,"sources":["System/Collections/Queue.js","System/Collections/Queue.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","factory","module","exports","v","require","undefined","define","amd","assertZeroOrGreater","value","property","ArgumentOutOfRangeException_1","assertIntegerZeroOrGreater","Integer_1","assert","Compare_1","AU","Types_1","EnumeratorBase_1","NotImplementedException_1","InvalidOperationException_1","CollectionBase_1","MINIMUM_GROW","SHRINK_THRESHOLD","GROW_FACTOR_HALF","DEFAULT_CAPACITY","emptyArray","Queue","_super","source","equalityComparer","areEqual","call","_","_head","_tail","_size","isNumber","capacity","_array","initialize","se","isArrayLike","length","_importEntries","_capacity","getCount","_addInternal","item","array","size","len","newCapacity","setCapacity","tail","_removeInternal","max","_clearInternal","head","clear","trimExcess","_onDispose","dump","Infinity","result","isFinite","push","_dequeueInternal","_signalModification","forEach","action","_version","newArray","copyTo","enqueue","add","throwIfEmpty","removed","_incrementModified","dequeue","assertModifiable","modified","tryDequeue","out","_getElement","index","peek","threshold","Math","floor","isNaN","getEnumerator","version","yielder","assertVersion","yieldBreak","yieldReturn","defineProperty"],"mappings":"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","file":"System/Collections/Queue.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../Compare\", \"./Array/Utility\", \"../Types\", \"../Integer\", \"./Enumeration/EnumeratorBase\", \"../Exceptions/NotImplementedException\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentOutOfRangeException\", \"./CollectionBase\"], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var Compare_1 = require(\"../Compare\");\n    var AU = require(\"./Array/Utility\");\n    var Types_1 = require(\"../Types\");\n    var Integer_1 = require(\"../Integer\");\n    var EnumeratorBase_1 = require(\"./Enumeration/EnumeratorBase\");\n    var NotImplementedException_1 = require(\"../Exceptions/NotImplementedException\");\n    var InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\n    var ArgumentOutOfRangeException_1 = require(\"../Exceptions/ArgumentOutOfRangeException\");\n    var CollectionBase_1 = require(\"./CollectionBase\");\n    var MINIMUM_GROW = 4;\n    var SHRINK_THRESHOLD = 32;\n    var GROW_FACTOR_HALF = 100;\n    var DEFAULT_CAPACITY = MINIMUM_GROW;\n    var emptyArray = [];\n    var Queue = (function (_super) {\n        __extends(Queue, _super);\n        function Queue(source, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Compare_1.areEqual; }\n            _super.call(this, null, equalityComparer);\n            var _ = this;\n            _._head = 0;\n            _._tail = 0;\n            _._size = 0;\n            if (!source)\n                _._array = emptyArray;\n            else {\n                if (Types_1.default.isNumber(source)) {\n                    var capacity = source;\n                    assertIntegerZeroOrGreater(capacity, \"capacity\");\n                    _._array = capacity\n                        ? AU.initialize(capacity)\n                        : emptyArray;\n                }\n                else {\n                    var se = source;\n                    _._array = AU.initialize(Types_1.default.isArrayLike(se)\n                        ? se.length\n                        : DEFAULT_CAPACITY);\n                    _._importEntries(se);\n                }\n            }\n            _._capacity = _._array.length;\n        }\n        Queue.prototype.getCount = function () {\n            return this._size;\n        };\n        Queue.prototype._addInternal = function (item) {\n            var _ = this, array = _._array, size = _._size, len = _._capacity;\n            if (size == len) {\n                var newCapacity = len * GROW_FACTOR_HALF;\n                if (newCapacity < len + MINIMUM_GROW)\n                    newCapacity = len + MINIMUM_GROW;\n                _.setCapacity(newCapacity);\n                array = _._array;\n                len = _._capacity;\n            }\n            var tail = _._tail;\n            array[tail] = item;\n            _._tail = (tail + 1) % len;\n            _._size = size + 1;\n            return true;\n        };\n        Queue.prototype._removeInternal = function (item, max) {\n            throw new NotImplementedException_1.default(\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\n                \" since it would require destroying the underlying array to remove the item.\");\n        };\n        Queue.prototype._clearInternal = function () {\n            var _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\n            if (head < tail)\n                AU.clear(array, head, tail);\n            else {\n                AU.clear(array, head, array.length - head);\n                AU.clear(array, 0, tail);\n            }\n            _._head = 0;\n            _._tail = 0;\n            _._size = 0;\n            _.trimExcess();\n            return size;\n        };\n        Queue.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            var _ = this;\n            if (_._array != emptyArray) {\n                _._array.length = _._capacity = 0;\n                _._array = emptyArray;\n            }\n        };\n        Queue.prototype.dump = function (max) {\n            if (max === void 0) { max = Infinity; }\n            var _ = this, result = [];\n            if (isFinite(max)) {\n                Integer_1.default.assertZeroOrGreater(max);\n                if (max !== 0) {\n                    while (max-- && _._size) {\n                        result.push(_._dequeueInternal());\n                    }\n                }\n            }\n            else {\n                while (_._size) {\n                    result.push(_._dequeueInternal());\n                }\n            }\n            _.trimExcess();\n            _._signalModification();\n            return result;\n        };\n        Queue.prototype.forEach = function (action) {\n            _super.prototype.forEach.call(this, action, true);\n        };\n        Queue.prototype.setCapacity = function (capacity) {\n            assertIntegerZeroOrGreater(capacity, \"capacity\");\n            var _ = this, array = _._array, len = _._capacity;\n            if (capacity == len)\n                return;\n            var head = _._head, tail = _._tail, size = _._size;\n            if (array != emptyArray && capacity > len && head < tail) {\n                array.length = _._capacity = capacity;\n                _._version++;\n                return;\n            }\n            var newArray = AU.initialize(capacity);\n            if (size > 0) {\n                if (head < tail) {\n                    AU.copyTo(array, newArray, head, 0, size);\n                }\n                else {\n                    AU.copyTo(array, newArray, head, 0, len - head);\n                    AU.copyTo(array, newArray, 0, len - head, tail);\n                }\n            }\n            _._array = newArray;\n            _._capacity = capacity;\n            _._head = 0;\n            _._tail = (size == capacity) ? 0 : size;\n            _._signalModification(true);\n        };\n        Queue.prototype.enqueue = function (item) {\n            this.add(item);\n        };\n        Queue.prototype._dequeueInternal = function (throwIfEmpty) {\n            if (throwIfEmpty === void 0) { throwIfEmpty = false; }\n            var _ = this;\n            if (_._size == 0) {\n                if (throwIfEmpty)\n                    throw new InvalidOperationException_1.default(\"Cannot dequeue an empty queue.\");\n                return void 0;\n            }\n            var array = _._array, head = _._head;\n            var removed = _._array[head];\n            array[head] = null;\n            _._head = (head + 1) % _._capacity;\n            _._size--;\n            _._incrementModified();\n            return removed;\n        };\n        Queue.prototype.dequeue = function (throwIfEmpty) {\n            if (throwIfEmpty === void 0) { throwIfEmpty = false; }\n            var _ = this;\n            _.assertModifiable();\n            var modified = !!_._size;\n            var v = this._dequeueInternal(throwIfEmpty);\n            if (modified && _._size < _._capacity / 2)\n                _.trimExcess(SHRINK_THRESHOLD);\n            _._signalModification();\n            return v;\n        };\n        Queue.prototype.tryDequeue = function (out) {\n            if (!this._size)\n                return false;\n            var d = this.dequeue();\n            if (out)\n                out(d);\n            return true;\n        };\n        Queue.prototype._getElement = function (index) {\n            assertIntegerZeroOrGreater(index, \"index\");\n            var _ = this;\n            return _._array[(_._head + index) % _._capacity];\n        };\n        Queue.prototype.peek = function () {\n            if (this._size == 0)\n                throw new InvalidOperationException_1.default(\"Cannot call peek on an empty queue.\");\n            return this._array[this._head];\n        };\n        Queue.prototype.trimExcess = function (threshold) {\n            var _ = this;\n            var size = _._size;\n            if (size < Math.floor(_._capacity * 0.9) && (isNaN(threshold) || threshold < size))\n                _.setCapacity(size);\n        };\n        Queue.prototype.getEnumerator = function () {\n            var _ = this;\n            var index;\n            var version;\n            return new EnumeratorBase_1.default(function () {\n                version = _._version;\n                index = 0;\n            }, function (yielder) {\n                _.assertVersion(version);\n                if (index == _._size)\n                    return yielder.yieldBreak();\n                return yielder.yieldReturn(_._getElement(index++));\n            });\n        };\n        return Queue;\n    }(CollectionBase_1.default));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Queue;\n    function assertZeroOrGreater(value, property) {\n        if (value < 0)\n            throw new ArgumentOutOfRangeException_1.default(property, value, \"Must be greater than zero\");\n    }\n    function assertIntegerZeroOrGreater(value, property) {\n        Integer_1.default.assert(value, property);\n        assertZeroOrGreater(value, property);\n    }\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ICollection.d.ts\"/>\r\n///<reference path=\"IList.d.ts\"/>\r\n///<reference path=\"Enumeration/IEnumerateEach.d.ts\"/>\r\n///<reference path=\"../FunctionTypes.d.ts\"/>\r\n///<reference path=\"IEnumerableOrArray.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport {areEqual} from \"../Compare\";\r\nimport * as AU from \"./Array/Utility\";\r\nimport Type from \"../Types\";\r\nimport Integer from \"../Integer\";\r\nimport EnumeratorBase from \"./Enumeration/EnumeratorBase\";\r\nimport NotImplementedException from \"../Exceptions/NotImplementedException\";\r\nimport InvalidOperationException from \"../Exceptions/InvalidOperationException\";\r\nimport ArgumentOutOfRangeException from \"../Exceptions/ArgumentOutOfRangeException\";\r\nimport CollectionBase from \"./CollectionBase\";\r\n\r\nconst MINIMUM_GROW:number = 4;\r\nconst SHRINK_THRESHOLD:number = 32; // Unused?\r\n// var GROW_FACTOR: number = 200;  // double each time\r\nconst GROW_FACTOR_HALF:number = 100;\r\nconst DEFAULT_CAPACITY:number = MINIMUM_GROW;\r\nvar emptyArray:any[] = [];\r\n\r\nexport default\r\nclass Queue<T>\r\nextends CollectionBase<T>\r\n{\r\n\r\n\tprivate _array:T[];\r\n\tprivate _head:number;       // First valid element in the queue\r\n\tprivate _tail:number;       // Last valid element in the queue\r\n\tprivate _size:number;       // Number of elements.\r\n\tprivate _capacity:number;   // Maps to _array.length;\r\n\r\n\tconstructor(\r\n\t\tsource?:IEnumerableOrArray<T> | number,\r\n\t\tequalityComparer:EqualityComparison<T> = areEqual)\r\n\t{\r\n\t\tsuper(null,equalityComparer);\r\n\t\tvar _ = this;\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\r\n\t\tif(!source)\r\n\t\t\t_._array = emptyArray;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(Type.isNumber(source))\r\n\t\t\t{\r\n\t\t\t\tvar capacity = <number>source;\r\n\t\t\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\t\t\t_._array = capacity\r\n\t\t\t\t\t? AU.initialize<T>(capacity)\r\n\t\t\t\t\t: emptyArray;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tvar se = <IEnumerableOrArray<T>> source;\r\n\t\t\t\t_._array = AU.initialize<T>(\r\n\t\t\t\t\tType.isArrayLike(se)\r\n\t\t\t\t\t\t? se.length\r\n\t\t\t\t\t\t: DEFAULT_CAPACITY\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_._importEntries(se);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._capacity = _._array.length;\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\tprotected _addInternal(item:T):boolean\r\n\t{\r\n\t\tvar _ = this, array = _._array, size = _._size, len = _._capacity;\r\n\t\tif(size==len)\r\n\t\t{\r\n\t\t\tvar newCapacity = len*GROW_FACTOR_HALF;\r\n\t\t\tif(newCapacity<len + MINIMUM_GROW)\r\n\t\t\t\tnewCapacity = len + MINIMUM_GROW;\r\n\r\n\t\t\t_.setCapacity(newCapacity);\r\n\t\t\tarray = _._array;\r\n\t\t\tlen = _._capacity;\r\n\t\t}\r\n\r\n\t\tvar tail = _._tail;\r\n\t\tarray[tail] = item;\r\n\t\t_._tail = (tail + 1)%len;\r\n\t\t_._size = size + 1;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprotected _removeInternal(item:T, max?:number):number\r\n\t{\r\n\t\tthrow new NotImplementedException(\r\n\t\t\t\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\r\n\t\t\t\" since it would require destroying the underlying array to remove the item.\"\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tvar _ = this, array = _._array, head = _._head, tail = _._tail, size = _._size;\r\n\t\tif(head<tail)\r\n\t\t\tAU.clear(array, head, tail);\r\n\t\telse\r\n\t\t{\r\n\t\t\tAU.clear(array, head, array.length - head);\r\n\t\t\tAU.clear(array, 0, tail);\r\n\t\t}\r\n\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\r\n\t\t_.trimExcess();\r\n\r\n\t\treturn size;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tvar _ = this;\r\n\t\tif(_._array!=emptyArray)\r\n\t\t{\r\n\t\t\t_._array.length = _._capacity = 0;\r\n\t\t\t_._array = emptyArray;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Dequeues entries into an array.\r\n\t */\r\n\tdump(max:number = Infinity):T[]\r\n\t{\r\n\t\tvar _ = this, result:T[] = [];\r\n\r\n\t\tif(isFinite(max))\r\n\t\t{\r\n\t\t\tInteger.assertZeroOrGreater(max);\r\n\t\t\tif(max!==0)\r\n\t\t\t{\r\n\t\t\t\twhile(max-- && _._size)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.push(_._dequeueInternal());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile(_._size)\r\n\t\t\t{\r\n\t\t\t\tresult.push(_._dequeueInternal());\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_.trimExcess();\r\n\t\t_._signalModification();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void\r\n\t{\r\n\t\tsuper.forEach(action,true);\r\n\t}\r\n\r\n\tsetCapacity(capacity:number):void\r\n\t{\r\n\r\n\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\tvar _ = this, array = _._array, len = _._capacity;\r\n\r\n\t\tif(capacity==len)\r\n\t\t\treturn;\r\n\r\n\t\tvar head = _._head, tail = _._tail, size = _._size;\r\n\r\n\t\t// Special case where we can simply extend the length of the array. (JavaScript only)\r\n\t\tif(array!=emptyArray && capacity>len && head<tail)\r\n\t\t{\r\n\t\t\tarray.length = _._capacity = capacity;\r\n\t\t\t_._version++;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// We create a new array because modifying an existing one could be slow.\r\n\t\tvar newArray:T[] = AU.initialize<T>(capacity);\r\n\t\tif(size>0)\r\n\t\t{\r\n\t\t\tif(head<tail)\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, size);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, len - head);\r\n\t\t\t\tAU.copyTo(array, newArray, 0, len - head, tail);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._array = newArray;\r\n\t\t_._capacity = capacity;\r\n\t\t_._head = 0;\r\n\t\t_._tail = (size==capacity) ? 0 : size;\r\n\t\t\r\n\t\t_._signalModification(true);\r\n\t}\r\n\r\n\tenqueue(item:T):void\r\n\t{\r\n\t\tthis.add(item);\r\n\t}\r\n\r\n\r\n\tprotected _dequeueInternal(throwIfEmpty:boolean = false):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(_._size==0)\r\n\t\t{\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow new InvalidOperationException(\"Cannot dequeue an empty queue.\");\r\n\t\t\treturn void 0;\r\n\t\t}\r\n\r\n\t\tvar array = _._array, head = _._head;\r\n\r\n\t\tvar removed = _._array[head];\r\n\t\tarray[head] = null;\r\n\t\t_._head = (head + 1)%_._capacity;\r\n\r\n\t\t_._size--;\r\n\r\n\t\t_._incrementModified();\r\n\r\n\t\treturn removed;\r\n\t}\r\n\r\n\tdequeue(throwIfEmpty:boolean = false):T {\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\t// A single dequeue shouldn't need update recursion tracking...\r\n\t\tvar modified = !!_._size;\r\n\t\tvar v = this._dequeueInternal(throwIfEmpty);\r\n\r\n\t\t// This may preemptively trigger the _onModified.\r\n\t\tif(modified && _._size<_._capacity/2)\r\n\t\t\t_.trimExcess(SHRINK_THRESHOLD);\r\n\r\n\t\t_._signalModification();\r\n\t\treturn v;\r\n\t}\r\n\r\n\r\n\ttryDequeue(out:(value:T)=>void):boolean\r\n\t{\r\n\t\tif(!this._size) return false;\r\n\t\tvar d = this.dequeue();\r\n\t\tif(out) out(d);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tprivate _getElement(index:number):T\r\n\t{\r\n\t\tassertIntegerZeroOrGreater(index, \"index\");\r\n\r\n\t\tvar _ = this;\r\n\t\treturn _._array[(_._head + index)%_._capacity];\r\n\t}\r\n\r\n\tpeek():T\r\n\t{\r\n\t\tif(this._size==0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot call peek on an empty queue.\");\r\n\r\n\t\treturn this._array[this._head];\r\n\t}\r\n\r\n\ttrimExcess(threshold?:number):void\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar size = _._size;\r\n\t\tif(size<Math.floor(_._capacity*0.9) && (isNaN(threshold) || threshold<size))\r\n\t\t\t_.setCapacity(size);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar index:number;\r\n\t\tvar version:number;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tversion = _._version;\r\n\t\t\t\tindex = 0;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\t_.assertVersion(version);\r\n\r\n\t\t\t\tif(index==_._size)\r\n\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\treturn yielder.yieldReturn(_._getElement(index++));\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction assertZeroOrGreater(value:number, property:string):void\r\n{\r\n\tif(value<0)\r\n\t\tthrow new ArgumentOutOfRangeException(property, value, \"Must be greater than zero\");\r\n\r\n}\r\n\r\nfunction assertIntegerZeroOrGreater(value:number, property:string):void\r\n{\r\n\tInteger.assert(value, property);\r\n\tassertZeroOrGreater(value, property);\r\n}\r\n"]}