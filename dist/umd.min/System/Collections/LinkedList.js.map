{"version":3,"sources":["System/Collections/LinkedList.js","System/Collections/LinkedList.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","ensureExternal","node","list","getInternal","Values","TextUtility","ArrayUtility","Enumerator","EnumeratorBase_1","InvalidOperationException_1","ArgumentException_1","ArgumentNullException_1","ArgumentOutOfRangeException_1","Node","Node.constructor","Node.assertDetached","LinkedList","LinkedList.constructor","LinkedList._addFirst","LinkedList._addLast","LinkedList._addNodeBefore","LinkedList._addNodeAfter","LinkedList._findFirst","LinkedList._findLast","LinkedList.forEach","LinkedList.getEnumerator","get","LinkedList.count","enumerable","configurable","LinkedList.isReadOnly","LinkedList.add","LinkedList.clear","LinkedList.contains","LinkedList.copyTo","LinkedList.toArray","LinkedList.removeOnce","LinkedList.remove","LinkedList.first","LinkedList.last","LinkedList._getNodeAt","LinkedList.getValueAt","LinkedList.getNodeAt","LinkedList.find","LinkedList.findLast","LinkedList.addFirst","LinkedList.addLast","LinkedList.removeFirst","LinkedList.removeLast","LinkedList.removeNode","LinkedList.addBefore","LinkedList.addAfter","LinkedList.addNodeBefore","LinkedList.addNodeAfter","Object","defineProperty","value","LinkedListNode","LinkedListNode.constructor","LinkedListNode.list","LinkedListNode.previous","LinkedListNode.next","LinkedListNode.value","set","LinkedListNode.addBefore","LinkedListNode.addAfter","LinkedListNode.addNodeBefore","LinkedListNode.addNodeAfter","LinkedListNode.remove"],"mappings":"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","file":"System/Collections/LinkedList.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../Compare', '../Text/Utility', '../Collections/Array/Utility', './Enumeration/Enumerator', './Enumeration/EnumeratorBase', '../Exceptions/InvalidOperationException', '../Exceptions/ArgumentException', '../Exceptions/ArgumentNullException', '../Exceptions/ArgumentOutOfRangeException'], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var Values = require('../Compare');\n    var TextUtility = require('../Text/Utility');\n    var ArrayUtility = require('../Collections/Array/Utility');\n    var Enumerator = require('./Enumeration/Enumerator');\n    var EnumeratorBase_1 = require('./Enumeration/EnumeratorBase');\n    var InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\n    var ArgumentException_1 = require('../Exceptions/ArgumentException');\n    var ArgumentNullException_1 = require('../Exceptions/ArgumentNullException');\n    var ArgumentOutOfRangeException_1 = require('../Exceptions/ArgumentOutOfRangeException');\n    var Node = (function () {\n        function Node(value, prev, next) {\n            this.value = value;\n            this.prev = prev;\n            this.next = next;\n        }\n        Node.prototype.assertDetached = function () {\n            if (this.next || this.prev)\n                throw new InvalidOperationException_1.default(\"Adding a node that is already placed.\");\n        };\n        return Node;\n    })();\n    function ensureExternal(node, list) {\n        if (!node)\n            return null;\n        var external = node.external;\n        if (!external)\n            node.external = external = new LinkedListNode(list, node);\n        return external;\n    }\n    function getInternal(node, list) {\n        if (!node)\n            throw new ArgumentNullException_1.default(\"Cannot be null.\");\n        if (node.list != list)\n            throw new InvalidOperationException_1.default(\"Provided node does not belong to this list.\");\n        var n = node._node;\n        if (!n)\n            throw new InvalidOperationException_1.default(\"Provided node is not valid.\");\n        return n;\n    }\n    var LinkedList = (function () {\n        function LinkedList(source) {\n            var _ = this, c = 0, first = null, last = null;\n            var e = Enumerator.from(source);\n            if (e.moveNext()) {\n                first = last = new Node(e.current);\n                ++c;\n            }\n            while (e.moveNext()) {\n                last = last.next = new Node(e.current, last);\n                ++c;\n            }\n            _._first = first;\n            _._last = last;\n            _._count = c;\n        }\n        LinkedList.prototype._addFirst = function (entry) {\n            var _ = this, first = _._first;\n            var prev = new Node(entry, null, first);\n            if (first)\n                first.prev = prev;\n            else\n                _._last = prev;\n            _._first = prev;\n            _._count += 1;\n            return prev;\n        };\n        LinkedList.prototype._addLast = function (entry) {\n            var _ = this, last = _._last;\n            var next = new Node(entry, last);\n            if (last)\n                last.next = next;\n            else\n                _._first = next;\n            _._last = next;\n            _._count += 1;\n            return next;\n        };\n        LinkedList.prototype._addNodeBefore = function (n, inserting) {\n            inserting.assertDetached();\n            inserting.next = n;\n            inserting.prev = n.prev;\n            n.prev.next = inserting;\n            n.prev = inserting;\n            this._count += 1;\n        };\n        LinkedList.prototype._addNodeAfter = function (n, inserting) {\n            inserting.assertDetached();\n            inserting.prev = n;\n            inserting.next = n.next;\n            n.next.prev = inserting;\n            n.next = inserting;\n            this._count += 1;\n        };\n        LinkedList.prototype._findFirst = function (entry) {\n            var equals = Values.areEqual, next = this._first;\n            while (next) {\n                if (equals(entry, next.value))\n                    return next;\n                next = next.next;\n            }\n            return null;\n        };\n        LinkedList.prototype._findLast = function (entry) {\n            var equals = Values.areEqual, prev = this._last;\n            while (prev) {\n                if (equals(entry, prev.value))\n                    return prev;\n                prev = prev.prev;\n            }\n            return null;\n        };\n        LinkedList.prototype.forEach = function (action, useCopy) {\n            if (useCopy === void 0) { useCopy = false; }\n            if (useCopy) {\n                var array = this.toArray();\n                ArrayUtility.forEach(array, action);\n                array.length = 0;\n            }\n            else {\n                var next = this._first, index = 0;\n                while (next && action(next.value, index++) !== false) {\n                    next = next.next;\n                }\n            }\n        };\n        LinkedList.prototype.getEnumerator = function () {\n            var _ = this, current;\n            return new EnumeratorBase_1.default(function () {\n                current = new Node(null, null, _._first);\n            }, function (yielder) {\n                return (current = current.next)\n                    ? yielder.yieldReturn(current.value)\n                    : yielder.yieldBreak();\n            });\n        };\n        Object.defineProperty(LinkedList.prototype, \"count\", {\n            get: function () {\n                return this._count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"isReadOnly\", {\n            get: function () {\n                return false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedList.prototype.add = function (entry) {\n            this._addLast(entry);\n        };\n        LinkedList.prototype.clear = function () {\n            var _ = this;\n            _._first = null;\n            _._last = null;\n            var count = _._count;\n            _._count = 0;\n            return count;\n        };\n        LinkedList.prototype.contains = function (entry) {\n            var found = false, equals = Values.areEqual;\n            this.forEach(function (e) { return !(found = equals(entry, e)); });\n            return found;\n        };\n        LinkedList.prototype.copyTo = function (array, index) {\n            if (index === void 0) { index = 0; }\n            this.forEach(function (entry, i) {\n                array[index + i] = entry;\n            });\n            return array;\n        };\n        LinkedList.prototype.toArray = function () {\n            var array = ArrayUtility.initialize(this._count);\n            return this.copyTo(array);\n        };\n        LinkedList.prototype.removeOnce = function (entry) {\n            var _ = this;\n            var node = _._findFirst(entry);\n            if (node) {\n                var prev = node.prev, next = node.next;\n                if (prev)\n                    prev.next = next;\n                else\n                    _._first = next;\n                if (next)\n                    next.prev = prev;\n                else\n                    _._last = prev;\n                _._count -= 1;\n            }\n            return node != null;\n        };\n        LinkedList.prototype.remove = function (entry) {\n            var _ = this, removedCount = 0;\n            while (_.removeOnce(entry)) {\n                ++removedCount;\n            }\n            return removedCount;\n        };\n        Object.defineProperty(LinkedList.prototype, \"first\", {\n            get: function () {\n                return ensureExternal(this._first, this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedList.prototype, \"last\", {\n            get: function () {\n                return ensureExternal(this._last, this);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedList.prototype._getNodeAt = function (index) {\n            if (index < 0)\n                throw new ArgumentOutOfRangeException_1.default('index', index, 'Is less than zero.');\n            if (index >= this._count)\n                throw new ArgumentOutOfRangeException_1.default('index', index, 'Is greater than count.');\n            var next = this._first, i = 0;\n            while (next && index < i++) {\n                next = next.next;\n            }\n            return next;\n        };\n        LinkedList.prototype.getValueAt = function (index) {\n            return this._getNodeAt(index).value;\n        };\n        LinkedList.prototype.getNodeAt = function (index) {\n            return ensureExternal(this._getNodeAt(index), this);\n        };\n        LinkedList.prototype.find = function (entry) {\n            return ensureExternal(this._findFirst(entry), this);\n        };\n        LinkedList.prototype.findLast = function (entry) {\n            return ensureExternal(this._findLast(entry), this);\n        };\n        LinkedList.prototype.addFirst = function (entry) {\n            this._addFirst(entry);\n        };\n        LinkedList.prototype.addLast = function (entry) {\n            this._addLast(entry);\n        };\n        LinkedList.prototype.removeFirst = function () {\n            var _ = this, first = _._first;\n            if (first) {\n                var next = first.next;\n                _._first = next;\n                if (next)\n                    next.prev = null;\n                _._count -= 1;\n            }\n        };\n        LinkedList.prototype.removeLast = function () {\n            var _ = this, last = _._last;\n            if (last) {\n                var prev = last.prev;\n                _._last = prev;\n                if (prev)\n                    prev.next = null;\n                _._count -= 1;\n            }\n        };\n        LinkedList.prototype.removeNode = function (node) {\n            var _ = this;\n            var n = getInternal(node, _);\n            var prev = n.prev, next = n.next, a = false, b = false;\n            if (prev)\n                prev.next = next;\n            else if (_._first == n)\n                _._first = next;\n            else\n                a = true;\n            if (next)\n                next.prev = prev;\n            else if (_._last == n)\n                _._last = prev;\n            else\n                b = true;\n            if (a !== b) {\n                throw new ArgumentException_1.default('node', TextUtility.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\n            }\n            return !a && !b;\n        };\n        LinkedList.prototype.addBefore = function (node, entry) {\n            this._addNodeBefore(getInternal(node, this), new Node(entry));\n        };\n        LinkedList.prototype.addAfter = function (node, entry) {\n            this._addNodeAfter(getInternal(node, this), new Node(entry));\n        };\n        LinkedList.prototype.addNodeBefore = function (node, before) {\n            this._addNodeBefore(getInternal(node, this), getInternal(before, this));\n        };\n        LinkedList.prototype.addNodeAfter = function (node, after) {\n            this._addNodeAfter(getInternal(node, this), getInternal(after, this));\n        };\n        return LinkedList;\n    })();\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = LinkedList;\n    var LinkedListNode = (function () {\n        function LinkedListNode(_list, _node) {\n            this._list = _list;\n            this._node = _node;\n        }\n        Object.defineProperty(LinkedListNode.prototype, \"list\", {\n            get: function () {\n                return this._list;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"previous\", {\n            get: function () {\n                return ensureExternal(this._node.prev, this._list);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"next\", {\n            get: function () {\n                return ensureExternal(this._node.next, this._list);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedListNode.prototype, \"value\", {\n            get: function () {\n                return this._node.value;\n            },\n            set: function (v) {\n                this._node.value = v;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedListNode.prototype.addBefore = function (entry) {\n            this._list.addBefore(this, entry);\n        };\n        LinkedListNode.prototype.addAfter = function (entry) {\n            this._list.addAfter(this, entry);\n        };\n        LinkedListNode.prototype.addNodeBefore = function (before) {\n            this._list.addNodeBefore(this, before);\n        };\n        LinkedListNode.prototype.addNodeAfter = function (after) {\n            this._list.addNodeAfter(this, after);\n        };\n        LinkedListNode.prototype.remove = function () {\n            this._list.removeNode(this);\n        };\n        return LinkedListNode;\n    })();\n});\n","/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://msdn.microsoft.com/en-us/library/he2s3bh7%28v=vs.110%29.aspx\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n///<reference path=\"ILinkedList.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as Values from '../Compare';\r\nimport * as TextUtility from '../Text/Utility';\r\nimport * as ArrayUtility from '../Collections/Array/Utility';\r\nimport * as Enumerator from './Enumeration/Enumerator';\r\nimport EnumeratorBase from './Enumeration/EnumeratorBase';\r\n\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\n\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\nimport ArgumentOutOfRangeException from '../Exceptions/ArgumentOutOfRangeException';\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n\r\nclass Node<T>\r\n{\r\n\tconstructor(\r\n\t\tpublic value?:T,\r\n\t\tpublic prev?:Node<T>,\r\n\t\tpublic next?:Node<T>)\r\n\t{\r\n\t}\r\n\r\n\texternal:ILinkedListNode<T>;\r\n\r\n\tassertDetached():void\r\n\t{\r\n\t\tif(this.next || this.prev)\r\n\t\t\tthrow new InvalidOperationException(\r\n\t\t\t\t\"Adding a node that is already placed.\");\r\n\t}\r\n\r\n}\r\n\r\nfunction ensureExternal<T>(node:Node<T>, list:LinkedList<T>):ILinkedListNode<T>\r\n{\r\n\tif(!node)\r\n\t\treturn null;\r\n\r\n\tvar external:ILinkedListNode<T> = node.external;\r\n\tif(!external)\r\n\t\tnode.external = external = new LinkedListNode<T>(list, node);\r\n\r\n\treturn external;\r\n}\r\n\r\nfunction getInternal<T>(node:ILinkedListNode<T>, list:LinkedList<T>):Node<T>\r\n{\r\n\tif(!node)\r\n\t\tthrow new ArgumentNullException(\r\n\t\t\t\"Cannot be null.\");\r\n\r\n\tif(node.list!=list)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node does not belong to this list.\");\r\n\r\n\tvar n:Node<T> = (<any>node)._node;\r\n\tif(!n)\r\n\t\tthrow new InvalidOperationException(\r\n\t\t\t\"Provided node is not valid.\");\r\n\r\n\treturn n;\r\n}\r\n\r\nexport default\r\nclass LinkedList<T>\r\nimplements ILinkedList<T>\r\n{\r\n\tprivate _first:Node<T>;\r\n\tprivate _last:Node<T>;\r\n\tprivate _count:number;\r\n\r\n\tconstructor(source?:IEnumerable<T>);\r\n\tconstructor(source?:IArray<T>);\r\n\tconstructor(source:any)\r\n\t{\r\n\t\tvar _ = this, c = 0, first:Node<T> = null, last:Node<T> = null;\r\n\t\tvar e = Enumerator.from<T>(source);\r\n\r\n\t\tif(e.moveNext())\r\n\t\t{\r\n\t\t\tfirst = last = new Node<T>(e.current);\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tlast = last.next = new Node<T>(e.current, last);\r\n\t\t\t++c;\r\n\t\t}\r\n\r\n\t\t_._first = first;\r\n\t\t_._last = last;\r\n\t\t_._count = c;\r\n\t}\r\n\r\n\t// #region Internals.\r\n\r\n\tprivate _addFirst(entry:T):Node<T>\r\n\t{\r\n\t\tvar _ = this, first = _._first;\r\n\t\tvar prev = new Node(entry, null, first);\r\n\t\tif(first)\r\n\t\t\tfirst.prev = prev;\r\n\t\telse\r\n\t\t\t_._last = prev;\r\n\r\n\t\t_._first = prev;\r\n\r\n\t\t_._count += 1;\r\n\r\n\t\treturn prev;\r\n\t}\r\n\r\n\tprivate _addLast(entry:T):Node<T>\r\n\t{\r\n\t\tvar _ = this, last = _._last;\r\n\t\tvar next = new Node(entry, last);\r\n\t\tif(last)\r\n\t\t\tlast.next = next;\r\n\t\telse\r\n\t\t\t_._first = next;\r\n\r\n\t\t_._last = next;\r\n\t\t_._count += 1;\r\n\r\n\t\treturn next;\r\n\t}\r\n\r\n\tprivate _addNodeBefore(n:Node<T>, inserting:Node<T>):void\r\n\t{\r\n\t\tinserting.assertDetached();\r\n\r\n\t\tinserting.next = n;\r\n\t\tinserting.prev = n.prev;\r\n\r\n\t\tn.prev.next = inserting;\r\n\t\tn.prev = inserting;\r\n\r\n\t\tthis._count += 1;\r\n\t}\r\n\r\n\r\n\tprivate _addNodeAfter(n:Node<T>, inserting:Node<T>):void\r\n\t{\r\n\t\tinserting.assertDetached();\r\n\r\n\t\tinserting.prev = n;\r\n\t\tinserting.next = n.next;\r\n\r\n\t\tn.next.prev = inserting;\r\n\t\tn.next = inserting;\r\n\r\n\t\tthis._count += 1;\r\n\t}\r\n\r\n\tprivate _findFirst(entry:T):Node<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    next   = this._first;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\tif(equals(entry, next.value))\r\n\t\t\t\treturn next;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate _findLast(entry:T):Node<T>\r\n\t{\r\n\t\tvar equals = Values.areEqual,\r\n\t\t    prev   = this._last;\r\n\t\twhile(prev)\r\n\t\t{\r\n\t\t\tif(equals(entry, prev.value))\r\n\t\t\t\treturn prev;\r\n\t\t\tprev = prev.prev;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\t// #region IEnumerateEach<T>\r\n\tforEach(\r\n\t\taction:Predicate<T> | Action<T>,\r\n\t\tuseCopy:boolean = false):void\r\n\t{\r\n\t\tif(useCopy)\r\n\t\t{\r\n\t\t\tvar array = this.toArray();\r\n\t\t\tArrayUtility.forEach(array, action);\r\n\t\t\tarray.length = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tvar next = this._first, index:number = 0;\r\n\t\t\twhile(next && <any>action(next.value, index++)!==false)\r\n\t\t\t{\r\n\t\t\t\tnext = next.next;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IEnumerable<T>\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tvar _ = this, current:Node<T>;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tcurrent = new Node(null, null, _._first);\r\n\t\t\t}, // Initialize anchor...\r\n\t\t\t(yielder)=>\r\n\t\t\t\t(current = current.next)\r\n\t\t\t\t\t? yielder.yieldReturn(current.value)\r\n\t\t\t\t\t: yielder.yieldBreak()\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region ICollection<T>\r\n\tget count():number\r\n\t{\r\n\t\treturn this._count;\r\n\t}\r\n\r\n\tget isReadOnly():boolean\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\tadd(entry:T):void\r\n\t{\r\n\t\tthis._addLast(entry);\r\n\t}\r\n\r\n\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_._first = null;\r\n\t\t_._last = null;\r\n\t\tvar count = _._count;\r\n\t\t_._count = 0;\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\tcontains(entry:T):boolean\r\n\t{\r\n\t\tvar found:boolean = false, equals = Values.areEqual;\r\n\t\tthis.forEach(e => !(found = equals(entry, e)));\r\n\t\treturn found;\r\n\t}\r\n\r\n\tcopyTo(array:T[], index:number = 0):T[]\r\n\t{\r\n\t\tthis.forEach(\r\n\t\t\t(entry, i) =>\r\n\t\t\t{\r\n\t\t\t\tarray[index + i] = entry;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar array = ArrayUtility.initialize<T>(this._count);\r\n\t\treturn this.copyTo(array);\r\n\t}\r\n\r\n\tremoveOnce(entry:T):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar node:Node<T> = _._findFirst(entry);\r\n\t\tif(node)\r\n\t\t{\r\n\t\t\tvar prev = node.prev, next = node.next;\r\n\t\t\tif(prev) prev.next = next;\r\n\t\t\telse _._first = next;\r\n\t\t\tif(next) next.prev = prev;\r\n\t\t\telse _._last = prev;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\r\n\t\treturn node!=null;\r\n\r\n\t}\r\n\r\n\tremove(entry:T):number\r\n\t{\r\n\t\tvar _ = this, removedCount:number = 0;\r\n\t\twhile(_.removeOnce(entry))\r\n\t\t{\r\n\t\t\t++removedCount;\r\n\t\t}\r\n\t\treturn removedCount;\r\n\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\tget first():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._first, this);\r\n\t}\r\n\r\n\tget last():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._last, this);\r\n\t}\r\n\r\n\t// get methods are available for convenience but is an n*index operation.\r\n\r\n\tprivate _getNodeAt(index:number):Node<T>\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\r\n\t\t\t\t'index', index, 'Is less than zero.');\r\n\r\n\t\tif(index>=this._count)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\r\n\t\t\t\t'index', index, 'Is greater than count.');\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && index<i++)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tgetValueAt(index:number):T\r\n\t{\r\n\t\treturn this._getNodeAt(index).value;\r\n\t}\r\n\r\n\tgetNodeAt(index:number):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._getNodeAt(index), this);\r\n\t}\r\n\r\n\tfind(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findFirst(entry), this);\r\n\t}\r\n\r\n\tfindLast(entry:T):ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._findLast(entry), this);\r\n\t}\r\n\r\n\taddFirst(entry:T):void\r\n\t{\r\n\t\tthis._addFirst(entry);\r\n\t}\r\n\r\n\taddLast(entry:T):void\r\n\t{\r\n\t\tthis._addLast(entry);\r\n\t}\r\n\r\n\tremoveFirst():void\r\n\t{\r\n\t\tvar _ = this, first = _._first;\r\n\t\tif(first)\r\n\t\t{\r\n\t\t\tvar next = first.next;\r\n\t\t\t_._first = next;\r\n\t\t\tif(next) // Might have been the last.\r\n\t\t\t\tnext.prev = null;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\tremoveLast():void\r\n\t{\r\n\t\tvar _ = this, last = _._last;\r\n\t\tif(last)\r\n\t\t{\r\n\t\t\tvar prev = last.prev;\r\n\t\t\t_._last = prev;\r\n\t\t\tif(prev) // Might have been the first.\r\n\t\t\t\tprev.next = null;\r\n\r\n\t\t\t_._count -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Returns true if successful and false if not found (already removed).\r\n\tremoveNode(node:ILinkedListNode<T>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar n:Node<T> = getInternal(node, _);\r\n\t\tvar prev = n.prev, next = n.next, a:boolean = false, b:boolean = false;\r\n\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==n) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.prev = prev;\r\n\t\telse if(_._last==n) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn !a && !b;\r\n\r\n\t}\r\n\r\n\taddBefore(node:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._addNodeBefore(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tnew Node(entry)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\taddAfter(node:ILinkedListNode<T>, entry:T):void\r\n\t{\r\n\t\tthis._addNodeAfter(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tnew Node(entry)\r\n\t\t);\r\n\t}\r\n\r\n\taddNodeBefore(node:ILinkedListNode<T>, before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._addNodeBefore(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tgetInternal(before, this)\r\n\t\t);\r\n\t}\r\n\r\n\taddNodeAfter(node:ILinkedListNode<T>, after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._addNodeAfter(\r\n\t\t\tgetInternal(node, this),\r\n\t\t\tgetInternal(after, this)\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n// Use an internal node class to prevent mucking up the LinkedList.\r\nclass LinkedListNode<T> implements ILinkedListNode<T>\r\n{\r\n\tconstructor(\r\n\t\tprivate _list:LinkedList<T>,\r\n\t\tprivate _node:Node<T>)\r\n\t{\r\n\t}\r\n\r\n\tget list():LinkedList<T>\r\n\t{\r\n\t\treturn this._list;\r\n\t}\r\n\r\n\tget previous():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._node.prev, this._list);\r\n\t}\r\n\r\n\tget next():ILinkedListNode<T>\r\n\t{\r\n\t\treturn ensureExternal(this._node.next, this._list);\r\n\t}\r\n\r\n\tget value():T\r\n\t{\r\n\t\treturn this._node.value;\r\n\t}\r\n\r\n\tset value(v:T)\r\n\t{\r\n\t\tthis._node.value = v;\r\n\t}\r\n\r\n\taddBefore(entry:T):void\r\n\t{\r\n\t\tthis._list.addBefore(this, entry);\r\n\t}\r\n\r\n\taddAfter(entry:T):void\r\n\t{\r\n\t\tthis._list.addAfter(this, entry);\r\n\t}\r\n\r\n\taddNodeBefore(before:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeBefore(this, before);\r\n\t}\r\n\r\n\taddNodeAfter(after:ILinkedListNode<T>):void\r\n\t{\r\n\t\tthis._list.addNodeAfter(this, after);\r\n\t}\r\n\r\n\tremove():void\r\n\t{\r\n\t\tthis._list.removeNode(this);\r\n\t}\r\n\r\n}\r\n\r\n"]}