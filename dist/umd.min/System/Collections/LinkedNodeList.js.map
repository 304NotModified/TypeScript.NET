{"version":3,"sources":["System/Collections/LinkedNodeList.js","System/Collections/LinkedNodeList.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","assertValidDetached","node","propName","ArgumentNullException_1","next","previous","InvalidOperationException_1","TextUtility","ArgumentException_1","LinkedNodeList","this","_first","_last","Object","defineProperty","prototype","get","enumerable","configurable","i","clear","n","_","cF","cL","console","warn","dispose","contains","indexOf","getNodeAt","index","c","removeFirst","removeNode","removeLast","prev","a","b","format","addNode","addNodeAfter","addNodeBefore","before","after","replace","replacement","value"],"mappings":"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","file":"System/Collections/LinkedNodeList.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", '../Text/Utility', '../Exceptions/InvalidOperationException', '../Exceptions/ArgumentException', '../Exceptions/ArgumentNullException'], factory);\n    }\n})(function (require, exports) {\n    'use strict';\n    var TextUtility = require('../Text/Utility');\n    var InvalidOperationException_1 = require('../Exceptions/InvalidOperationException');\n    var ArgumentException_1 = require('../Exceptions/ArgumentException');\n    var ArgumentNullException_1 = require('../Exceptions/ArgumentNullException');\n    var LinkedNodeList = (function () {\n        function LinkedNodeList() {\n            this._first = null;\n            this._last = null;\n        }\n        Object.defineProperty(LinkedNodeList.prototype, \"first\", {\n            get: function () {\n                return this._first;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedNodeList.prototype, \"last\", {\n            get: function () {\n                return this._last;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(LinkedNodeList.prototype, \"count\", {\n            get: function () {\n                var next = this._first, i = 0;\n                while (next) {\n                    i++;\n                    next = next.next;\n                }\n                return i;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        LinkedNodeList.prototype.clear = function () {\n            var _ = this, n, cF = 0, cL = 0;\n            n = _._first;\n            _._first = null;\n            while (n) {\n                cF++;\n                n.previous = null;\n                n = n.next;\n            }\n            n = _._last;\n            _._last = null;\n            while (n) {\n                cL++;\n                n.next = null;\n                n = n.previous;\n            }\n            if (cF !== cL)\n                console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing.');\n            return cF;\n        };\n        LinkedNodeList.prototype.dispose = function () {\n            this.clear();\n        };\n        LinkedNodeList.prototype.contains = function (node) {\n            return this.indexOf(node) != -1;\n        };\n        LinkedNodeList.prototype.getNodeAt = function (index) {\n            if (index < 0)\n                return null;\n            var next = this._first, i = 0;\n            while (next && index < i++) {\n                next = next.next;\n            }\n            return next;\n        };\n        LinkedNodeList.prototype.indexOf = function (node) {\n            if (node != null && (node.previous || node.next)) {\n                var index = 0;\n                var c = this._first;\n                while (c) {\n                    if (c === node)\n                        return index;\n                    index++;\n                    c = c.next;\n                }\n            }\n            return -1;\n        };\n        LinkedNodeList.prototype.removeFirst = function () {\n            return this.removeNode(this._first);\n        };\n        LinkedNodeList.prototype.removeLast = function () {\n            return this.removeNode(this._last);\n        };\n        LinkedNodeList.prototype.removeNode = function (node) {\n            if (node == null)\n                throw new ArgumentNullException_1.default('node');\n            var _ = this;\n            var prev = node.previous, next = node.next, a = false, b = false;\n            if (prev)\n                prev.next = next;\n            else if (_._first == node)\n                _._first = next;\n            else\n                a = true;\n            if (next)\n                next.previous = prev;\n            else if (_._last == node)\n                _._last = prev;\n            else\n                b = true;\n            if (a !== b) {\n                throw new ArgumentException_1.default('node', TextUtility.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\n            }\n            return !a && !b;\n        };\n        LinkedNodeList.prototype.addNode = function (node) {\n            this.addNodeAfter(node);\n        };\n        LinkedNodeList.prototype.addNodeBefore = function (node, before) {\n            assertValidDetached(node);\n            var _ = this;\n            if (!before) {\n                before = _._first;\n            }\n            if (before) {\n                node.previous = before.previous;\n                node.next = before;\n                before.previous = node;\n                if (before == _._first)\n                    _._last = node;\n            }\n            else {\n                _._first = _._last = node;\n            }\n        };\n        LinkedNodeList.prototype.addNodeAfter = function (node, after) {\n            assertValidDetached(node);\n            var _ = this;\n            if (!after) {\n                after = _._last;\n            }\n            if (after) {\n                node.next = after.next;\n                node.previous = after;\n                after.next = node;\n                if (after == _._last)\n                    _._last = node;\n            }\n            else {\n                _._first = _._last = node;\n            }\n        };\n        LinkedNodeList.prototype.replace = function (node, replacement) {\n            if (node == null)\n                throw new ArgumentNullException_1.default('node');\n            assertValidDetached(replacement, 'replacement');\n            var _ = this;\n            replacement.previous = node.previous;\n            replacement.next = node.next;\n            if (node.previous)\n                node.previous.next = replacement;\n            if (node.next)\n                node.next.previous = replacement;\n            if (node == _._first)\n                _._first = replacement;\n            if (node == _._last)\n                _._last = replacement;\n        };\n        return LinkedNodeList;\n    }());\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = LinkedNodeList;\n    function assertValidDetached(node, propName) {\n        if (propName === void 0) { propName = 'node'; }\n        if (node == null)\n            throw new ArgumentNullException_1.default(propName);\n        if (node.next || node.previous)\n            throw new InvalidOperationException_1.default(\"Cannot add a node to a LinkedNodeList that is already linked.\");\n    }\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"ILinkedListNode.d.ts\"/>\r\n'use strict'; // For compatibility with (let, const, function, class);\r\n\r\nimport * as TextUtility from '../Text/Utility';\r\n\r\nimport InvalidOperationException from '../Exceptions/InvalidOperationException';\r\n\r\nimport ArgumentException from '../Exceptions/ArgumentException';\r\nimport ArgumentNullException from '../Exceptions/ArgumentNullException';\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport default\r\nclass LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode;\r\n\tprivate _last:TNode;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t * @returns {TNode}\r\n\t */\r\n\tget first():TNode\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t * @returns {TNode}\r\n\t */\r\n\tget last():TNode\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number {\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, n:TNode, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n) {\r\n\t\t\tcF++;\r\n\t\t\tn.previous = null;\r\n\t\t\tn = n.next;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n) {\r\n\t\t\tcL++;\r\n\t\t\tn.next = null;\r\n\t\t\tn = n.previous;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing.');\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!=-1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t * @returns {TNode}\r\n\t */\r\n\tgetNodeAt(index:number):TNode\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && index<i++)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number {\r\n\t\tif(node!=null && (node.previous || node.next)) {\r\n\r\n\t\t\tvar index = 0;\r\n\t\t\tvar c = this._first;\r\n\t\t\twhile(c) {\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t\tc = c.next;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tvar _ = this;\r\n\t\tvar prev = node.previous, next = node.next, a:boolean = false, b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn !a && !b;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t */\r\n\taddNode(node:TNode):void {\r\n\t\tthis.addNodeAfter(node);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t */\r\n\taddNodeBefore(node:TNode, before?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!before) {\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before) {\r\n\t\t\tnode.previous = before.previous;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(before==_._first) _._last = node;\r\n\t\t} else {\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t */\r\n\taddNodeAfter(node:TNode, after?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!after) {\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after) {\r\n\t\t\tnode.next = after.next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t} else {\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):void {\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tassertValidDetached(replacement,'replacement');\r\n\r\n\t\tvar _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(node:TNode, propName:string = 'node') {\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}"]}