{"version":3,"sources":["System/Collections/Array/Compare.js","System/Collections/Array/Compare.ts"],"names":["deps","factory","module","exports","v","require","undefined","define","amd","validateSize","a","b","areAllEqual","arrays","strict","equalityComparer","areEqual","copyAndSort","comparer","areEquivalent","Values","Types_1"],"mappings":";;;;CAIA,SAAWA,EAAMC,GACb,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,OAAOP,EAAMC,KAEjB,UAAW,UAAW,gBAAiB,eAAgB,SAAUI,EAASF,GCE9E,QAAAM,GAAsBC,EAAeC,GAGpCF,GAAGA,GAAKA,GAAKA,IAAIA,IAAMA,IAAMA,EAC5BA,OAAOA,CAGRA,KAAIA,IAAMA,EACTA,OAAOA,CAERA,IAAIA,GAAMA,EAAEA,MACZA,OAAGA,KAAMA,EAAEA,QACHA,EAGCA,IAANA,GACKA,EAGDA,EAGR,QAAAG,GACCC,EACAC,EACAC,GAEAH,GAFAA,SAAAA,IAAAA,EAA2CA,EAAOA,WAE9CA,EACHA,KAAMA,IAAIA,OAAMA,kDACjBA,IAAGA,EAAOA,OAAOA,EAChBA,KAAMA,IAAIA,OAAMA,8CAEjBA,KAAIA,GADAA,GAAQA,EAAOA,GACXA,EAAIA,EAAGA,EAAIA,EAAOA,OAAUA,EAAFA,IAAOA,EAExCA,IAAIA,EAASA,EAAOA,EAAOA,GAAIA,EAAQA,GACtCA,OAAOA,CAETA,QAAOA,EAGR,QAAAI,GACCN,EAAaC,EACbG,EACAC,GAAAC,SAAAA,IAAAA,EAAyCA,EAAOA,SAEhDA,IAAIA,GAAMA,EAAaA,EAAGA,EAC1BA,IAAGA,EAAAA,WAAKA,UAAUA,GAAMA,MAAgBA,EAExCA,KAAIA,GAAIA,GAAIA,EAAKA,EAAFA,IAASA,EAEvBA,IAAIA,EAAiBA,EAAEA,GAAIA,EAAEA,GAAIA,GAChCA,OAAOA,CAGTA,QAAOA,EAIR,QAAAC,GAAwBP,EAAaQ,GAEpCD,IAAIA,EAAGA,MAAOA,KACdA,IAAGA,YAAaA,OAAOA,MAAkBA,GAAGA,OAC5CA,IAAoBA,GAAhBA,EAAMA,EAAEA,MACTA,GAAIA,MAAOA,EAAIA,GAAIA,OAAMA,IAG3BA,KACAA,EAAEA,OAASA,EAEZA,KAAIA,GAAIA,GAAIA,EAAKA,EAAFA,EAAOA,IAAKA,EAAEA,GAAKA,EAAEA,EAEpCA,OADAA,GAAEA,KAAKA,GACAA,EAGR,QAAAE,GACCT,EAAaC,EACbO,GAAAC,SAAAA,IAAAA,EAAyBA,EAAOA,QAEhCA,IAAIA,GAAMA,EAAaA,EAAGA,EAC1BA,IAAGA,EAAAA,WAAKA,UAAUA,GAAMA,MAAgBA,EAIxCA,GAAIA,EAAYA,EAAGA,GACnBA,EAAIA,EAAYA,EAAGA,EAEnBA,KAAIA,GAAIA,GAAIA,EAAKA,EAAFA,IAASA,EAEvBA,GAA0BA,IAAvBA,EAASA,EAAEA,GAAIA,EAAEA,IACnBA,OAAOA,CAGTA,QAAOA,EAlGR,GAAYC,GAAMf,EAAM,iBACxBgB,EAAAhB,EAAiB,cA2BDF,GAAAS,YAAWA,EAkBXT,EAAAa,SAAQA,EAkCRb,EAAAgB,cAAaA","file":"System/Collections/Array/Compare.js","sourcesContent":["/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n(function (deps, factory) {\r\n    if (typeof module === 'object' && typeof module.exports === 'object') {\r\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === 'function' && define.amd) {\r\n        define(deps, factory);\r\n    }\r\n})([\"require\", \"exports\", '../../Compare', '../../Types'], function (require, exports) {\r\n    ///<reference path=\"IArray.d.ts\"/>\r\n    ///<reference path=\"../../FunctionTypes.d.ts\"/>\r\n    var Values = require('../../Compare');\r\n    var Types_1 = require('../../Types');\r\n    function validateSize(a, b) {\r\n        if (a && b && a === b || !a && !b)\r\n            return true;\r\n        if (!a || !b)\r\n            return false;\r\n        var len = a.length;\r\n        if (len !== b.length)\r\n            return false;\r\n        if (len === 0)\r\n            return true;\r\n        return len;\r\n    }\r\n    function areAllEqual(arrays, strict, equalityComparer) {\r\n        if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\r\n        if (!arrays)\r\n            throw new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n        if (arrays.length < 2)\r\n            throw new Error(\"Cannot compare a set of arrays less than 2.\");\r\n        var first = arrays[0];\r\n        for (var i = 0, l = arrays.length; i < l; ++i) {\r\n            if (!areEqual(first, arrays[i], strict, equalityComparer))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports.areAllEqual = areAllEqual;\r\n    function areEqual(a, b, strict, equalityComparer) {\r\n        if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\r\n        var len = validateSize(a, b);\r\n        if (Types_1.default.isBoolean(len))\r\n            return len;\r\n        for (var i = 0; i < len; ++i) {\r\n            if (!equalityComparer(a[i], b[i], strict))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports.areEqual = areEqual;\r\n    function copyAndSort(a, comparer) {\r\n        if (!a)\r\n            return null;\r\n        if (a instanceof Array)\r\n            return a.slice();\r\n        var len = a.length, b;\r\n        if (len > 65536)\r\n            b = new Array(len);\r\n        else {\r\n            b = [];\r\n            b.length = len;\r\n        }\r\n        for (var i = 0; i < len; i++)\r\n            b[i] = a[i];\r\n        b.sort(comparer);\r\n        return b;\r\n    }\r\n    function areEquivalent(a, b, comparer) {\r\n        if (comparer === void 0) { comparer = Values.compare; }\r\n        var len = validateSize(a, b);\r\n        if (Types_1.default.isBoolean(len))\r\n            return len;\r\n        a = copyAndSort(a, comparer);\r\n        b = copyAndSort(b, comparer);\r\n        for (var i = 0; i < len; ++i) {\r\n            if (comparer(a[i], b[i]) !== 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    exports.areEquivalent = areEquivalent;\r\n});\r\n//# sourceMappingURL=Compare.js.map","/*\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n///<reference path=\"IArray.d.ts\"/>\r\n///<reference path=\"../../FunctionTypes.d.ts\"/>\r\nimport * as Values from '../../Compare';\r\nimport Type from '../../Types';\r\n\r\n/*  validateSize: Utility for quick validation/invalidation of array equality.\r\n\tWhy this way?  Why not pass a closure for the last return?\r\n\tReason: Performance and avoiding the creation of new functions/closures. */\r\nfunction validateSize(a:IArray<any>, b:IArray<any>):any\r\n{\r\n\t// Both valid and are same object, or both are null/undefined.\r\n\tif(a && b && a===b || !a && !b)\r\n\t\treturn true;\r\n\r\n\t// At this point, at least one has to be non-null.\r\n\tif(!a || !b)\r\n\t\treturn false;\r\n\r\n\tvar len = a.length;\r\n\tif(len!==b.length)\r\n\t\treturn false;\r\n\r\n\t// If both are arrays and have zero length, they are equal.\r\n\tif(len===0)\r\n\t\treturn true;\r\n\r\n\t// Return the length for downstream processing.\r\n\treturn len;\r\n}\r\n\r\nexport function areAllEqual(\r\n\tarrays:any[][],\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<any> = Values.areEqual):boolean\r\n{\r\n\tif(!arrays)\r\n\t\tthrow new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n\tif(arrays.length<2)\r\n\t\tthrow new Error(\"Cannot compare a set of arrays less than 2.\");\r\n\tvar first = arrays[0];\r\n\tfor(let i = 0, l = arrays.length; i<l; ++i)\r\n\t{\r\n\t\tif(!areEqual(first, arrays[i], strict, equalityComparer))\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nexport function areEqual<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\tfor(let i = 0; i<len; ++i)\r\n\t{\r\n\t\tif(!equalityComparer(a[i], b[i], strict))\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction copyAndSort<T>(a:IArray<T>, comparer:Comparison<T>):T[]\r\n{\r\n\tif(!a) return null;\r\n\tif(a instanceof Array) return (<Array<T>>a).slice();\r\n\tvar len = a.length, b:T[];\r\n\tif(len>65536) b = new Array(len);\r\n\telse\r\n\t{\r\n\t\tb = [];\r\n\t\tb.length = len;\r\n\t}\r\n\tfor(let i = 0; i<len; i++) b[i] = a[i];\r\n\tb.sort(comparer);\r\n\treturn b;\r\n}\r\n\r\nexport function areEquivalent<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tcomparer:Comparison<T> = Values.compare):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\t// There might be a better more performant way to do this, but for the moment, this\r\n\t// works quite well.\r\n\ta = copyAndSort(a, comparer);\r\n\tb = copyAndSort(b, comparer);\r\n\r\n\tfor(let i = 0; i<len; ++i)\r\n\t{\r\n\t\tif(comparer(a[i], b[i])!==0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n"]}