{"version":3,"sources":["System/Collections/Array/Sorting/mergeSort.js","System/Collections/Array/Sorting/mergeSort.ts"],"names":["dependencies","factory","module","exports","v","require","undefined","define","amd","mergeSort","target","ArgumentNullException_1","ArgumentNullException","len","length","sort","Utility_1","initialize","start","end","temp","middle","Math","floor","i_1","k","i","j"],"mappings":"CAAA,SAAWA,EAAcC,GACrB,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,OAAOP,EAAcC,KAEzB,UAAW,UAAW,4CAA6C,cAAe,SAAUI,EAASF,GACrG,YCQJ,SAAAM,GAA+CC,GAE9C,IAAIA,EAAQ,KAAM,IAAIC,GAAAC,sBAAsB,SAC5C,IAAMC,GAAMH,EAAOI,MACnB,OAAOD,GAAI,EAAIH,EAASK,EAAKL,EAAQ,EAAGG,EAAKG,EAAAC,WAAcJ,IAG5D,QAAAE,GACCL,EACAQ,EACAC,EACAC,GAEA,GAAGD,EAAMD,EAAM,EACf,CAEC,GAAMG,GAASC,KAAKC,OAAOL,EAAQC,GAAK,EACxCJ,GAAKL,EAAQQ,EAAOG,EAAQD,GAC5BL,EAAKL,EAAQW,EAAQF,EAAKC,EAG1B,KAAI,GAAII,GAAI,EAAGX,EAAMH,EAAOI,OAAQU,EAAEX,EAAKW,IAE1CJ,EAAKI,GAAKd,EAAOc,EAOlB,KAHA,GAAIC,GAAIP,EAAOQ,EAAIR,EAAOS,EAAIN,EAGxBK,EAAEL,GAAUM,EAAER,GAEnBT,EAAOe,KACJL,EAAKM,GAAGN,EAAKO,GACbP,EAAKO,KACLP,EAAKM,IAIT,MAAMA,EAAEL,GAEPX,EAAOe,KAAOL,EAAKM,KAKrB,MAAOhB,GAvDR,GAAAC,GAAAN,EAAA,6CACAW,EAAAX,EAAA,aAQAF,GAAAM,UAAAA","file":"mergeSort.js","sourcesContent":["(function (dependencies, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(dependencies, factory);\n    }\n})([\"require\", \"exports\", \"../../../Exceptions/ArgumentNullException\", \"../Utility\"], function (require, exports) {\n    \"use strict\";\n    var ArgumentNullException_1 = require(\"../../../Exceptions/ArgumentNullException\");\n    var Utility_1 = require(\"../Utility\");\n    function mergeSort(target) {\n        if (!target)\n            throw new ArgumentNullException_1.ArgumentNullException(\"target\");\n        var len = target.length;\n        return len < 2 ? target : sort(target, 0, len, Utility_1.initialize(len));\n    }\n    exports.mergeSort = mergeSort;\n    function sort(target, start, end, temp) {\n        if (end - start > 1) {\n            var middle = Math.floor((start + end) / 2);\n            sort(target, start, middle, temp);\n            sort(target, middle, end, temp);\n            for (var i_1 = 0, len = target.length; i_1 < len; i_1++) {\n                temp[i_1] = target[i_1];\n            }\n            var k = start, i = start, j = middle;\n            while (i < middle && j < end) {\n                target[k++]\n                    = temp[i] > temp[j]\n                        ? temp[j++]\n                        : temp[i++];\n            }\n            while (i < middle) {\n                target[k++] = temp[i++];\n            }\n        }\n        return target;\n    }\n});\n","/*!\r\n * @author Sebastian Belmar / https://github.com/sebabelmar/\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * https://en.wikipedia.org/wiki/Merge_sort\r\n */\r\nimport {Primitive} from \"../../../Primitive\";\r\nimport {ArgumentNullException} from \"../../../Exceptions/ArgumentNullException\";\r\nimport {initialize} from \"../Utility\";\r\n\r\n/**\r\n * Merge sort O(n log (n))\r\n * Warning: Uses recursion.\r\n * @param target\r\n * @returns {number[]}\r\n */\r\nexport function mergeSort<T extends Primitive>(target:T[]):T[]\r\n{\r\n\tif(!target) throw new ArgumentNullException(\"target\");\r\n\tconst len = target.length;\r\n\treturn len<2 ? target : sort(target, 0, len, initialize<T>(len));\r\n}\r\n\r\nfunction sort<T extends Primitive>(\r\n\ttarget:T[],\r\n\tstart:number,\r\n\tend:number,\r\n\ttemp:T[]):T[]\r\n{\r\n\tif(end - start>1)\r\n\t{\r\n\t\t// Step 1: Sort the left and right parts.\r\n\t\tconst middle = Math.floor((start + end)/2);\r\n\t\tsort(target, start, middle, temp);\r\n\t\tsort(target, middle, end, temp);\r\n\r\n\t\t// Step 2: Copy the original array\r\n\t\tfor(let i = 0, len = target.length; i<len; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = target[i];\r\n\t\t}\r\n\r\n\t\t// Step 3: Create variables to traverse\r\n\t\tlet k = start, i = start, j = middle;\r\n\r\n\t\t// Step 4: Merge: Move from the temp to target integers in order\r\n\t\twhile(i<middle && j<end)\r\n\t\t{\r\n\t\t\ttarget[k++]\r\n\t\t\t\t= temp[i]>temp[j]\r\n\t\t\t\t? temp[j++]\r\n\t\t\t\t: temp[i++];\r\n\t\t}\r\n\r\n\t\t// Step 5: Finalize merging in case right side of the array is bigger.\r\n\t\twhile(i<middle)\r\n\t\t{\r\n\t\t\ttarget[k++] = temp[i++];\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn target\r\n}\r\n"]}