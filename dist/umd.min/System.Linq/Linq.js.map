{"version":3,"sources":["System.Linq/Linq.js","System.Linq/Linq.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","getEmptyEnumerator","EmptyEnumerator_1","EmptyEnumerator","nextEnumerator","queue","e","moveNext","dispose_1","dispose","enqueue","createSortContext","orderedEnumerable","currentContext","context","KeySortedContext_1","KeySortedContext","keySelector","order","comparer","parent","throwIfDisposed","disposed","ObjectDisposedException_1","ObjectDisposedException","Values","Arrays","ArrayUtility","Enumerator_1","Types_1","Integer_1","Functions_1","ArrayEnumerator_1","EnumeratorBase_1","Dictionary_1","Queue_1","DisposableBase_1","UnsupportedEnumerableException_1","ArgumentNullException_1","ArgumentOutOfRangeException_1","extends_1","__extends","INVALID_DEFAULT","VOID0","NULL","BREAK","element","LinqFunctions","_super","apply","this","arguments","prototype","Greater","a","b","Lesser","Functions","Object","freeze","InfiniteEnumerable","_enumeratorFactory","finalizer","call","_isEndless","defineProperty","get","enumerable","configurable","getEnumerator","_onDispose","asEnumerable","_","doAction","action","initializer","isEndless","isE","Enumerable","enumerator","index","EnumeratorBase","yielder","actionResult","current","yieldBreak","yieldReturn","force","skip","count","isFinite","Integer","assert","take","empty","ArgumentOutOfRangeException","elementAt","elementAtOrDefault","defaultValue","assertZeroOrGreater","n","using","i","first","firstOrDefault","Error","single","value","singleOrDefault","any","isEmpty","traverseBreadthFirst","childrenSelector","resultSelector","Identity","buffer","len","nestLevel","next","from","selectMany","length","traverseDepthFirst","enumeratorStack","fromAny","these","flatten","middleEnumerator","c","Type","isString","pairwise","selector","prev","scan","func","seed","isUseSeed","isFirst","select","_selectMany","collectionSelector","middleSeq","_choose","result","choose","where","predicate","ofType","type","typeName","Number","NUMBER","String","STRING","Boolean","BOOLEAN","Function","FUNCTION","x","except","second","compareSelector","keys","Dictionary","forEach","key","addByKeyValue","containsKey","clear","distinct","distinctUntilChanged","compareKey","initial","areEqual","defaultIfEmpty","zip","firstEnumerator","secondEnumerator","zipMultiple","secondTemp","Queue","dequeue","join","inner","outerKeySelector","innerKeySelector","outerEnumerator","lookup","innerElements","innerCount","toLookup","innerElement","groupJoin","merge","enumerables","concat","_i","union","insertAt","other","isEnumerated","alternateMultiple","sequence","mode","alternateEnumerator","ArrayEnumerator","toArray","hasAtLeastOne","reset","latest","another","alternateSingle","make","alternate","catchError","handler","finallyAction","size","array","initialize","share","sharedEnumerator","DisposableBase","enumeratorFactory","source","UnsupportedEnumerableException","defaultEnumerable","isObject","isArrayLike","ArrayEnumerable","isEnumerable","fromOrEmpty","choice","values","random","chooseFrom","args","cycle","cycleThrough","FiniteEnumerable","repeat","Infinity","repeatWithFinalize","range","start","step","rangeDown","Math","abs","toInfinity","toNegativeInfinity","rangeTo","to","isNaN","matches","input","pattern","flags","ArgumentNullException","RegExp","indexOf","regex","match","exec","generate","unfold","valueFactory","skipSeed","max","map","takeUntil","aggregate","NaN","min","weave","mainEnumerator","dump","skipWhile","takeWhile","includeUntilValue","found","throwIfEndless","copyTo","target","elementSelector","dict","getValue","push","Lookup","toMap","obj","toDictionary","toJoinedString","separator","takeExceptLast","q","skipToLast","reverse","shuffle","capacity","selectedIndex","selectedValue","all","every","some","contains","lastIndexOf","intersect","outs","sequenceEqual","equalityComparer","e1","e2","orderBy","OrderedEnumerable","orderUsing","comparison","orderUsingReversed","orderByDescending","groupBy","_this","partitionBy","elements","Grouping","group","hasNext","lastOrDefault","average","numberOrNaN","sum","maxBy","minBy","sumInfinite","product","exists","quotient","last","memoize","cache","_source","_disposableObjectName","s","Array","isArray","_groupKey","_dictionary","compare","createOrderedEnumerable","thenBy","thenUsing","thenByDescending","thenUsingReversed","indexes","generateSortedIndexes"],"mappings":"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","file":"Linq.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Original: http://linqjs.codeplex.com/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../System/Compare\", \"../System/Collections/Array/Compare\", \"../System/Collections/Array/Utility\", \"../System/Collections/Enumeration/Enumerator\", \"../System/Collections/Enumeration/EmptyEnumerator\", \"../System/Types\", \"../System/Integer\", \"../System/Functions\", \"../System/Collections/Enumeration/ArrayEnumerator\", \"../System/Collections/Enumeration/EnumeratorBase\", \"../System/Collections/Dictionaries/Dictionary\", \"../System/Collections/Queue\", \"../System/Disposable/dispose\", \"../System/Disposable/DisposableBase\", \"../System/Collections/Enumeration/UnsupportedEnumerableException\", \"../System/Disposable/ObjectDisposedException\", \"../System/Collections/Sorting/KeySortedContext\", \"../System/Exceptions/ArgumentNullException\", \"../System/Exceptions/ArgumentOutOfRangeException\", \"../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Values = require(\"../System/Compare\");\n    var Arrays = require(\"../System/Collections/Array/Compare\");\n    var ArrayUtility = require(\"../System/Collections/Array/Utility\");\n    var Enumerator_1 = require(\"../System/Collections/Enumeration/Enumerator\");\n    var EmptyEnumerator_1 = require(\"../System/Collections/Enumeration/EmptyEnumerator\");\n    var Types_1 = require(\"../System/Types\");\n    var Integer_1 = require(\"../System/Integer\");\n    var Functions_1 = require(\"../System/Functions\");\n    var ArrayEnumerator_1 = require(\"../System/Collections/Enumeration/ArrayEnumerator\");\n    var EnumeratorBase_1 = require(\"../System/Collections/Enumeration/EnumeratorBase\");\n    var Dictionary_1 = require(\"../System/Collections/Dictionaries/Dictionary\");\n    var Queue_1 = require(\"../System/Collections/Queue\");\n    var dispose_1 = require(\"../System/Disposable/dispose\");\n    var DisposableBase_1 = require(\"../System/Disposable/DisposableBase\");\n    var UnsupportedEnumerableException_1 = require(\"../System/Collections/Enumeration/UnsupportedEnumerableException\");\n    var ObjectDisposedException_1 = require(\"../System/Disposable/ObjectDisposedException\");\n    var KeySortedContext_1 = require(\"../System/Collections/Sorting/KeySortedContext\");\n    var ArgumentNullException_1 = require(\"../System/Exceptions/ArgumentNullException\");\n    var ArgumentOutOfRangeException_1 = require(\"../System/Exceptions/ArgumentOutOfRangeException\");\n    var extends_1 = require(\"../extends\");\n    var __extends = extends_1.default;\n    var INVALID_DEFAULT = {};\n    var VOID0 = void 0;\n    var NULL = null;\n    var BREAK = function (element) { return 0; };\n    var LinqFunctions = (function (_super) {\n        __extends(LinqFunctions, _super);\n        function LinqFunctions() {\n            _super.apply(this, arguments);\n        }\n        LinqFunctions.prototype.Greater = function (a, b) {\n            return a > b ? a : b;\n        };\n        LinqFunctions.prototype.Lesser = function (a, b) {\n            return a < b ? a : b;\n        };\n        return LinqFunctions;\n    }(Functions_1.Functions));\n    var Functions = new LinqFunctions();\n    Object.freeze(Functions);\n    function getEmptyEnumerator() {\n        return EmptyEnumerator_1.EmptyEnumerator;\n    }\n    var InfiniteEnumerable = (function (_super) {\n        __extends(InfiniteEnumerable, _super);\n        function InfiniteEnumerable(_enumeratorFactory, finalizer) {\n            _super.call(this, finalizer);\n            this._enumeratorFactory = _enumeratorFactory;\n            this._isEndless = true;\n        }\n        Object.defineProperty(InfiniteEnumerable.prototype, \"isEndless\", {\n            get: function () {\n                return this._isEndless;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        InfiniteEnumerable.prototype.getEnumerator = function () {\n            this.throwIfDisposed();\n            return this._enumeratorFactory();\n        };\n        InfiniteEnumerable.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._enumeratorFactory = null;\n        };\n        InfiniteEnumerable.prototype.asEnumerable = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return new InfiniteEnumerable(function () { return _.getEnumerator(); });\n        };\n        InfiniteEnumerable.prototype.doAction = function (action, initializer, isEndless) {\n            if (isEndless === void 0) { isEndless = this.isEndless; }\n            var _ = this;\n            var isE = isEndless || undefined;\n            var disposed = !_.throwIfDisposed();\n            return new Enumerable(function () {\n                var enumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    if (initializer)\n                        initializer();\n                    index = 0;\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var actionResult = action(enumerator.current, index++);\n                        if (actionResult === false || actionResult === 0)\n                            return yielder.yieldBreak();\n                        if (actionResult !== 2)\n                            return yielder.yieldReturn(enumerator.current);\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, isE);\n            }, function () {\n                disposed = true;\n            }, isE);\n        };\n        InfiniteEnumerable.prototype.force = function () {\n            this.throwIfDisposed();\n            this.doAction(BREAK)\n                .getEnumerator()\n                .moveNext();\n        };\n        InfiniteEnumerable.prototype.skip = function (count) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!isFinite(count))\n                return new InfiniteEnumerable(getEmptyEnumerator);\n            Integer_1.Integer.assert(count, \"count\");\n            return this.doAction(function (element, index) {\n                return index < count\n                    ? 2\n                    : 1;\n            });\n        };\n        InfiniteEnumerable.prototype.take = function (count) {\n            if (!(count > 0))\n                return Enumerable.empty();\n            var _ = this;\n            _.throwIfDisposed();\n            if (!isFinite(count))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('count', count, 'Must be finite.');\n            Integer_1.Integer.assert(count, \"count\");\n            return _.doAction(function (element, index) { return index < count; }, null, false);\n        };\n        InfiniteEnumerable.prototype.elementAt = function (index) {\n            var v = this.elementAtOrDefault(index, INVALID_DEFAULT);\n            if (v === INVALID_DEFAULT)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('index', index, \"is greater than or equal to the number of elements in source\");\n            return v;\n        };\n        InfiniteEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            Integer_1.Integer.assertZeroOrGreater(index, 'index');\n            var n = index;\n            return dispose_1.using(this.getEnumerator(), function (e) {\n                var i = 0;\n                while (e.moveNext()) {\n                    if (i == n)\n                        return e.current;\n                    i++;\n                }\n                return defaultValue;\n            });\n        };\n        InfiniteEnumerable.prototype.first = function () {\n            var v = this.firstOrDefault(INVALID_DEFAULT);\n            if (v === INVALID_DEFAULT)\n                throw new Error(\"first:The sequence is empty.\");\n            return v;\n        };\n        InfiniteEnumerable.prototype.firstOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) { return e.moveNext() ? e.current : defaultValue; });\n        };\n        InfiniteEnumerable.prototype.single = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) {\n                if (e.moveNext()) {\n                    var value = e.current;\n                    if (!e.moveNext())\n                        return value;\n                    throw new Error(\"single:sequence contains more than one element.\");\n                }\n                throw new Error(\"single:The sequence is empty.\");\n            });\n        };\n        InfiniteEnumerable.prototype.singleOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) {\n                if (e.moveNext()) {\n                    var value = e.current;\n                    if (!e.moveNext())\n                        return value;\n                }\n                return defaultValue;\n            });\n        };\n        InfiniteEnumerable.prototype.any = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) { return e.moveNext(); });\n        };\n        InfiniteEnumerable.prototype.isEmpty = function () {\n            return !this.any();\n        };\n        InfiniteEnumerable.prototype.traverseBreadthFirst = function (childrenSelector, resultSelector) {\n            if (resultSelector === void 0) { resultSelector = Functions.Identity; }\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var nestLevel = 0;\n                var buffer, len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    nestLevel = 0;\n                    buffer = [];\n                    len = 0;\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    while (true) {\n                        if (enumerator.moveNext()) {\n                            buffer[len++] = enumerator.current;\n                            return yielder.yieldReturn(resultSelector(enumerator.current, nestLevel));\n                        }\n                        if (!len)\n                            return yielder.yieldBreak();\n                        var next = Enumerable\n                            .from(buffer)\n                            .selectMany(childrenSelector);\n                        if (!next.any()) {\n                            return yielder.yieldBreak();\n                        }\n                        else {\n                            nestLevel++;\n                            buffer = [];\n                            len = 0;\n                            enumerator.dispose();\n                            enumerator = next.getEnumerator();\n                        }\n                    }\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                    buffer.length = 0;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.traverseDepthFirst = function (childrenSelector, resultSelector) {\n            if (resultSelector === void 0) { resultSelector = Functions.Identity; }\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumeratorStack = [];\n                var enumerator;\n                var len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    len = 0;\n                }, function (yielder) {\n                    while (true) {\n                        if (enumerator.moveNext()) {\n                            var value = resultSelector(enumerator.current, len);\n                            enumeratorStack[len++] = enumerator;\n                            var e = Enumerable.fromAny(childrenSelector(enumerator.current));\n                            enumerator = e ? e.getEnumerator() : EmptyEnumerator_1.EmptyEnumerator;\n                            return yielder.yieldReturn(value);\n                        }\n                        if (len == 0)\n                            return false;\n                        enumerator.dispose();\n                        enumerator = enumeratorStack[--len];\n                        enumeratorStack.length = len;\n                    }\n                }, function () {\n                    try {\n                        dispose_1.dispose(enumerator);\n                    }\n                    finally {\n                        dispose_1.dispose.these(enumeratorStack);\n                    }\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.flatten = function () {\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var middleEnumerator = null;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    while (true) {\n                        if (middleEnumerator) {\n                            if (middleEnumerator.moveNext()) {\n                                return yielder.yieldReturn(middleEnumerator.current);\n                            }\n                            else {\n                                middleEnumerator.dispose();\n                                middleEnumerator = null;\n                            }\n                        }\n                        if (enumerator.moveNext()) {\n                            var c = enumerator.current;\n                            var e = !Types_1.Type.isString(c) && Enumerable.fromAny(c);\n                            if (e) {\n                                middleEnumerator = e\n                                    .selectMany(Functions.Identity)\n                                    .flatten()\n                                    .getEnumerator();\n                                continue;\n                            }\n                            else {\n                                return yielder.yieldReturn(c);\n                            }\n                        }\n                        return yielder.yieldBreak();\n                    }\n                }, function () {\n                    dispose_1.dispose(enumerator, middleEnumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.pairwise = function (selector) {\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    enumerator.moveNext();\n                }, function (yielder) {\n                    var prev = enumerator.current;\n                    return enumerator.moveNext()\n                        && yielder.yieldReturn(selector(prev, enumerator.current));\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.scan = function (func, seed) {\n            var _ = this;\n            var isUseSeed = seed !== VOID0;\n            return new Enumerable(function () {\n                var enumerator;\n                var value;\n                var isFirst;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    isFirst = true;\n                }, function (yielder) {\n                    if (isFirst) {\n                        isFirst = false;\n                        return isUseSeed\n                            ? yielder.yieldReturn(value = seed)\n                            : enumerator.moveNext()\n                                && yielder.yieldReturn(value = enumerator.current);\n                    }\n                    return (enumerator.moveNext())\n                        ? yielder.yieldReturn(value = func(value, enumerator.current))\n                        : false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, _._isEndless);\n            }, null, _._isEndless);\n        };\n        InfiniteEnumerable.prototype.select = function (selector) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new Enumerable(function () {\n                var enumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    index = 0;\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    return enumerator.moveNext()\n                        ? yielder.yieldReturn(selector(enumerator.current, index++))\n                        : yielder.yieldBreak();\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, _._isEndless);\n            }, function () {\n                disposed = true;\n            }, _._isEndless);\n        };\n        InfiniteEnumerable.prototype._selectMany = function (collectionSelector, resultSelector) {\n            var _ = this;\n            var isEndless = _._isEndless;\n            if (!resultSelector)\n                resultSelector = function (a, b) { return b; };\n            return new Enumerable(function () {\n                var enumerator;\n                var middleEnumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    middleEnumerator = VOID0;\n                    index = 0;\n                }, function (yielder) {\n                    if (middleEnumerator === VOID0 && !enumerator.moveNext())\n                        return false;\n                    do {\n                        if (!middleEnumerator) {\n                            var middleSeq = collectionSelector(enumerator.current, index++);\n                            if (!middleSeq)\n                                continue;\n                            middleEnumerator = Enumerator_1.from(middleSeq);\n                        }\n                        if (middleEnumerator.moveNext())\n                            return yielder.yieldReturn(resultSelector(enumerator.current, middleEnumerator.current));\n                        middleEnumerator.dispose();\n                        middleEnumerator = null;\n                    } while (enumerator.moveNext());\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator, middleEnumerator);\n                    enumerator = NULL;\n                    middleEnumerator = null;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.selectMany = function (collectionSelector, resultSelector) {\n            return this._selectMany(collectionSelector, resultSelector);\n        };\n        InfiniteEnumerable.prototype._choose = function (selector) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    index = 0;\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var result = selector(enumerator.current, index++);\n                        if (result !== null && result !== VOID0)\n                            return yielder.yieldReturn(result);\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        InfiniteEnumerable.prototype.choose = function (selector) {\n            if (selector === void 0) { selector = Functions.Identity; }\n            return this._choose(selector);\n        };\n        InfiniteEnumerable.prototype.where = function (predicate) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new Enumerable(function () {\n                var enumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    index = 0;\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var v = enumerator.current;\n                        if (predicate(v, index++))\n                            return yielder.yieldReturn(v);\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, _._isEndless);\n            }, function () {\n                disposed = true;\n            }, _._isEndless);\n        };\n        InfiniteEnumerable.prototype.ofType = function (type) {\n            var typeName;\n            switch (type) {\n                case Number:\n                    typeName = Types_1.Type.NUMBER;\n                    break;\n                case String:\n                    typeName = Types_1.Type.STRING;\n                    break;\n                case Boolean:\n                    typeName = Types_1.Type.BOOLEAN;\n                    break;\n                case Function:\n                    typeName = Types_1.Type.FUNCTION;\n                    break;\n                default:\n                    return this\n                        .where(function (x) { return x instanceof type; });\n            }\n            return this\n                .choose()\n                .where(function (x) { return (typeof x) === typeName; });\n        };\n        InfiniteEnumerable.prototype.except = function (second, compareSelector) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var keys;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                    keys = new Dictionary_1.Dictionary(compareSelector);\n                    if (second)\n                        Enumerator_1.forEach(second, function (key) { keys.addByKeyValue(key, true); });\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var current = enumerator.current;\n                        if (!keys.containsKey(current)) {\n                            keys.addByKeyValue(current, true);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                    keys.clear();\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        InfiniteEnumerable.prototype.distinct = function (compareSelector) {\n            return this.except(NULL, compareSelector);\n        };\n        InfiniteEnumerable.prototype.distinctUntilChanged = function (compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var compareKey;\n                var initial = true;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var key = compareSelector(enumerator.current);\n                        if (initial) {\n                            initial = false;\n                        }\n                        else if (Values.areEqual(compareKey, key)) {\n                            continue;\n                        }\n                        compareKey = key;\n                        return yielder.yieldReturn(enumerator.current);\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        InfiniteEnumerable.prototype.defaultIfEmpty = function (defaultValue) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var isFirst;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    isFirst = true;\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    if (enumerator.moveNext()) {\n                        isFirst = false;\n                        return yielder.yieldReturn(enumerator.current);\n                    }\n                    else if (isFirst) {\n                        isFirst = false;\n                        return yielder.yieldReturn(defaultValue);\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.zip = function (second, resultSelector) {\n            var _ = this;\n            _.throwIfDisposed();\n            return new Enumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    firstEnumerator = _.getEnumerator();\n                    secondEnumerator = Enumerator_1.from(second);\n                }, function (yielder) { return firstEnumerator.moveNext()\n                    && secondEnumerator.moveNext()\n                    && yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++)); }, function () {\n                    dispose_1.dispose(firstEnumerator, secondEnumerator);\n                });\n            });\n        };\n        InfiniteEnumerable.prototype.zipMultiple = function (second, resultSelector) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!second.length)\n                return Enumerable.empty();\n            return new Enumerable(function () {\n                var secondTemp;\n                var firstEnumerator;\n                var secondEnumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    secondTemp = new Queue_1.Queue(second);\n                    index = 0;\n                    firstEnumerator = _.getEnumerator();\n                    secondEnumerator = NULL;\n                }, function (yielder) {\n                    if (firstEnumerator.moveNext()) {\n                        while (true) {\n                            while (!secondEnumerator) {\n                                if (secondTemp.count) {\n                                    var next = secondTemp.dequeue();\n                                    if (next)\n                                        secondEnumerator = Enumerator_1.from(next);\n                                }\n                                else\n                                    return yielder.yieldBreak();\n                            }\n                            if (secondEnumerator.moveNext())\n                                return yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++));\n                            secondEnumerator.dispose();\n                            secondEnumerator = NULL;\n                        }\n                    }\n                    return yielder.yieldBreak();\n                }, function () {\n                    dispose_1.dispose(firstEnumerator, secondTemp);\n                });\n            });\n        };\n        InfiniteEnumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            return new Enumerable(function () {\n                var outerEnumerator;\n                var lookup;\n                var innerElements;\n                var innerCount = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    outerEnumerator = _.getEnumerator();\n                    lookup = Enumerable.from(inner)\n                        .toLookup(innerKeySelector, Functions.Identity, compareSelector);\n                }, function (yielder) {\n                    while (true) {\n                        if (innerElements) {\n                            var innerElement = innerElements[innerCount++];\n                            if (innerElement !== VOID0)\n                                return yielder.yieldReturn(resultSelector(outerEnumerator.current, innerElement));\n                            innerElements = null;\n                            innerCount = 0;\n                        }\n                        if (outerEnumerator.moveNext()) {\n                            var key = outerKeySelector(outerEnumerator.current);\n                            innerElements = lookup.get(key);\n                        }\n                        else {\n                            return yielder.yieldBreak();\n                        }\n                    }\n                }, function () {\n                    dispose_1.dispose(outerEnumerator);\n                    innerElements = null;\n                    outerEnumerator = NULL;\n                    lookup = NULL;\n                });\n            });\n        };\n        InfiniteEnumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            return new Enumerable(function () {\n                var enumerator;\n                var lookup;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    lookup = Enumerable.from(inner)\n                        .toLookup(innerKeySelector, Functions.Identity, compareSelector);\n                }, function (yielder) {\n                    return enumerator.moveNext()\n                        && yielder.yieldReturn(resultSelector(enumerator.current, lookup.get(outerKeySelector(enumerator.current))));\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                    enumerator = NULL;\n                    lookup = NULL;\n                });\n            });\n        };\n        InfiniteEnumerable.prototype.merge = function (enumerables) {\n            var _ = this;\n            var isEndless = _._isEndless;\n            if (!enumerables || enumerables.length == 0)\n                return _;\n            return new Enumerable(function () {\n                var enumerator;\n                var queue;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    queue = new Queue_1.Queue(enumerables);\n                }, function (yielder) {\n                    while (true) {\n                        while (!enumerator && queue.count) {\n                            enumerator = Enumerator_1.from(queue.dequeue());\n                        }\n                        if (enumerator && enumerator.moveNext())\n                            return yielder.yieldReturn(enumerator.current);\n                        if (enumerator) {\n                            enumerator.dispose();\n                            enumerator = NULL;\n                            continue;\n                        }\n                        return yielder.yieldBreak();\n                    }\n                }, function () {\n                    dispose_1.dispose(enumerator, queue);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.concat = function () {\n            var enumerables = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                enumerables[_i - 0] = arguments[_i];\n            }\n            return this.merge(enumerables);\n        };\n        InfiniteEnumerable.prototype.union = function (second, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var keys;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    firstEnumerator = _.getEnumerator();\n                    keys = new Dictionary_1.Dictionary(compareSelector);\n                }, function (yielder) {\n                    var current;\n                    if (secondEnumerator === VOID0) {\n                        while (firstEnumerator.moveNext()) {\n                            current = firstEnumerator.current;\n                            if (!keys.containsKey(current)) {\n                                keys.addByKeyValue(current, null);\n                                return yielder.yieldReturn(current);\n                            }\n                        }\n                        secondEnumerator = Enumerator_1.from(second);\n                    }\n                    while (secondEnumerator.moveNext()) {\n                        current = secondEnumerator.current;\n                        if (!keys.containsKey(current)) {\n                            keys.addByKeyValue(current, null);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(firstEnumerator, secondEnumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.insertAt = function (index, other) {\n            Integer_1.Integer.assertZeroOrGreater(index, 'index');\n            var n = index;\n            var _ = this;\n            _.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var count = 0;\n                var isEnumerated = false;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    count = 0;\n                    firstEnumerator = _.getEnumerator();\n                    secondEnumerator = Enumerator_1.from(other);\n                    isEnumerated = false;\n                }, function (yielder) {\n                    if (count == n) {\n                        isEnumerated = true;\n                        if (secondEnumerator.moveNext())\n                            return yielder.yieldReturn(secondEnumerator.current);\n                    }\n                    if (firstEnumerator.moveNext()) {\n                        count++;\n                        return yielder.yieldReturn(firstEnumerator.current);\n                    }\n                    return !isEnumerated\n                        && secondEnumerator.moveNext()\n                        && yielder.yieldReturn(secondEnumerator.current);\n                }, function () {\n                    dispose_1.dispose(firstEnumerator, secondEnumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.alternateMultiple = function (sequence) {\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new Enumerable(function () {\n                var buffer, mode, enumerator, alternateEnumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    alternateEnumerator = new ArrayEnumerator_1.ArrayEnumerator(Enumerable.toArray(sequence));\n                    enumerator = _.getEnumerator();\n                    var hasAtLeastOne = enumerator.moveNext();\n                    mode = hasAtLeastOne\n                        ? 1\n                        : 0;\n                    if (hasAtLeastOne)\n                        buffer = enumerator.current;\n                }, function (yielder) {\n                    switch (mode) {\n                        case 0:\n                            return yielder.yieldBreak();\n                        case 2:\n                            if (alternateEnumerator.moveNext())\n                                return yielder.yieldReturn(alternateEnumerator.current);\n                            alternateEnumerator.reset();\n                            mode = 1;\n                            break;\n                    }\n                    var latest = buffer;\n                    var another = enumerator.moveNext();\n                    mode = another\n                        ? 2\n                        : 0;\n                    if (another)\n                        buffer = enumerator.current;\n                    return yielder.yieldReturn(latest);\n                }, function () {\n                    dispose_1.dispose(enumerator, alternateEnumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.alternateSingle = function (value) {\n            return this.alternateMultiple(Enumerable.make(value));\n        };\n        InfiniteEnumerable.prototype.alternate = function () {\n            var sequence = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                sequence[_i - 0] = arguments[_i];\n            }\n            return this.alternateMultiple(sequence);\n        };\n        InfiniteEnumerable.prototype.catchError = function (handler) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new Enumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    try {\n                        throwIfDisposed(disposed);\n                        enumerator = _.getEnumerator();\n                    }\n                    catch (e) {\n                    }\n                }, function (yielder) {\n                    try {\n                        throwIfDisposed(disposed);\n                        if (enumerator.moveNext())\n                            return yielder.yieldReturn(enumerator.current);\n                    }\n                    catch (e) {\n                        handler(e);\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                });\n            });\n        };\n        InfiniteEnumerable.prototype.finallyAction = function (action) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new Enumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    return (enumerator.moveNext())\n                        ? yielder.yieldReturn(enumerator.current)\n                        : false;\n                }, function () {\n                    try {\n                        dispose_1.dispose(enumerator);\n                    }\n                    finally {\n                        action();\n                    }\n                });\n            });\n        };\n        InfiniteEnumerable.prototype.buffer = function (size) {\n            if (size < 1 || !isFinite(size))\n                throw new Error(\"Invalid buffer size.\");\n            Integer_1.Integer.assert(size, \"size\");\n            var _ = this;\n            var isEndless = _._isEndless;\n            var len;\n            return new Enumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    var array = ArrayUtility.initialize(size);\n                    len = 0;\n                    while (len < size && enumerator.moveNext()) {\n                        array[len++] = enumerator.current;\n                    }\n                    array.length = len;\n                    return !!len && yielder.yieldReturn(array);\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteEnumerable.prototype.share = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var sharedEnumerator;\n            return new Enumerable(function () {\n                return sharedEnumerator || (sharedEnumerator = _.getEnumerator());\n            }, function () {\n                dispose_1.dispose(sharedEnumerator);\n            }, _._isEndless);\n        };\n        return InfiniteEnumerable;\n    }(DisposableBase_1.DisposableBase));\n    exports.InfiniteEnumerable = InfiniteEnumerable;\n    var Enumerable = (function (_super) {\n        __extends(Enumerable, _super);\n        function Enumerable(enumeratorFactory, finalizer, isEndless) {\n            _super.call(this, enumeratorFactory, finalizer);\n            this._isEndless = isEndless;\n        }\n        Enumerable.from = function (source) {\n            var e = Enumerable.fromAny(source);\n            if (!e)\n                throw new UnsupportedEnumerableException_1.UnsupportedEnumerableException();\n            return e;\n        };\n        Enumerable.fromAny = function (source, defaultEnumerable) {\n            if (Types_1.Type.isObject(source) || Types_1.Type.isString(source)) {\n                if (source instanceof Enumerable)\n                    return source;\n                if (Types_1.Type.isArrayLike(source))\n                    return new ArrayEnumerable(source);\n                if (Enumerator_1.isEnumerable(source))\n                    return new Enumerable(function () { return source.getEnumerator(); }, null, source.isEndless);\n            }\n            return defaultEnumerable;\n        };\n        Enumerable.fromOrEmpty = function (source) {\n            return Enumerable.fromAny(source) || Enumerable.empty();\n        };\n        Enumerable.toArray = function (source) {\n            if (source instanceof Enumerable)\n                return source.toArray();\n            return Enumerator_1.toArray(source);\n        };\n        Enumerable.choice = function (values) {\n            var len = values && values.length;\n            if (!len || !isFinite(len))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n            return new InfiniteEnumerable(function () { return new EnumeratorBase_1.EnumeratorBase(null, function (yielder) {\n                return yielder.yieldReturn(Integer_1.Integer.random.select(values));\n            }, true); });\n        };\n        Enumerable.chooseFrom = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return Enumerable.choice(args);\n        };\n        Enumerable.cycle = function (values) {\n            var len = values && values.length;\n            if (!len || !isFinite(len))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n            return new InfiniteEnumerable(function () {\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                }, function (yielder) {\n                    if (index >= values.length)\n                        index = 0;\n                    return yielder.yieldReturn(values[index++]);\n                }, true);\n            });\n        };\n        Enumerable.cycleThrough = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i - 0] = arguments[_i];\n            }\n            return Enumerable.cycle(args);\n        };\n        Enumerable.empty = function () {\n            return new FiniteEnumerable(getEmptyEnumerator);\n        };\n        Enumerable.repeat = function (element, count) {\n            if (count === void 0) { count = Infinity; }\n            if (!(count > 0))\n                return Enumerable.empty();\n            return isFinite(count) && Integer_1.Integer.assert(count, \"count\")\n                ? new FiniteEnumerable(function () {\n                    var c = count;\n                    var index = 0;\n                    return new EnumeratorBase_1.EnumeratorBase(function () { index = 0; }, function (yielder) { return (index++ < c) && yielder.yieldReturn(element); }, null, false);\n                })\n                : new Enumerable(function () {\n                    return new EnumeratorBase_1.EnumeratorBase(null, function (yielder) { return yielder.yieldReturn(element); }, true);\n                });\n        };\n        Enumerable.repeatWithFinalize = function (initializer, finalizer) {\n            return new InfiniteEnumerable(function () {\n                var element;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    element = initializer();\n                }, function (yielder) { return yielder.yieldReturn(element); }, function () {\n                    finalizer(element);\n                }, true);\n            });\n        };\n        Enumerable.make = function (element) {\n            return Enumerable.repeat(element, 1);\n        };\n        Enumerable.range = function (start, count, step) {\n            if (step === void 0) { step = 1; }\n            if (!isFinite(start))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\n            if (!(count > 0))\n                return Enumerable.empty();\n            if (!step)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\n            if (!isFinite(step))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\n            Integer_1.Integer.assert(count, \"count\");\n            return new FiniteEnumerable(function () {\n                var value;\n                var c = count;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    value = start;\n                }, function (yielder) {\n                    var result = index++ < c\n                        && yielder.yieldReturn(value);\n                    if (result && index < count)\n                        value += step;\n                    return result;\n                }, false);\n            });\n        };\n        Enumerable.rangeDown = function (start, count, step) {\n            if (step === void 0) { step = 1; }\n            step = Math.abs(step) * -1;\n            return Enumerable.range(start, count, step);\n        };\n        Enumerable.toInfinity = function (start, step) {\n            if (start === void 0) { start = 0; }\n            if (step === void 0) { step = 1; }\n            if (!isFinite(start))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\n            if (!step)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\n            if (!isFinite(step))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\n            return new InfiniteEnumerable(function () {\n                var value;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    value = start;\n                }, function (yielder) {\n                    var current = value;\n                    value += step;\n                    return yielder.yieldReturn(current);\n                }, true);\n            });\n        };\n        Enumerable.toNegativeInfinity = function (start, step) {\n            if (start === void 0) { start = 0; }\n            if (step === void 0) { step = 1; }\n            return Enumerable.toInfinity(start, -step);\n        };\n        Enumerable.rangeTo = function (start, to, step) {\n            if (step === void 0) { step = 1; }\n            if (isNaN(to) || !isFinite(to))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"to\", to, \"Must be a finite number.\");\n            if (step && !isFinite(step))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite non-zero number.\");\n            step = Math.abs(step);\n            return new FiniteEnumerable(function () {\n                var value;\n                return new EnumeratorBase_1.EnumeratorBase(function () { value = start; }, start < to\n                    ?\n                        function (yielder) {\n                            var result = value <= to && yielder.yieldReturn(value);\n                            if (result)\n                                value += step;\n                            return result;\n                        }\n                    :\n                        function (yielder) {\n                            var result = value >= to && yielder.yieldReturn(value);\n                            if (result)\n                                value -= step;\n                            return result;\n                        }, false);\n            });\n        };\n        Enumerable.matches = function (input, pattern, flags) {\n            if (flags === void 0) { flags = \"\"; }\n            if (input === null || input === VOID0)\n                throw new ArgumentNullException_1.ArgumentNullException(\"input\");\n            var type = typeof input;\n            if (type != Types_1.Type.STRING)\n                throw new Error(\"Cannot exec RegExp matches of type '\" + type + \"'.\");\n            if (pattern instanceof RegExp) {\n                flags += (pattern.ignoreCase) ? \"i\" : \"\";\n                flags += (pattern.multiline) ? \"m\" : \"\";\n                pattern = pattern.source;\n            }\n            if (flags.indexOf(\"g\") === -1)\n                flags += \"g\";\n            return new FiniteEnumerable(function () {\n                var regex;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    regex = new RegExp(pattern, flags);\n                }, function (yielder) {\n                    var match = regex.exec(input);\n                    return (match !== null) ? yielder.yieldReturn(match) : false;\n                });\n            });\n        };\n        Enumerable.generate = function (factory, count) {\n            if (count === void 0) { count = Infinity; }\n            if (isNaN(count) || count <= 0)\n                return Enumerable.empty();\n            return isFinite(count) && Integer_1.Integer.assert(count, \"count\")\n                ?\n                    new FiniteEnumerable(function () {\n                        var c = count;\n                        var index = 0;\n                        return new EnumeratorBase_1.EnumeratorBase(function () {\n                            index = 0;\n                        }, function (yielder) {\n                            var current = index++;\n                            return current < c && yielder.yieldReturn(factory(current));\n                        }, false);\n                    })\n                :\n                    new InfiniteEnumerable(function () {\n                        var index = 0;\n                        return new EnumeratorBase_1.EnumeratorBase(function () {\n                            index = 0;\n                        }, function (yielder) { return yielder.yieldReturn(factory(index++)); }, true);\n                    });\n        };\n        Enumerable.unfold = function (seed, valueFactory, skipSeed) {\n            if (skipSeed === void 0) { skipSeed = false; }\n            return new InfiniteEnumerable(function () {\n                var index = 0;\n                var value;\n                var isFirst;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    value = seed;\n                    isFirst = !skipSeed;\n                }, function (yielder) {\n                    var i = index++;\n                    if (isFirst)\n                        isFirst = false;\n                    else\n                        value = valueFactory(value, i);\n                    return yielder.yieldReturn(value);\n                }, true);\n            });\n        };\n        Enumerable.forEach = function (enumerable, action, max) {\n            if (max === void 0) { max = Infinity; }\n            return Enumerator_1.forEach(enumerable, action, max);\n        };\n        Enumerable.map = function (enumerable, selector) {\n            return Enumerator_1.map(enumerable, selector);\n        };\n        Enumerable.max = function (values) {\n            var v = values\n                .takeUntil(function (v) { return v == +Infinity; }, true)\n                .aggregate(Functions.Greater);\n            return v === VOID0 ? NaN : v;\n        };\n        Enumerable.min = function (values) {\n            var v = values\n                .takeUntil(function (v) { return v == -Infinity; }, true)\n                .aggregate(Functions.Lesser);\n            return v === VOID0 ? NaN : v;\n        };\n        Enumerable.weave = function (enumerables) {\n            if (!enumerables)\n                throw new ArgumentNullException_1.ArgumentNullException('enumerables');\n            return new Enumerable(function () {\n                var queue;\n                var mainEnumerator;\n                var index;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    queue = new Queue_1.Queue();\n                    mainEnumerator = Enumerator_1.from(enumerables);\n                }, function (yielder) {\n                    var e = null;\n                    if (mainEnumerator) {\n                        while (!e && mainEnumerator.moveNext()) {\n                            var c = mainEnumerator.current;\n                            e = nextEnumerator(queue, c ? Enumerator_1.from(c) : NULL);\n                        }\n                        if (!e)\n                            mainEnumerator = null;\n                    }\n                    while (!e && queue.count) {\n                        e = nextEnumerator(queue, queue.dequeue());\n                    }\n                    return e\n                        ? yielder.yieldReturn(e.current)\n                        : yielder.yieldBreak();\n                }, function () {\n                    dispose_1.dispose.these(queue.dump());\n                    dispose_1.dispose(mainEnumerator, queue);\n                    mainEnumerator = null;\n                    queue = NULL;\n                });\n            });\n        };\n        Enumerable.prototype.asEnumerable = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return new Enumerable(function () { return _.getEnumerator(); });\n        };\n        Enumerable.prototype.skipWhile = function (predicate) {\n            this.throwIfDisposed();\n            return this.doAction(function (element, index) {\n                return predicate(element, index)\n                    ? 2\n                    : 1;\n            });\n        };\n        Enumerable.prototype.takeWhile = function (predicate) {\n            this.throwIfDisposed();\n            if (!predicate)\n                throw new ArgumentNullException_1.ArgumentNullException('predicate');\n            return this.doAction(function (element, index) {\n                return predicate(element, index)\n                    ? 1\n                    : 0;\n            }, null, null);\n        };\n        Enumerable.prototype.takeUntil = function (predicate, includeUntilValue) {\n            this.throwIfDisposed();\n            if (!predicate)\n                throw new ArgumentNullException_1.ArgumentNullException('predicate');\n            if (!includeUntilValue)\n                return this.doAction(function (element, index) {\n                    return predicate(element, index)\n                        ? 0\n                        : 1;\n                }, null, null);\n            var found = false;\n            return this.doAction(function (element, index) {\n                if (found)\n                    return 0;\n                found = predicate(element, index);\n                return 1;\n            }, function () {\n                found = false;\n            }, null);\n        };\n        Enumerable.prototype.forEach = function (action) {\n            var _ = this;\n            _.throwIfDisposed();\n            Enumerator_1.throwIfEndless(_.isEndless);\n            var index = 0;\n            dispose_1.using(_.getEnumerator(), function (e) {\n                Enumerator_1.throwIfEndless(e.isEndless);\n                while (_.throwIfDisposed() && e.moveNext()) {\n                    if (action(e.current, index++) === false)\n                        break;\n                }\n            });\n        };\n        Enumerable.prototype.toArray = function (predicate) {\n            return predicate\n                ? this.where(predicate).toArray()\n                : this.copyTo([]);\n        };\n        Enumerable.prototype.copyTo = function (target, index, count) {\n            if (index === void 0) { index = 0; }\n            if (count === void 0) { count = Infinity; }\n            this.throwIfDisposed();\n            if (!target)\n                throw new ArgumentNullException_1.ArgumentNullException(\"target\");\n            Integer_1.Integer.assertZeroOrGreater(index);\n            Enumerator_1.forEach(this, function (x, i) {\n                target[i + index] = x;\n            }, count);\n            return target;\n        };\n        Enumerable.prototype.toLookup = function (keySelector, elementSelector, compareSelector) {\n            if (elementSelector === void 0) { elementSelector = Functions.Identity; }\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var dict = new Dictionary_1.Dictionary(compareSelector);\n            this.forEach(function (x) {\n                var key = keySelector(x);\n                var element = elementSelector(x);\n                var array = dict.getValue(key);\n                if (array !== VOID0)\n                    array.push(element);\n                else\n                    dict.addByKeyValue(key, [element]);\n            });\n            return new Lookup(dict);\n        };\n        Enumerable.prototype.toMap = function (keySelector, elementSelector) {\n            var obj = {};\n            this.forEach(function (x, i) {\n                obj[keySelector(x, i)] = elementSelector(x, i);\n            });\n            return obj;\n        };\n        Enumerable.prototype.toDictionary = function (keySelector, elementSelector, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var dict = new Dictionary_1.Dictionary(compareSelector);\n            this.forEach(function (x, i) { return dict.addByKeyValue(keySelector(x, i), elementSelector(x, i)); });\n            return dict;\n        };\n        Enumerable.prototype.toJoinedString = function (separator, selector) {\n            if (separator === void 0) { separator = \"\"; }\n            if (selector === void 0) { selector = Functions.Identity; }\n            return this\n                .select(selector)\n                .toArray()\n                .join(separator);\n        };\n        Enumerable.prototype.takeExceptLast = function (count) {\n            if (count === void 0) { count = 1; }\n            var _ = this;\n            if (!(count > 0))\n                return _;\n            if (!isFinite(count))\n                return Enumerable.empty();\n            Integer_1.Integer.assert(count, \"count\");\n            var c = count;\n            return new Enumerable(function () {\n                var enumerator;\n                var q;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    q = new Queue_1.Queue();\n                }, function (yielder) {\n                    while (enumerator.moveNext()) {\n                        q.enqueue(enumerator.current);\n                        if (q.count > c)\n                            return yielder.yieldReturn(q.dequeue());\n                    }\n                    return false;\n                }, function () {\n                    dispose_1.dispose(enumerator, q);\n                });\n            });\n        };\n        Enumerable.prototype.skipToLast = function (count) {\n            if (!(count > 0))\n                return Enumerable.empty();\n            var _ = this;\n            if (!isFinite(count))\n                return _;\n            Integer_1.Integer.assert(count, \"count\");\n            return _.reverse()\n                .take(count)\n                .reverse();\n        };\n        Enumerable.prototype.select = function (selector) {\n            return _super.prototype.select.call(this, selector);\n        };\n        Enumerable.prototype.selectMany = function (collectionSelector, resultSelector) {\n            return this._selectMany(collectionSelector, resultSelector);\n        };\n        Enumerable.prototype.choose = function (selector) {\n            if (selector === void 0) { selector = Functions.Identity; }\n            return this._choose(selector);\n        };\n        Enumerable.prototype.reverse = function () {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            Enumerator_1.throwIfEndless(_._isEndless);\n            return new Enumerable(function () {\n                var buffer;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    buffer = _.toArray();\n                    index = buffer.length;\n                }, function (yielder) { return !!index && yielder.yieldReturn(buffer[--index]); }, function () {\n                    buffer.length = 0;\n                });\n            }, function () {\n                disposed = true;\n            });\n        };\n        Enumerable.prototype.shuffle = function () {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            Enumerator_1.throwIfEndless(_._isEndless);\n            return new Enumerable(function () {\n                var buffer;\n                var capacity;\n                var len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    buffer = _.toArray();\n                    capacity = len = buffer.length;\n                }, function (yielder) {\n                    if (!len)\n                        return yielder.yieldBreak();\n                    var selectedIndex = Integer_1.Integer.random(len);\n                    var selectedValue = buffer[selectedIndex];\n                    buffer[selectedIndex] = buffer[--len];\n                    buffer[len] = NULL;\n                    if (len % 32 == 0)\n                        buffer.length = len;\n                    return yielder.yieldReturn(selectedValue);\n                }, function () {\n                    buffer.length = 0;\n                });\n            }, function () {\n                disposed = true;\n            });\n        };\n        Enumerable.prototype.count = function (predicate) {\n            var count = 0;\n            this.forEach(predicate\n                ?\n                    function (x, i) {\n                        if (predicate(x, i))\n                            ++count;\n                    }\n                :\n                    function () {\n                        ++count;\n                    });\n            return count;\n        };\n        Enumerable.prototype.all = function (predicate) {\n            if (!predicate)\n                throw new ArgumentNullException_1.ArgumentNullException(\"predicate\");\n            var result = true;\n            this.forEach(function (x, i) {\n                if (!predicate(x, i)) {\n                    result = false;\n                    return false;\n                }\n            });\n            return result;\n        };\n        Enumerable.prototype.every = function (predicate) {\n            return this.all(predicate);\n        };\n        Enumerable.prototype.any = function (predicate) {\n            if (!predicate)\n                return _super.prototype.any.call(this);\n            var result = false;\n            this.forEach(function (x, i) {\n                result = predicate(x, i);\n                return !result;\n            });\n            return result;\n        };\n        Enumerable.prototype.some = function (predicate) {\n            return this.any(predicate);\n        };\n        Enumerable.prototype.contains = function (value, compareSelector) {\n            return compareSelector\n                ? this.any(function (v) { return compareSelector(v) === compareSelector(value); })\n                : this.any(function (v) { return v === value; });\n        };\n        Enumerable.prototype.indexOf = function (value, compareSelector) {\n            var found = -1;\n            this.forEach(compareSelector\n                ?\n                    function (element, i) {\n                        if (Values.areEqual(compareSelector(element, i), compareSelector(value, i), true)) {\n                            found = i;\n                            return false;\n                        }\n                    }\n                :\n                    function (element, i) {\n                        if (Values.areEqual(element, value, true)) {\n                            found = i;\n                            return false;\n                        }\n                    });\n            return found;\n        };\n        Enumerable.prototype.lastIndexOf = function (value, compareSelector) {\n            var result = -1;\n            this.forEach(compareSelector\n                ?\n                    function (element, i) {\n                        if (Values.areEqual(compareSelector(element, i), compareSelector(value, i), true))\n                            result\n                                = i;\n                    }\n                :\n                    function (element, i) {\n                        if (Values.areEqual(element, value, true))\n                            result = i;\n                    });\n            return result;\n        };\n        Enumerable.prototype.intersect = function (second, compareSelector) {\n            var _ = this;\n            var isEndless = _.isEndless;\n            return new Enumerable(function () {\n                var enumerator;\n                var keys;\n                var outs;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    keys = new Dictionary_1.Dictionary(compareSelector);\n                    outs = new Dictionary_1.Dictionary(compareSelector);\n                    Enumerator_1.forEach(second, function (key) {\n                        keys.addByKeyValue(key, true);\n                    });\n                }, function (yielder) {\n                    while (enumerator.moveNext()) {\n                        var current = enumerator.current;\n                        if (!outs.containsKey(current) && keys.containsKey(current)) {\n                            outs.addByKeyValue(current, true);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    return yielder.yieldBreak();\n                }, function () {\n                    dispose_1.dispose(enumerator, keys, outs);\n                }, isEndless);\n            }, null, isEndless);\n        };\n        Enumerable.prototype.sequenceEqual = function (second, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\n            return dispose_1.using(this.getEnumerator(), function (e1) { return dispose_1.using(Enumerator_1.from(second), function (e2) {\n                Enumerator_1.throwIfEndless(e1.isEndless && e2.isEndless);\n                while (e1.moveNext()) {\n                    if (!e2.moveNext() || !equalityComparer(e1.current, e2.current))\n                        return false;\n                }\n                return !e2.moveNext();\n            }); });\n        };\n        Enumerable.prototype.ofType = function (type) {\n            return _super.prototype.ofType.call(this, type);\n        };\n        Enumerable.prototype.orderBy = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            return new OrderedEnumerable(this, keySelector, 1);\n        };\n        Enumerable.prototype.orderUsing = function (comparison) {\n            return new OrderedEnumerable(this, null, 1, null, comparison);\n        };\n        Enumerable.prototype.orderUsingReversed = function (comparison) {\n            return new OrderedEnumerable(this, null, -1, null, comparison);\n        };\n        Enumerable.prototype.orderByDescending = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            return new OrderedEnumerable(this, keySelector, -1);\n        };\n        Enumerable.prototype.buffer = function (size) {\n            return _super.prototype.buffer.call(this, size);\n        };\n        Enumerable.prototype.groupBy = function (keySelector, elementSelector, compareSelector) {\n            var _this = this;\n            if (!elementSelector)\n                elementSelector = Functions.Identity;\n            return new Enumerable(function () { return _this\n                .toLookup(keySelector, elementSelector, compareSelector)\n                .getEnumerator(); });\n        };\n        Enumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, compareSelector) {\n            if (resultSelector === void 0) { resultSelector = function (key, elements) { return new Grouping(key, elements); }; }\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            if (!elementSelector)\n                elementSelector = Functions.Identity;\n            return new Enumerable(function () {\n                var enumerator;\n                var key;\n                var compareKey;\n                var group;\n                var len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    if (enumerator.moveNext()) {\n                        var v = enumerator.current;\n                        key = keySelector(v);\n                        compareKey = compareSelector(key);\n                        group = [elementSelector(v)];\n                        len = 1;\n                    }\n                    else\n                        group = null;\n                }, function (yielder) {\n                    if (!group)\n                        return yielder.yieldBreak();\n                    var hasNext, c;\n                    while ((hasNext = enumerator.moveNext())) {\n                        c = enumerator.current;\n                        if (compareKey === compareSelector(keySelector(c)))\n                            group[len++] = elementSelector(c);\n                        else\n                            break;\n                    }\n                    var result = resultSelector(key, group);\n                    if (hasNext) {\n                        c = enumerator.current;\n                        key = keySelector(c);\n                        compareKey = compareSelector(key);\n                        group = [elementSelector(c)];\n                        len = 1;\n                    }\n                    else {\n                        group = null;\n                    }\n                    return yielder.yieldReturn(result);\n                }, function () {\n                    dispose_1.dispose(enumerator);\n                    group = null;\n                });\n            });\n        };\n        Enumerable.prototype.aggregate = function (func, seed) {\n            return this\n                .scan(func, seed)\n                .lastOrDefault();\n        };\n        Enumerable.prototype.average = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var count = 0;\n            var sum = this.sum(function (e, i) {\n                count++;\n                return selector(e, i);\n            });\n            return (isNaN(sum) || !count)\n                ? NaN\n                : (sum / count);\n        };\n        Enumerable.prototype.max = function () {\n            return this.aggregate(Functions.Greater);\n        };\n        Enumerable.prototype.min = function () {\n            return this.aggregate(Functions.Lesser);\n        };\n        Enumerable.prototype.maxBy = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            return this.aggregate(function (a, b) { return (keySelector(a) > keySelector(b)) ? a : b; });\n        };\n        Enumerable.prototype.minBy = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            return this.aggregate(function (a, b) { return (keySelector(a) < keySelector(b)) ? a : b; });\n        };\n        Enumerable.prototype.sum = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var sum = 0;\n            var sumInfinite = 0;\n            this.forEach(function (x) {\n                var value = selector(x);\n                if (isNaN(value)) {\n                    sum = NaN;\n                    return false;\n                }\n                if (isFinite(value))\n                    sum += value;\n                else\n                    sumInfinite +=\n                        value > 0 ?\n                            (+1) :\n                            (-1);\n            });\n            return isNaN(sum) ? NaN : (sumInfinite ? (sumInfinite * Infinity) : sum);\n        };\n        Enumerable.prototype.product = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var result = 1, exists = false;\n            this.forEach(function (x, i) {\n                exists = true;\n                var value = selector(x, i);\n                if (isNaN(value)) {\n                    result = NaN;\n                    return false;\n                }\n                if (value == 0) {\n                    result = 0;\n                    return false;\n                }\n                result *= value;\n            });\n            return (exists && isNaN(result)) ? NaN : result;\n        };\n        Enumerable.prototype.quotient = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var count = 0;\n            var result = NaN;\n            this.forEach(function (x, i) {\n                var value = selector(x, i);\n                count++;\n                if (count === 1) {\n                    result = value;\n                }\n                else {\n                    if (isNaN(value) || value === 0 || !isFinite(value)) {\n                        result = NaN;\n                        return false;\n                    }\n                    result /= value;\n                }\n            });\n            if (count === 1)\n                result = NaN;\n            return result;\n        };\n        Enumerable.prototype.last = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var value = VOID0;\n            var found = false;\n            _.forEach(function (x) {\n                found = true;\n                value = x;\n            });\n            if (!found)\n                throw new Error(\"last:No element satisfies the condition.\");\n            return value;\n        };\n        Enumerable.prototype.lastOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            var value = VOID0;\n            var found = false;\n            _.forEach(function (x) {\n                found = true;\n                value = x;\n            });\n            return (!found) ? defaultValue : value;\n        };\n        Enumerable.prototype.memoize = function () {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var cache;\n            var enumerator;\n            return new Enumerable(function () {\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    if (!enumerator)\n                        enumerator = _.getEnumerator();\n                    if (!cache)\n                        cache = [];\n                    index = 0;\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    var i = index++;\n                    if (i >= cache.length) {\n                        return (enumerator.moveNext())\n                            ? yielder.yieldReturn(cache[i] = enumerator.current)\n                            : false;\n                    }\n                    return yielder.yieldReturn(cache[i]);\n                });\n            }, function () {\n                disposed = true;\n                if (cache)\n                    cache.length = 0;\n                cache = NULL;\n                dispose_1.dispose(enumerator);\n                enumerator = NULL;\n            });\n        };\n        return Enumerable;\n    }(InfiniteEnumerable));\n    exports.Enumerable = Enumerable;\n    var FiniteEnumerable = (function (_super) {\n        __extends(FiniteEnumerable, _super);\n        function FiniteEnumerable(enumeratorFactory, finalizer) {\n            _super.call(this, enumeratorFactory, finalizer, false);\n        }\n        return FiniteEnumerable;\n    }(Enumerable));\n    exports.FiniteEnumerable = FiniteEnumerable;\n    var ArrayEnumerable = (function (_super) {\n        __extends(ArrayEnumerable, _super);\n        function ArrayEnumerable(source) {\n            _super.call(this, function () {\n                _.throwIfDisposed();\n                return new ArrayEnumerator_1.ArrayEnumerator(function () {\n                    _.throwIfDisposed(\"The underlying ArrayEnumerable was disposed.\", \"ArrayEnumerator\");\n                    return _._source;\n                });\n            });\n            var _ = this;\n            _._disposableObjectName = \"ArrayEnumerable\";\n            _._source = source;\n        }\n        ArrayEnumerable.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._source = NULL;\n        };\n        Object.defineProperty(ArrayEnumerable.prototype, \"source\", {\n            get: function () {\n                return this._source;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ArrayEnumerable.prototype.toArray = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return Enumerator_1.toArray(_._source);\n        };\n        ArrayEnumerable.prototype.asEnumerable = function () {\n            return new ArrayEnumerable(this._source);\n        };\n        ArrayEnumerable.prototype.forEach = function (action, max) {\n            if (max === void 0) { max = Infinity; }\n            var _ = this;\n            _.throwIfDisposed();\n            return Enumerator_1.forEach(_._source, action, max);\n        };\n        ArrayEnumerable.prototype.any = function (predicate) {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return !!len && (!predicate || _super.prototype.any.call(this, predicate));\n        };\n        ArrayEnumerable.prototype.count = function (predicate) {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return len && (predicate ? _super.prototype.count.call(this, predicate) : len);\n        };\n        ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            Integer_1.Integer.assertZeroOrGreater(index, 'index');\n            var source = _._source;\n            return index < source.length\n                ? source[index]\n                : defaultValue;\n        };\n        ArrayEnumerable.prototype.last = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return (len)\n                ? source[len - 1]\n                : _super.prototype.last.call(this);\n        };\n        ArrayEnumerable.prototype.lastOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return len\n                ? source[len - 1]\n                : defaultValue;\n        };\n        ArrayEnumerable.prototype.skip = function (count) {\n            var _ = this;\n            if (!(count > 0))\n                return _;\n            return new Enumerable(function () { return new ArrayEnumerator_1.ArrayEnumerator(function () { return _._source; }, count); });\n        };\n        ArrayEnumerable.prototype.takeExceptLast = function (count) {\n            if (count === void 0) { count = 1; }\n            var _ = this;\n            return _.take(_._source.length - count);\n        };\n        ArrayEnumerable.prototype.skipToLast = function (count) {\n            if (!(count > 0))\n                return Enumerable.empty();\n            var _ = this;\n            if (!isFinite(count))\n                return _;\n            var len = _._source\n                ? _._source.length\n                : 0;\n            return _.skip(len - count);\n        };\n        ArrayEnumerable.prototype.reverse = function () {\n            var _ = this;\n            return new Enumerable(function () { return new ArrayEnumerator_1.ArrayEnumerator(function () { return _._source; }, _._source\n                ? (_._source.length - 1)\n                : 0, -1); });\n        };\n        ArrayEnumerable.prototype.memoize = function () {\n            return this.asEnumerable();\n        };\n        ArrayEnumerable.prototype.sequenceEqual = function (second, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\n            if (Types_1.Type.isArrayLike(second))\n                return Arrays.areEqual(this.source, second, true, equalityComparer);\n            if (second instanceof ArrayEnumerable)\n                return second.sequenceEqual(this.source, equalityComparer);\n            return _super.prototype.sequenceEqual.call(this, second, equalityComparer);\n        };\n        ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {\n            if (separator === void 0) { separator = \"\"; }\n            if (selector === void 0) { selector = Functions.Identity; }\n            var s = this._source;\n            return !selector && Array.isArray(s)\n                ? s.join(separator)\n                : _super.prototype.toJoinedString.call(this, separator, selector);\n        };\n        return ArrayEnumerable;\n    }(FiniteEnumerable));\n    var Grouping = (function (_super) {\n        __extends(Grouping, _super);\n        function Grouping(_groupKey, elements) {\n            _super.call(this, elements);\n            this._groupKey = _groupKey;\n        }\n        Object.defineProperty(Grouping.prototype, \"key\", {\n            get: function () {\n                return this._groupKey;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return Grouping;\n    }(ArrayEnumerable));\n    var Lookup = (function () {\n        function Lookup(_dictionary) {\n            this._dictionary = _dictionary;\n        }\n        Object.defineProperty(Lookup.prototype, \"count\", {\n            get: function () {\n                return this._dictionary.count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Lookup.prototype.get = function (key) {\n            return this._dictionary.getValue(key);\n        };\n        Lookup.prototype.contains = function (key) {\n            return this._dictionary.containsKey(key);\n        };\n        Lookup.prototype.getEnumerator = function () {\n            var _ = this;\n            var enumerator;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                enumerator = _._dictionary.getEnumerator();\n            }, function (yielder) {\n                if (!enumerator.moveNext())\n                    return false;\n                var current = enumerator.current;\n                return yielder.yieldReturn(new Grouping(current.key, current.value));\n            }, function () {\n                dispose_1.dispose(enumerator);\n            });\n        };\n        return Lookup;\n    }());\n    var OrderedEnumerable = (function (_super) {\n        __extends(OrderedEnumerable, _super);\n        function OrderedEnumerable(source, keySelector, order, parent, comparer) {\n            if (comparer === void 0) { comparer = Values.compare; }\n            _super.call(this, NULL);\n            this.source = source;\n            this.keySelector = keySelector;\n            this.order = order;\n            this.parent = parent;\n            this.comparer = comparer;\n            Enumerator_1.throwIfEndless(!!source && !!source.isEndless);\n        }\n        OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, order) {\n            return new OrderedEnumerable(this.source, keySelector, order, this);\n        };\n        OrderedEnumerable.prototype.thenBy = function (keySelector) {\n            return this.createOrderedEnumerable(keySelector, 1);\n        };\n        OrderedEnumerable.prototype.thenUsing = function (comparison) {\n            return new OrderedEnumerable(this.source, null, 1, this, comparison);\n        };\n        OrderedEnumerable.prototype.thenByDescending = function (keySelector) {\n            return this.createOrderedEnumerable(keySelector, -1);\n        };\n        OrderedEnumerable.prototype.thenUsingReversed = function (comparison) {\n            return new OrderedEnumerable(this.source, null, -1, this, comparison);\n        };\n        OrderedEnumerable.prototype.getEnumerator = function () {\n            var _ = this;\n            var buffer;\n            var indexes;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                index = 0;\n                buffer = Enumerable.toArray(_.source);\n                indexes = createSortContext(_)\n                    .generateSortedIndexes(buffer);\n            }, function (yielder) {\n                return (index < indexes.length)\n                    ? yielder.yieldReturn(buffer[indexes[index++]])\n                    : false;\n            }, function () {\n                if (buffer)\n                    buffer.length = 0;\n                buffer = NULL;\n                if (indexes)\n                    indexes.length = 0;\n                indexes = NULL;\n            }, false);\n        };\n        OrderedEnumerable.prototype._onDispose = function () {\n            var _ = this;\n            _super.prototype._onDispose.call(this);\n            _.source = NULL;\n            _.keySelector = NULL;\n            _.order = NULL;\n            _.parent = NULL;\n        };\n        return OrderedEnumerable;\n    }(FiniteEnumerable));\n    function nextEnumerator(queue, e) {\n        if (e) {\n            if (e.moveNext()) {\n                queue.enqueue(e);\n            }\n            else {\n                dispose_1.dispose(e);\n                return null;\n            }\n        }\n        return e;\n    }\n    function createSortContext(orderedEnumerable, currentContext) {\n        if (currentContext === void 0) { currentContext = null; }\n        var context = new KeySortedContext_1.KeySortedContext(currentContext, orderedEnumerable.keySelector, orderedEnumerable.order, orderedEnumerable.comparer);\n        if (orderedEnumerable.parent)\n            return createSortContext(orderedEnumerable.parent, context);\n        return context;\n    }\n    function throwIfDisposed(disposed) {\n        if (disposed)\n            throw new ObjectDisposedException_1.ObjectDisposedException(\"Enumerable\");\n    }\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Enumerable;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Original: http://linqjs.codeplex.com/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport * as Values from \"../System/Compare\";\r\nimport * as Arrays from \"../System/Collections/Array/Compare\";\r\nimport * as ArrayUtility from \"../System/Collections/Array/Utility\";\r\nimport {\r\n\tfrom as enumeratorFrom,\r\n\tforEach,\r\n\ttoArray,\r\n\tmap,\r\n\tisEnumerable,\r\n\tthrowIfEndless\r\n} from \"../System/Collections/Enumeration/Enumerator\";\r\nimport {EmptyEnumerator} from \"../System/Collections/Enumeration/EmptyEnumerator\";\r\nimport {Type} from \"../System/Types\";\r\nimport {Integer} from \"../System/Integer\";\r\nimport {Functions as BaseFunctions} from \"../System/Functions\";\r\nimport {ArrayEnumerator} from \"../System/Collections/Enumeration/ArrayEnumerator\";\r\nimport {EnumeratorBase} from \"../System/Collections/Enumeration/EnumeratorBase\";\r\nimport {Dictionary} from \"../System/Collections/Dictionaries/Dictionary\";\r\nimport {Queue} from \"../System/Collections/Queue\";\r\nimport {dispose, using} from \"../System/Disposable/dispose\";\r\nimport {DisposableBase} from \"../System/Disposable/DisposableBase\";\r\nimport {UnsupportedEnumerableException} from \"../System/Collections/Enumeration/UnsupportedEnumerableException\";\r\nimport {ObjectDisposedException} from \"../System/Disposable/ObjectDisposedException\";\r\nimport {KeySortedContext} from \"../System/Collections/Sorting/KeySortedContext\";\r\nimport {ArgumentNullException} from \"../System/Exceptions/ArgumentNullException\";\r\nimport {ArgumentOutOfRangeException} from \"../System/Exceptions/ArgumentOutOfRangeException\";\r\nimport {IEnumerator} from \"../System/Collections/Enumeration/IEnumerator\";\r\nimport {IEnumerable} from \"../System/Collections/Enumeration/IEnumerable\";\r\nimport {\r\n\tAction,\r\n\tPredicate,\r\n\tSelector,\r\n\tEqualityComparison,\r\n\tComparison,\r\n\tClosure\r\n} from \"../System/FunctionTypes\";\r\nimport {IEnumerableOrArray} from \"../System/Collections/IEnumerableOrArray\";\r\nimport {IArray} from \"../System/Collections/Array/IArray\";\r\nimport {IMap, IDictionary} from \"../System/Collections/Dictionaries/IDictionary\";\r\nimport {Comparable} from \"../System/IComparable\";\r\nimport {IComparer} from \"../System/IComparer\";\r\nimport {IKeyValuePair} from \"../System/KeyValuePair\";\r\nimport {Order} from \"../System/Collections/Sorting/Order\";\r\nimport {\r\n\tIInfiniteEnumerable,\r\n\tILinqEnumerable,\r\n\tIFiniteEnumerable,\r\n\tILookup,\r\n\tIOrderedEnumerable,\r\n\tIGrouping,\r\n\tEnumerableAction\r\n} from \"./Enumerable\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n// #region Local Constants.\r\n\r\nconst INVALID_DEFAULT:any = {}; // create a private unique instance for referencing.\r\nconst VOID0:undefined = void 0;\r\nconst NULL:any = null;\r\nconst BREAK:(e:any)=>EnumerableAction = element => EnumerableAction.Break;\r\n\r\n// Leave internal to avoid accidental overwriting.\r\nclass LinqFunctions extends BaseFunctions\r\n{\r\n\t// noinspection JSMethodCanBeStatic\r\n\tGreater<T>(a:T, b:T)\r\n\t{\r\n\t\treturn a>b ? a : b;\r\n\t}\r\n\r\n\r\n\t// noinspection JSMethodCanBeStatic\r\n\tLesser<T>(a:T, b:T)\r\n\t{\r\n\t\treturn a<b ? a : b;\r\n\t}\r\n}\r\n\r\nvar Functions = new LinqFunctions();\r\nObject.freeze(Functions);\r\n\r\n// For re-use as a factory.\r\nfunction getEmptyEnumerator():IEnumerator<any>\r\n{\r\n\treturn EmptyEnumerator;\r\n}\r\n\r\n// #endregion\r\n\r\n\r\n/*\r\n * NOTE: About InfiniteEnumerable<T> and Enumerable<T>.\r\n * There may seem like there's extra overrides here and they may seem unnecessary.\r\n * But after closer inspection you'll see the type chain is retained and\r\n * infinite enumerables are prevented from having features that finite ones have.\r\n *\r\n * I'm not sure if it's the best option to just use overrides, but it honors the typing properly.\r\n */\r\n\r\nexport class InfiniteEnumerable<T>\r\nextends DisposableBase implements IInfiniteEnumerable<T>\r\n{\r\n\tconstructor(\r\n\t\tprotected _enumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:Closure|null)\r\n\t{\r\n\t\tsuper(finalizer);\r\n\t\tthis._isEndless = true;\r\n\t}\r\n\r\n\tprotected _isEndless:boolean|undefined;\r\n\tget isEndless():boolean|undefined\r\n\t{\r\n\t\treturn this._isEndless;\r\n\t}\r\n\r\n\t// #region IEnumerable<T> Implementation...\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this._enumeratorFactory();\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IDisposable override...\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose(); // Just in case.\r\n\t\t(<any>this)._enumeratorFactory = null;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// Return a default (unfiltered) enumerable.\r\n\tasEnumerable():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\treturn <any> new InfiniteEnumerable<T>(() => _.getEnumerator());\r\n\t}\r\n\r\n\t/**\r\n\t * Similar to forEach, but executes an action for each time a value is enumerated.\r\n\t * If the action explicitly returns false or 0 (EnumerationAction.Break), the enumeration will complete.\r\n\t * If it returns a 2 (EnumerationAction.Skip) it will move on to the next item.\r\n\t * This also automatically handles disposing the enumerator.\r\n\t * @param action\r\n\t * @param initializer\r\n\t * @param isEndless Special case where isEndless can be null in order to negate inheritance.\r\n\t * @returns {any}\r\n\t */\r\n\tdoAction(\r\n\t\taction:Action<T> | Predicate<T> | Selector<T, number> | Selector<T, EnumerableAction>,\r\n\t\tinitializer?:Closure|null,\r\n\t\tisEndless:boolean|null|undefined = this.isEndless):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tconst isE:boolean|undefined = isEndless || undefined; // In case it's null.\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tif(initializer) initializer();\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\t// May need a way to propagate isEndless\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet actionResult = <any>action(<T>enumerator.current, index++);\r\n\r\n\t\t\t\t\t\t\tif(actionResult===false || actionResult===EnumerableAction.Break)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tif(actionResult!==EnumerableAction.Skip) // || !== 2\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\r\n\t\t\t\t\t\t\t// If actionResult===2, then a signal for skip is received.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisE\r\n\t\t\t\t);\r\n\r\n\t\t\t},\r\n\t\t\t// Using a finalizer value reduces the chance of a circular reference\r\n\t\t\t// since we could simply reference the enumeration and check e.wasDisposed.\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisE\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tforce():void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis.doAction(BREAK)\r\n\t\t\t.getEnumerator()\r\n\t\t\t.moveNext();\r\n\r\n\t}\r\n\r\n\t// #region Indexing/Paging methods.\r\n\tskip(count:number):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!isFinite(count)) // +Infinity equals skip all so return empty.\r\n\t\t\treturn <any> new InfiniteEnumerable<T>(getEmptyEnumerator);\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t\tindex<count\r\n\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t: EnumerableAction.Return\r\n\t\t);\r\n\t}\r\n\r\n\r\n\ttake(count:number):FiniteEnumerable<T>\r\n\t{\r\n\t\tif(!(count>0)) // Out of bounds? Empty.\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!isFinite(count))\r\n\t\t\tthrow new ArgumentOutOfRangeException('count', count, 'Must be finite.');\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\t// Once action returns false, the enumeration will stop.\r\n\t\treturn <any> _.doAction((element:T, index?:number) => index<count, null, false);\r\n\t}\r\n\r\n\t// #region Single Value Return...\r\n\r\n\telementAt(index:number):T\r\n\t{\r\n\t\tvar v = this.elementAtOrDefault(index, INVALID_DEFAULT);\r\n\t\tif(v===INVALID_DEFAULT) throw new ArgumentOutOfRangeException('index', index, \"is greater than or equal to the number of elements in source\");\r\n\t\treturn <T>v;\r\n\t}\r\n\r\n\telementAtOrDefault(index:number, defaultValue?:T):T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\t\tvar n:number = index;\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\twhile(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(i==n) return e.current;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn defaultValue;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/* Note: Unlike previous implementations, you could pass a predicate into these methods.\r\n\t * But since under the hood it ends up calling .where(predicate) anyway,\r\n\t * it may be better to remove this to allow for a cleaner signature/override.\r\n\t * JavaScript/TypeScript does not easily allow for a strict method interface like C#.\r\n\t * Having to write extra override logic is error prone and confusing to the consumer.\r\n\t * Removing the predicate here may also cause the consumer of this method to think more about how they structure their query.\r\n\t * The end all difference is that the user must declare .where(predicate) before .first(), .single(), or .last().\r\n\t * */\r\n\r\n\tfirst():T\r\n\t{\r\n\t\tvar v = this.firstOrDefault(INVALID_DEFAULT);\r\n\t\tif(v===INVALID_DEFAULT) throw new Error(\"first:The sequence is empty.\");\r\n\t\treturn <T>v;\r\n\t}\r\n\r\n\tfirstOrDefault(defaultValue?:T):T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=> e.moveNext() ? e.current : defaultValue\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tsingle():T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn <T>using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tif(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = e.current;\r\n\t\t\t\t\tif(!e.moveNext()) return value;\r\n\t\t\t\t\tthrow new Error(\"single:sequence contains more than one element.\");\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error(\"single:The sequence is empty.\");\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tsingleOrDefault(defaultValue?:T):T|undefined\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tif(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = e.current;\r\n\t\t\t\t\tif(!e.moveNext()) return value;\r\n\t\t\t\t}\r\n\t\t\t\treturn defaultValue;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tany():boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=> e.moveNext()\r\n\t\t);\r\n\t}\r\n\r\n\tisEmpty():boolean\r\n\t{\r\n\t\treturn !this.any();\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\t// #region Projection and Filtering Methods\r\n\r\n\ttraverseBreadthFirst(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>):Enumerable<T>;\r\n\r\n\ttraverseBreadthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>):Enumerable<TNode>;\r\n\r\n\ttraverseBreadthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>,\r\n\t\tresultSelector?:(element:T, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseBreadthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector?:(element:TNode, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseBreadthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector:(\r\n\t\t\telement:TNode,\r\n\t\t\tnestLevel?:number) => any = Functions.Identity):Enumerable<any>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless; // Is endless is not affirmative if false.\r\n\r\n\r\n\t\treturn new Enumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<any>;\r\n\t\t\t\tlet nestLevel:number = 0;\r\n\t\t\t\tlet buffer:any[], len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<any>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnestLevel = 0;\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbuffer[len++] = enumerator.current;\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(resultSelector(enumerator.current, nestLevel));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!len)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tlet next = Enumerable\r\n\t\t\t\t\t\t\t\t.from(buffer)\r\n\t\t\t\t\t\t\t\t.selectMany(childrenSelector);\r\n\r\n\t\t\t\t\t\t\tif(!next.any())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnestLevel++;\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\t\tenumerator = next.getEnumerator();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\ttraverseDepthFirst(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>):Enumerable<T>;\r\n\r\n\ttraverseDepthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>):Enumerable<TNode>;\r\n\r\n\ttraverseDepthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>,\r\n\t\tresultSelector?:(element:T, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseDepthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector?:(element:TNode, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseDepthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector:(\r\n\t\t\telement:TNode,\r\n\t\t\tnestLevel?:number) => any = Functions.Identity):Enumerable<any>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless; // Is endless is not affirmative if false.\r\n\r\n\t\treturn new Enumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Dev Note: May want to consider using an actual stack and not an array.\r\n\t\t\t\tlet enumeratorStack:IEnumerator<any>[] = [];\r\n\t\t\t\tlet enumerator:IEnumerator<any>;\r\n\t\t\t\tlet len:number;  // Avoid using push/pop since they query .length every time and can be slower.\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet value = resultSelector(<TNode>enumerator.current, len);\r\n\t\t\t\t\t\t\t\tenumeratorStack[len++] = enumerator;\r\n\t\t\t\t\t\t\t\tlet e = Enumerable.fromAny(childrenSelector(<T|TNode>enumerator.current));\r\n\t\t\t\t\t\t\t\tenumerator = e ? e.getEnumerator() : EmptyEnumerator;\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(value);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(len==0) return false;\r\n\r\n\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\tenumerator = enumeratorStack[--len];\r\n\t\t\t\t\t\t\tenumeratorStack.length = len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose.these(enumeratorStack);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tflatten():Enumerable<any>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless; // Is endless is not affirmative if false.;\r\n\r\n\t\treturn new Enumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<any>;\r\n\t\t\t\tlet middleEnumerator:IEnumerator<any>|null = null;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(middleEnumerator)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif(middleEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(middleEnumerator.current);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tmiddleEnumerator.dispose();\r\n\t\t\t\t\t\t\t\t\tmiddleEnumerator = null;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet c = enumerator.current;\r\n\t\t\t\t\t\t\t\t// Because strings are enumerable, we can get stuck in an infinite loop.\r\n\t\t\t\t\t\t\t\t// Treat strings as primitives here.\r\n\t\t\t\t\t\t\t\tlet e = !Type.isString(c) && Enumerable.fromAny(c);\r\n\t\t\t\t\t\t\t\tif(e)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tmiddleEnumerator = e\r\n\t\t\t\t\t\t\t\t\t\t.selectMany(Functions.Identity)\r\n\t\t\t\t\t\t\t\t\t\t.flatten()\r\n\t\t\t\t\t\t\t\t\t\t.getEnumerator();\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(c);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, middleEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tpairwise<TSelect>(selector:(prev:T, current:T) => TSelect):Enumerable<TSelect>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn new Enumerable<TSelect>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TSelect>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tenumerator.moveNext();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet prev = <T>enumerator.current;\r\n\t\t\t\t\t\treturn enumerator.moveNext()\r\n\t\t\t\t\t\t\t&& yielder.yieldReturn(selector(prev, <T>enumerator.current));\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tscan(func:(a:T, b:T) => T, seed?:T):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tvar isUseSeed = seed!==VOID0; // For now...\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet value:T;\r\n\t\t\t\tlet isFirst:boolean;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tisFirst = true;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(isFirst)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\t//noinspection JSUnusedAssignment\r\n\t\t\t\t\t\t\treturn isUseSeed\r\n\t\t\t\t\t\t\t\t? yielder.yieldReturn(value = <T>seed)\r\n\t\t\t\t\t\t\t\t: enumerator.moveNext()\r\n\t\t\t\t\t\t\t&& yielder.yieldReturn(value = <T>enumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(value = func(value, <T>enumerator.current))\r\n\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tselect<TResult>(selector:Selector<T, TResult>):InfiniteEnumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\treturn enumerator.moveNext()\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(selector(<T>enumerator.current, index++))\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\t/*\r\n\tpublic static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(\r\n\t\tthis IEnumerable<TSource> source,\r\n\t\tFunc<TSource, IEnumerable<TCollection>> collectionSelector,\r\n\t\tFunc<TSource, TCollection, TResult> resultSelector)\r\n\t */\r\n\r\n\tprotected _selectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector?:(collection:T, element:TElement) => TResult):Enumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless; // Do second enumeration, it will be indeterminate if false.\r\n\t\tif(!resultSelector)\r\n\t\t\tresultSelector = (a:T, b:any) => <TResult>b;\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet middleEnumerator:IEnumerator<any>|null|undefined;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tmiddleEnumerator = VOID0;\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t// Just started, and nothing to enumerate? End.\r\n\t\t\t\t\t\tif(middleEnumerator===VOID0 && !enumerator.moveNext())\r\n\t\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t\t// moveNext has been called at least once...\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t// Initialize middle if there isn't one.\r\n\t\t\t\t\t\t\tif(!middleEnumerator)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet middleSeq = collectionSelector(<T>enumerator.current, index++);\r\n\r\n\t\t\t\t\t\t\t\t// Collection is null?  Skip it...\r\n\t\t\t\t\t\t\t\tif(!middleSeq)\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t\tmiddleEnumerator = enumeratorFrom(middleSeq);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(middleEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(\r\n\t\t\t\t\t\t\t\t\tresultSelector!(\r\n\t\t\t\t\t\t\t\t\t\t<T>enumerator.current, <TElement>middleEnumerator.current\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t// else no more in this middle?  Then clear and reset for next...\r\n\r\n\t\t\t\t\t\t\tmiddleEnumerator.dispose();\r\n\t\t\t\t\t\t\tmiddleEnumerator = null;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(enumerator.moveNext());\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, middleEnumerator);\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tmiddleEnumerator = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TResult>>):InfiniteEnumerable<TResult>;\r\n\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector:(collection:T, element:TElement) => TResult):InfiniteEnumerable<TResult>;\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<any>>,\r\n\t\tresultSelector?:(collection:T, element:any) => TResult):InfiniteEnumerable<TResult>\r\n\t{\r\n\t\treturn this._selectMany(collectionSelector, resultSelector);\r\n\t}\r\n\r\n\tprotected _choose<TResult>(selector:Selector<T, TResult>):Enumerable<TResult>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet result = selector(<T>enumerator.current, index++);\r\n\t\t\t\t\t\t\tif(result!==null && result!==VOID0)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns selected values that are not null or undefined.\r\n\t */\r\n\tchoose():InfiniteEnumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):InfiniteEnumerable<TResult>\r\n\tchoose(selector:Selector<T, any> = Functions.Identity):InfiniteEnumerable<any>\r\n\t{\r\n\t\treturn this._choose(selector)\r\n\t}\r\n\r\n\twhere(predicate:Predicate<T>):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet v = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(predicate(v, index++))\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(v);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tofType<TType>(type:{ new (...params:any[]):TType }):InfiniteEnumerable<TType>;\r\n\tofType<TType>(type:any):InfiniteEnumerable<TType>\r\n\t{\r\n\t\tvar typeName:string;\r\n\t\tswitch(<any>type)\r\n\t\t{\r\n\t\t\tcase Number:\r\n\t\t\t\ttypeName = Type.NUMBER;\r\n\t\t\t\tbreak;\r\n\t\t\tcase String:\r\n\t\t\t\ttypeName = Type.STRING;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Boolean:\r\n\t\t\t\ttypeName = Type.BOOLEAN;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Function:\r\n\t\t\t\ttypeName = Type.FUNCTION;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\treturn <any> this\r\n\t\t\t\t\t.where(x=>x instanceof type);\r\n\t\t}\r\n\t\treturn <Enumerable<any>>this\r\n\t\t\t.choose()\r\n\t\t\t.where(x=>(typeof x)===typeName);\r\n\t}\r\n\r\n\texcept<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet keys:Dictionary<T, boolean>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tkeys = new Dictionary<T, boolean>(compareSelector);\r\n\t\t\t\t\t\tif(second)\r\n\t\t\t\t\t\t\tforEach(second, key => { keys.addByKeyValue(key, true) });\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet current = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, true);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tkeys.clear();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tdistinct(compareSelector?:(value:T) => T):this\r\n\t{\r\n\t\treturn this.except(NULL, compareSelector);\r\n\t}\r\n\r\n\t// [0,0,0,1,1,1,2,2,2,0,0,0,1,1] results in [0,1,2,0,1];\r\n\tdistinctUntilChanged<TCompare>(compareSelector:Selector<T, TCompare> = Functions.Identity):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet compareKey:TCompare;\r\n\t\t\t\tlet initial:boolean = true;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet key = compareSelector(<T>enumerator.current);\r\n\r\n\t\t\t\t\t\t\tif(initial)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinitial = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(Values.areEqual(compareKey, key))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcompareKey = key;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a single default value if empty.\r\n\t * @param defaultValue\r\n\t * @returns {Enumerable}\r\n\t */\r\n\tdefaultIfEmpty(defaultValue?:T):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed:boolean = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet isFirst:boolean;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tisFirst = true;\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if(isFirst)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(defaultValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tzip<TSecond, TResult>(\r\n\t\tsecond:IEnumerableOrArray<TSecond>,\r\n\t\tresultSelector:(first:T, second:TSecond, index?:number) => TResult):Enumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<TSecond>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = enumeratorFrom<TSecond>(second);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=> firstEnumerator.moveNext()\r\n\t\t\t\t\t&& secondEnumerator.moveNext()\r\n\t\t\t\t\t&& yielder.yieldReturn(resultSelector(<T>firstEnumerator.current, <TSecond>secondEnumerator.current, index++)),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondEnumerator);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tzipMultiple<TSecond, TResult>(\r\n\t\tsecond:IArray<IEnumerableOrArray<TSecond>>,\r\n\t\tresultSelector:(first:T, second:TSecond, index?:number) => TResult):Enumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!second.length)\r\n\t\t\treturn Enumerable.empty<TResult>();\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet secondTemp:Queue<any>;\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<TSecond>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsecondTemp = new Queue<any>(second);\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\twhile(!secondEnumerator)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(secondTemp.count)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tlet next = secondTemp.dequeue();\r\n\t\t\t\t\t\t\t\t\t\tif(next) // In case by chance next is null, then try again.\r\n\t\t\t\t\t\t\t\t\t\t\tsecondEnumerator = enumeratorFrom<TSecond>(next);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(\r\n\t\t\t\t\t\t\t\t\t\tresultSelector(<T>firstEnumerator.current, <TSecond>secondEnumerator.current, index++)\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tsecondEnumerator.dispose();\r\n\t\t\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondTemp);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t// #region Join Methods\r\n\r\n\tjoin<TInner, TKey, TResult, TCompare>(\r\n\t\tinner:IEnumerableOrArray<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner) => TResult,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):Enumerable<TResult>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet outerEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet lookup:ILookup<TKey,TInner>;\r\n\t\t\t\tlet innerElements:TInner[]|null;\r\n\t\t\t\tlet innerCount:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\touterEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlookup = Enumerable.from(inner)\r\n\t\t\t\t\t\t\t.toLookup(innerKeySelector, Functions.Identity, compareSelector);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(innerElements)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet innerElement = innerElements[innerCount++];\r\n\t\t\t\t\t\t\t\tif(innerElement!==VOID0)\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(resultSelector(<T>outerEnumerator.current, innerElement));\r\n\r\n\t\t\t\t\t\t\t\tinnerElements = null;\r\n\t\t\t\t\t\t\t\tinnerCount = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(outerEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet key = outerKeySelector(<T>outerEnumerator.current);\r\n\t\t\t\t\t\t\t\tinnerElements = lookup.get(key);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(outerEnumerator);\r\n\t\t\t\t\t\tinnerElements = null;\r\n\t\t\t\t\t\touterEnumerator = NULL;\r\n\t\t\t\t\t\tlookup = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgroupJoin<TInner, TKey, TResult, TCompare>(\r\n\t\tinner:IEnumerableOrArray<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner[]) => TResult,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):Enumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet lookup:ILookup<TKey, TInner>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlookup = Enumerable.from(inner)\r\n\t\t\t\t\t\t\t.toLookup(innerKeySelector, Functions.Identity, compareSelector);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\tenumerator.moveNext()\r\n\t\t\t\t\t&& yielder.yieldReturn(\r\n\t\t\t\t\t\tresultSelector(\r\n\t\t\t\t\t\t\t<T>enumerator.current,\r\n\t\t\t\t\t\t\tlookup.get(outerKeySelector(<T>enumerator.current))\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tlookup = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tmerge(enumerables:IArray<IEnumerableOrArray<T>>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\tif(!enumerables || enumerables.length==0)\r\n\t\t\treturn _;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet queue:Queue<IEnumerableOrArray<T>>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 1) First get our values...\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tqueue = new Queue<IEnumerableOrArray<T>>(enumerables);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\twhile(!enumerator && queue.count)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tenumerator = enumeratorFrom<T>(queue.dequeue()); // 4) Keep going and on to step 2.  Else fall through to yieldBreak().\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(enumerator && enumerator.moveNext()) // 2) Keep returning until done.\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\r\n\t\t\t\t\t\t\tif(enumerator) // 3) Dispose and reset for next.\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, queue); // Just in case this gets disposed early.\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tconcat(...enumerables:Array<IEnumerableOrArray<T>>):this\r\n\t{\r\n\t\treturn this.merge(enumerables);\r\n\t}\r\n\r\n\r\n\tunion<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector:Selector<T, TCompare> = Functions.Identity):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet keys:Dictionary<T, any>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tkeys = new Dictionary<T, any>(compareSelector); // Acting as a HashSet.\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet current:T;\r\n\t\t\t\t\t\tif(secondEnumerator===VOID0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcurrent = <T>firstEnumerator.current;\r\n\t\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, null);\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsecondEnumerator = enumeratorFrom(second);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcurrent = <T>secondEnumerator.current;\r\n\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, null);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tinsertAt(index:number, other:IEnumerableOrArray<T>):this\r\n\t{\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\t\tvar n:number = index;\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<T>;\r\n\r\n\t\t\t\tlet count:number = 0;\r\n\t\t\t\tlet isEnumerated:boolean = false;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcount = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = enumeratorFrom<T>(other);\r\n\t\t\t\t\t\tisEnumerated = false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(count==n)\r\n\t\t\t\t\t\t{ // Inserting?\r\n\t\t\t\t\t\t\tisEnumerated = true;\r\n\t\t\t\t\t\t\tif(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(secondEnumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(firstEnumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn !isEnumerated\r\n\t\t\t\t\t\t\t&& secondEnumerator.moveNext()\r\n\t\t\t\t\t\t\t&& yielder.yieldReturn(secondEnumerator.current);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\talternateMultiple(sequence:IEnumerableOrArray<T>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet buffer:T,\r\n\t\t\t\t    mode:EnumerableAction,\r\n\t\t\t\t    enumerator:IEnumerator<T>,\r\n\t\t\t\t    alternateEnumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Instead of recalling getEnumerator every time, just reset the existing one.\r\n\t\t\t\t\t\talternateEnumerator = new ArrayEnumerator(\r\n\t\t\t\t\t\t\tEnumerable.toArray<T>(sequence)\r\n\t\t\t\t\t\t); // Freeze\r\n\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tlet hasAtLeastOne = enumerator.moveNext();\r\n\t\t\t\t\t\tmode = hasAtLeastOne\r\n\t\t\t\t\t\t\t? EnumerableAction.Return\r\n\t\t\t\t\t\t\t: EnumerableAction.Break;\r\n\r\n\t\t\t\t\t\tif(hasAtLeastOne)\r\n\t\t\t\t\t\t\tbuffer = <T>enumerator.current;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tswitch(mode)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcase EnumerableAction.Break: // We're done?\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tcase EnumerableAction.Skip:\r\n\t\t\t\t\t\t\t\tif(alternateEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(alternateEnumerator.current);\r\n\t\t\t\t\t\t\t\talternateEnumerator.reset();\r\n\t\t\t\t\t\t\t\tmode = EnumerableAction.Return;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet latest = buffer;\r\n\r\n\t\t\t\t\t\t// Set up the next round...\r\n\r\n\t\t\t\t\t\t// Is there another one?  Set the buffer and setup instruct for the next one to be the alternate.\r\n\t\t\t\t\t\tlet another = enumerator.moveNext();\r\n\t\t\t\t\t\tmode = another\r\n\t\t\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t\t\t: EnumerableAction.Break;\r\n\r\n\t\t\t\t\t\tif(another)\r\n\t\t\t\t\t\t\tbuffer = <T>enumerator.current;\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(latest);\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, alternateEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\talternateSingle(value:T):this\r\n\t{\r\n\t\treturn this.alternateMultiple(Enumerable.make(value));\r\n\t}\r\n\r\n\talternate(...sequence:T[]):this\r\n\t{\r\n\t\treturn this.alternateMultiple(sequence);\r\n\t}\r\n\r\n\r\n\t// #region Error Handling\r\n\tcatchError(handler:(e:any) => void):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Don't init...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\thandler(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tfinallyAction(action:Closure):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(enumerator.current)\r\n\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\taction();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tbuffer(size:number):InfiniteEnumerable<T[]>\r\n\t{\r\n\t\tif(size<1 || !isFinite(size))\r\n\t\t\tthrow new Error(\"Invalid buffer size.\");\r\n\r\n\t\tInteger.assert(size, \"size\");\r\n\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\t\tvar len:number;\r\n\r\n\t\treturn new Enumerable<T[]>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\treturn new EnumeratorBase<T[]>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet array:T[] = ArrayUtility.initialize<T>(size);\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\twhile(len<size && enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tarray[len++] = <T>enumerator.current;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tarray.length = len;\r\n\t\t\t\t\t\treturn !!len && yielder.yieldReturn(array);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tshare():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet sharedEnumerator:IEnumerator<T>;\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\treturn sharedEnumerator || (sharedEnumerator = _.getEnumerator());\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdispose(sharedEnumerator);\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * Enumerable<T> is a wrapper class that allows more primitive enumerables to exhibit LINQ behavior.\r\n *\r\n * In C# Enumerable<T> is not an instance but has extensions for IEnumerable<T>.\r\n * In this case, we use Enumerable<T> as the underlying class that is being chained.\r\n */\r\nexport class Enumerable<T>\r\nextends InfiniteEnumerable<T> implements ILinqEnumerable<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tenumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:Closure|null,\r\n\t\tisEndless?:boolean)\r\n\t{\r\n\t\tsuper(enumeratorFactory, finalizer);\r\n\t\tthis._isEndless = isEndless;\r\n\t}\r\n\r\n\t/**\r\n\t * Universal method for converting a primitive enumerables into a LINQ enabled ones.\r\n\t *\r\n\t * Is not limited to TypeScript usages.\r\n\t */\r\n\tstatic from<T>(source:IEnumerableOrArray<T>):Enumerable<T>\r\n\t{\r\n\t\tvar e = Enumerable.fromAny(source);\r\n\t\tif(!e) throw new UnsupportedEnumerableException();\r\n\t\treturn e;\r\n\t}\r\n\r\n\tstatic fromAny<T>(\r\n\t\tsource:IEnumerableOrArray<T>):Enumerable<T>\r\n\r\n\tstatic fromAny(\r\n\t\tsource:any):Enumerable<any>\r\n\r\n\tstatic fromAny<T>(\r\n\t\tsource:IEnumerableOrArray<T>,\r\n\t\tdefaultEnumerable:Enumerable<T>):Enumerable<T>\r\n\r\n\tstatic fromAny<T>(\r\n\t\tsource:any,\r\n\t\tdefaultEnumerable?:Enumerable<T>):Enumerable<T>|undefined\r\n\t{\r\n\t\tif(Type.isObject(source) || Type.isString(source))\r\n\t\t{\r\n\t\t\tif(source instanceof Enumerable)\r\n\t\t\t\treturn source;\r\n\r\n\t\t\tif(Type.isArrayLike<T>(source))\r\n\t\t\t\treturn new ArrayEnumerable<T>(source);\r\n\r\n\t\t\tif(isEnumerable<T>(source))\r\n\t\t\t\treturn new Enumerable<T>(\r\n\t\t\t\t\t()=>source.getEnumerator(),\r\n\t\t\t\t\tnull, source.isEndless);\r\n\t\t}\r\n\r\n\t\treturn defaultEnumerable;\r\n\t}\r\n\r\n\tstatic fromOrEmpty<T>(source:IEnumerableOrArray<T>):Enumerable<T>\r\n\t{\r\n\t\treturn Enumerable.fromAny(source) || Enumerable.empty<T>();\r\n\t}\r\n\r\n\t/**\r\n\t * Static helper for converting enumerables to an array.\r\n\t * @param source\r\n\t * @returns {any}\r\n\t */\r\n\tstatic toArray<T>(source:IEnumerableOrArray<T>):T[]\r\n\t{\r\n\t\tif(source instanceof Enumerable)\r\n\t\t\treturn source.toArray();\r\n\r\n\t\treturn toArray(source);\r\n\t}\r\n\r\n\r\n\t//////////////////////////////////////////\r\n\t// #region Static Methods...\r\n\tstatic choice<T>(values:IArray<T>):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar len = values && values.length;\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!len || !isFinite(len))\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() => new EnumeratorBase<T>(\r\n\t\t\t\tnull,\r\n\t\t\t\t(yielder)=>\r\n\t\t\t\t\tyielder.yieldReturn(Integer.random.select(values)),\r\n\t\t\t\ttrue // Is endless!\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tstatic chooseFrom<T>(...args:T[]):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn Enumerable.choice(args);\r\n\t}\r\n\r\n\tstatic cycle<T>(values:IArray<T>):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar len = values && values.length;\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!len || !isFinite(len))\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet index:number = 0;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t}, // Reinitialize the value just in case the enumerator is restarted.\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(index>=values.length) index = 0;\r\n\t\t\t\t\t\treturn yielder.yieldReturn(values[index++]);\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic cycleThrough<T>(...args:T[]):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn Enumerable.cycle(args);\r\n\t}\r\n\r\n\tstatic empty<T>():FiniteEnumerable<T>\r\n\t{\r\n\t\t// Could be single static instance, but for safety, we'll make a new one.\r\n\t\treturn new FiniteEnumerable<T>(getEmptyEnumerator);\r\n\t}\r\n\r\n\tstatic repeat<T>(element:T):InfiniteEnumerable<T>;\r\n\tstatic repeat<T>(element:T, count:number):FiniteEnumerable<T>;\r\n\tstatic repeat<T>(element:T, count:number = Infinity):Enumerable<T>\r\n\t{\r\n\t\tif(!(count>0))\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\treturn isFinite(count) && Integer.assert(count, \"count\")\r\n\t\t\t? new FiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet c:number = count;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() => { index = 0; },\r\n\t\t\t\t\t(yielder)=> (index++<c) && yielder.yieldReturn(element),\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t)\r\n\t\t\t: new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t\tnew EnumeratorBase<T>(\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\t(yielder)=> yielder.yieldReturn(element),\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t// Note: this enumeration is endless but can be disposed/cancelled and finalized.\r\n\tstatic repeatWithFinalize<T>(\r\n\t\tinitializer:() => T,\r\n\t\tfinalizer:(element:T) => void):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet element:T;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\telement = initializer();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=> yielder.yieldReturn(element),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfinalizer(element);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an enumerable of one element.\r\n\t * @param element\r\n\t * @returns {FiniteEnumerable<T>}\r\n\t */\r\n\tstatic make<T>(element:T):FiniteEnumerable<T>\r\n\t{\r\n\t\treturn Enumerable.repeat<T>(element, 1);\r\n\t}\r\n\r\n\t// start and step can be other than integer.\r\n\r\n\tstatic range(\r\n\t\tstart:number,\r\n\t\tcount:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tif(!isFinite(start))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn Enumerable.empty<number>();\r\n\r\n\t\tif(!step)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\r\n\r\n\t\tif(!isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\treturn new FiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet value:number;\r\n\t\t\t\tlet c:number = count; // Force integer evaluation.\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tvalue = start;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet result:boolean =\r\n\t\t\t\t\t\t\t    index++<c\r\n\t\t\t\t\t\t\t    && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\tif(result && index<count)\r\n\t\t\t\t\t\t\tvalue += step;\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t}\r\n\r\n\tstatic rangeDown(\r\n\t\tstart:number,\r\n\t\tcount:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tstep = Math.abs(step)* -1;\r\n\r\n\t\treturn Enumerable.range(start, count, step);\r\n\t}\r\n\r\n\t// step = -1 behaves the same as toNegativeInfinity;\r\n\tstatic toInfinity(\r\n\t\tstart:number = 0,\r\n\t\tstep:number = 1):InfiniteEnumerable<number>\r\n\t{\r\n\t\tif(!isFinite(start))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\r\n\r\n\t\tif(!step)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\r\n\r\n\t\tif(!isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\r\n\r\n\t\treturn new InfiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet value:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = start;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet current:number = value;\r\n\t\t\t\t\t\tvalue += step;\r\n\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic toNegativeInfinity(\r\n\t\tstart:number = 0,\r\n\t\tstep:number = 1):InfiniteEnumerable<number>\r\n\t{\r\n\t\treturn Enumerable.toInfinity(start, -step);\r\n\t}\r\n\r\n\tstatic rangeTo(\r\n\t\tstart:number,\r\n\t\tto:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tif(isNaN(to) || !isFinite(to))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"to\", to, \"Must be a finite number.\");\r\n\r\n\t\tif(step && !isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite non-zero number.\");\r\n\r\n\t\t// This way we adjust for the delta from start and to so the user can say +/- step and it will work as expected.\r\n\t\tstep = Math.abs(step);\r\n\r\n\t\treturn new FiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet value:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(() => { value = start; },\r\n\t\t\t\t\tstart<to\r\n\t\t\t\t\t\t?\r\n\t\t\t\t\t\tyielder=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet result:boolean = value<=to && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\t\tif(result)\r\n\t\t\t\t\t\t\t\tvalue += step;\r\n\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t:\r\n\t\t\t\t\t\tyielder=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet result:boolean = value>=to && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\t\tif(result)\r\n\t\t\t\t\t\t\t\tvalue -= step;\r\n\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t, false);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic matches(\r\n\t\tinput:string, pattern:any,\r\n\t\tflags:string = \"\"):FiniteEnumerable<RegExpExecArray>\r\n\t{\r\n\t\tif(input===null || input===VOID0)\r\n\t\t\tthrow new ArgumentNullException(\"input\");\r\n\t\tvar type = typeof input;\r\n\t\tif(type!=Type.STRING)\r\n\t\t\tthrow new Error(\"Cannot exec RegExp matches of type '\" + type + \"'.\");\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tflags += (pattern.ignoreCase) ? \"i\" : \"\";\r\n\t\t\tflags += (pattern.multiline) ? \"m\" : \"\";\r\n\t\t\tpattern = pattern.source;\r\n\t\t}\r\n\r\n\t\tif(flags.indexOf(\"g\")=== -1) flags += \"g\";\r\n\r\n\t\treturn new FiniteEnumerable<RegExpExecArray>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet regex:RegExp;\r\n\t\t\t\treturn new EnumeratorBase<RegExpExecArray>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tregex = new RegExp(pattern, flags);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Calling regex.exec consecutively on the same input uses the lastIndex to start the next match.\r\n\t\t\t\t\t\tlet match = regex.exec(input);\r\n\t\t\t\t\t\treturn (match!==null) ? yielder.yieldReturn(match) : false;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic generate<T>(factory:(index?:number) => T):InfiniteEnumerable<T>;\r\n\tstatic generate<T>(factory:(index?:number) => T, count:number):FiniteEnumerable<T>;\r\n\tstatic generate<T>(\r\n\t\tfactory:(index?:number) => T,\r\n\t\tcount:number = Infinity):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\tif(isNaN(count) || count<=0)\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\treturn isFinite(count) && Integer.assert(count, \"count\")\r\n\t\t\t?\r\n\t\t\tnew FiniteEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet c:number = count;\r\n\t\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet current:number = index++;\r\n\t\t\t\t\t\t\treturn current<c && yielder.yieldReturn(factory(current));\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\t);\r\n\t\t\t\t})\r\n\t\t\t:\r\n\t\t\tnew InfiniteEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet index:number = 0;\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t(yielder)=> yielder.yieldReturn(factory(index++)),\r\n\r\n\t\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t}\r\n\r\n\tstatic unfold<T>(\r\n\t\tseed:T,\r\n\t\tvalueFactory:Selector<T, T>,\r\n\t\tskipSeed:Boolean = false):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet index:number = 0;\r\n\t\t\t\tlet value:T;\r\n\t\t\t\tlet isFirst:boolean;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tvalue = seed;\r\n\t\t\t\t\t\tisFirst = !skipSeed;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet i = index++;\r\n\t\t\t\t\t\tif(isFirst)\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tvalue = valueFactory(value, i);\r\n\t\t\t\t\t\treturn yielder.yieldReturn(value);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic forEach<T>(\r\n\t\tenumerable:IEnumerableOrArray<T>,\r\n\t\taction:(element:T, index?:number) => any,\r\n\t\tmax:number = Infinity):number\r\n\t{\r\n\t\t// Will properly dispose created enumerable.\r\n\t\t// Will throw if enumerable is endless.\r\n\t\treturn forEach(enumerable, action, max);\r\n\t}\r\n\r\n\tstatic map<T,TResult>(\r\n\t\tenumerable:IEnumerableOrArray<T>,\r\n\t\tselector:Selector<T,TResult>):TResult[]\r\n\t{\r\n\t\t// Will properly dispose created enumerable.\r\n\t\t// Will throw if enumerable is endless.\r\n\t\treturn map(enumerable, selector);\r\n\r\n\t}\r\n\r\n\t// Slightly optimized versions for numbers.\r\n\tstatic max(values:FiniteEnumerable<number>):number\r\n\t{\r\n\t\tvar v = values\r\n\t\t\t.takeUntil(v=> v== +Infinity, true)\r\n\t\t\t.aggregate(Functions.Greater);\r\n\r\n\t\treturn v===VOID0 ? NaN : v;\r\n\t}\r\n\r\n\tstatic min(values:FiniteEnumerable<number>):number\r\n\t{\r\n\t\tvar v = values\r\n\t\t\t.takeUntil(v=> v== -Infinity, true)\r\n\t\t\t.aggregate(Functions.Lesser);\r\n\r\n\t\treturn v===VOID0 ? NaN : v;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Takes any set of collections of the same type and weaves them together.\r\n\t * @param enumerables\r\n\t * @returns {Enumerable<T>}\r\n\t */\r\n\tstatic weave<T>(\r\n\t\tenumerables:IEnumerableOrArray<IEnumerableOrArray<T>>):Enumerable<T>\r\n\t{\r\n\t\tif(!enumerables)\r\n\t\t\tthrow new ArgumentNullException('enumerables');\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet queue:Queue<IEnumerator<T>>;\r\n\t\t\t\tlet mainEnumerator:IEnumerator<IEnumerableOrArray<T>>|null;\r\n\t\t\t\tlet index:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tqueue = new Queue<IEnumerator<T>>();\r\n\t\t\t\t\t\tmainEnumerator = enumeratorFrom(enumerables);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet e:IEnumerator<T>|null = null;\r\n\r\n\t\t\t\t\t\t// First pass...\r\n\t\t\t\t\t\tif(mainEnumerator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(!e && mainEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet c = mainEnumerator.current;\r\n\t\t\t\t\t\t\t\te = nextEnumerator(queue, c ? enumeratorFrom(c) : NULL);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!e)\r\n\t\t\t\t\t\t\t\tmainEnumerator = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\twhile(!e && queue.count)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\te = nextEnumerator(queue, queue.dequeue());\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn e\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(e.current)\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose.these(queue.dump());\r\n\t\t\t\t\t\tdispose(mainEnumerator, queue);\r\n\t\t\t\t\t\tmainEnumerator = null;\r\n\t\t\t\t\t\tqueue = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// Return a default (unfiltered) enumerable.\r\n\tasEnumerable():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\treturn <any> new Enumerable<T>(() => _.getEnumerator());\r\n\t}\r\n\r\n// #region Indexing/Paging methods.\r\n\r\n\tskipWhile(predicate:Predicate<T>):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t: EnumerableAction.Return\r\n\t\t);\r\n\t}\r\n\r\n\ttakeWhile(predicate:Predicate<T>):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException('predicate');\r\n\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t? EnumerableAction.Return\r\n\t\t\t\t\t: EnumerableAction.Break,\r\n\t\t\tnull,\r\n\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t);\r\n\t}\r\n\r\n\t// Is like the inverse of take While with the ability to return the value identified by the predicate.\r\n\ttakeUntil(predicate:Predicate<T>, includeUntilValue?:boolean):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException('predicate');\r\n\r\n\t\tif(!includeUntilValue)\r\n\t\t\treturn this.doAction(\r\n\t\t\t\t(element:T, index?:number) =>\r\n\t\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t\t? EnumerableAction.Break\r\n\t\t\t\t\t\t: EnumerableAction.Return,\r\n\t\t\t\tnull,\r\n\t\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t\t);\r\n\r\n\t\tlet found:boolean = false;\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t{\r\n\t\t\t\tif(found)\r\n\t\t\t\t\treturn EnumerableAction.Break;\r\n\r\n\t\t\t\tfound = predicate(element, index);\r\n\t\t\t\treturn EnumerableAction.Return;\r\n\t\t\t},\r\n\t\t\t()=>\r\n\t\t\t{\r\n\t\t\t\tfound = false;\r\n\t\t\t},\r\n\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tthrowIfEndless(_.isEndless);\r\n\r\n\t\tvar index:number = 0;\r\n\t\t// Return value of action can be anything, but if it is (===) false then the forEach will discontinue.\r\n\t\tusing(\r\n\t\t\t_.getEnumerator(), e=>\r\n\t\t\t{\r\n\t\t\t\tthrowIfEndless(e.isEndless);\r\n\r\n\t\t\t\t// It is possible that subsequently 'action' could cause the enumeration to dispose, so we have to check each time.\r\n\t\t\t\twhile(_.throwIfDisposed() && e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(action(<T>e.current, index++)===false)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #region Conversion Methods\r\n\ttoArray(predicate?:Predicate<T>):T[]\r\n\t{\r\n\t\treturn predicate\r\n\t\t\t? this.where(predicate).toArray()\r\n\t\t\t: this.copyTo([]);\r\n\t}\r\n\r\n\tcopyTo(target:T[], index:number = 0, count:number = Infinity):T[]\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(!target) throw new ArgumentNullException(\"target\");\r\n\t\tInteger.assertZeroOrGreater(index);\r\n\r\n\t\t// If not exposing an action that could cause dispose, then use forEach utility instead.\r\n\t\tforEach<T>(this, (x, i)=>\r\n\t\t{\r\n\t\t\ttarget[i + index] = x\r\n\t\t}, count);\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\ttoLookup<TKey, TValue, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TValue> = Functions.Identity,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):ILookup<TKey, TValue>\r\n\t{\r\n\t\tvar dict:Dictionary<TKey, TValue[]> = new Dictionary<TKey, TValue[]>(compareSelector);\r\n\t\tthis.forEach(\r\n\t\t\tx=>\r\n\t\t\t{\r\n\t\t\t\tlet key = keySelector(x);\r\n\t\t\t\tlet element = elementSelector(x);\r\n\r\n\t\t\t\tlet array = dict.getValue(key);\r\n\t\t\t\tif(array!==VOID0) array.push(element);\r\n\t\t\t\telse dict.addByKeyValue(key, [element]);\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn new Lookup<TKey, TValue>(dict);\r\n\t}\r\n\r\n\ttoMap<TResult>(\r\n\t\tkeySelector:Selector<T, string>,\r\n\t\telementSelector:Selector<T, TResult>):IMap<TResult>\r\n\t{\r\n\t\tvar obj:IMap<TResult> = {};\r\n\t\tthis.forEach((x, i)=>\r\n\t\t{\r\n\t\t\tobj[keySelector(x, i)] = elementSelector(x, i);\r\n\t\t});\r\n\t\treturn obj;\r\n\t}\r\n\r\n\ttoDictionary<TKey, TValue, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TValue>,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):IDictionary<TKey, TValue>\r\n\t{\r\n\t\tvar dict:Dictionary<TKey, TValue> = new Dictionary<TKey, TValue>(compareSelector);\r\n\t\tthis.forEach((x, i)=> dict.addByKeyValue(keySelector(x, i), elementSelector(x, i)));\r\n\t\treturn dict;\r\n\t}\r\n\r\n\ttoJoinedString(separator:string = \"\", selector:Selector<T, string> = Functions.Identity)\r\n\t{\r\n\t\treturn this\r\n\t\t\t.select(selector)\r\n\t\t\t.toArray()\r\n\t\t\t.join(separator);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\ttakeExceptLast(count:number = 1):this\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!(count>0)) // Out of bounds?\r\n\t\t\treturn _;\r\n\r\n\t\tif(!isFinite(count)) // +Infinity equals skip all so return empty.\r\n\t\t\treturn <any> Enumerable.empty<T>();\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\t\tvar c = count;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet q:Queue<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tq = new Queue<T>();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Add the next one to the queue.\r\n\t\t\t\t\t\t\tq.enqueue(<T>enumerator.current);\r\n\r\n\t\t\t\t\t\t\t// Did we reach our quota?\r\n\t\t\t\t\t\t\tif(q.count>c)\r\n\t\t\t\t\t\t\t// Okay then, start returning results.\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(q.dequeue());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, q);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tskipToLast(count:number):this\r\n\t{\r\n\t\tif(!(count>0)) // Out of bounds? Empty.\r\n\t\t\treturn <any> Enumerable.empty<T>();\r\n\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!isFinite(count)) // Infinity means return all.\r\n\t\t\treturn _;\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\t// This sets up the query so nothing is done until move next is called.\r\n\t\treturn <any> _.reverse()\r\n\t\t\t.take(count)\r\n\t\t\t.reverse();\r\n\t}\r\n\r\n\t// To help with type guarding.\r\n\r\n\tselect<TResult>(selector:Selector<T, TResult>):Enumerable<TResult>\r\n\t{\r\n\t\treturn <Enumerable<TResult>>super.select(selector);\r\n\t}\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TResult>>):Enumerable<TResult>;\r\n\r\n\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector:(collection:T, element:TElement)=>TResult):Enumerable<TResult>;\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<any>>,\r\n\t\tresultSelector?:(collection:T, element:any)=>TResult):Enumerable<TResult>\r\n\t{\r\n\t\treturn this._selectMany(collectionSelector, resultSelector);\r\n\t}\r\n\r\n\tchoose():Enumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):Enumerable<TResult>\r\n\tchoose(selector:Selector<T, any> = Functions.Identity):Enumerable<any>\r\n\t{\r\n\t\treturn this._choose(selector);\r\n\t}\r\n\r\n\treverse():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\t\tthrowIfEndless(_._isEndless); // Cannot reverse an endless collection...\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet buffer:T[];\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tbuffer = _.toArray();\r\n\t\t\t\t\t\tindex = buffer.length;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=> !!index && yielder.yieldReturn(buffer[--index]),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tshuffle():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed = !_.throwIfDisposed();\r\n\t\tthrowIfEndless(_._isEndless); // Cannot shuffle an endless collection...\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet buffer:T[];\r\n\t\t\t\tlet capacity:number;\r\n\t\t\t\tlet len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tbuffer = _.toArray();\r\n\t\t\t\t\t\tcapacity = len = buffer.length;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Avoid using major array operations like .slice();\r\n\t\t\t\t\t\tif(!len)\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\tlet selectedIndex = Integer.random(len);\r\n\t\t\t\t\t\tlet selectedValue = buffer[selectedIndex];\r\n\r\n\t\t\t\t\t\tbuffer[selectedIndex] = buffer[--len]; // Take the last one and put it here.\r\n\t\t\t\t\t\tbuffer[len] = NULL; // clear possible reference.\r\n\r\n\t\t\t\t\t\tif(len%32==0) // Shrink?\r\n\t\t\t\t\t\t\tbuffer.length = len;\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(selectedValue);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tcount(predicate?:Predicate<T>):number\r\n\t{\r\n\t\tvar count:number = 0;\r\n\t\tthis.forEach(\r\n\t\t\tpredicate\r\n\r\n\t\t\t\t?\r\n\t\t\t\t(x, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(predicate(x, i))++count;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t:\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\t++count;\r\n\t\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\t// Akin to '.every' on an array.\r\n\tall(predicate:Predicate<T>):boolean\r\n\t{\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException(\"predicate\");\r\n\r\n\t\tvar result = true;\r\n\t\tthis.forEach((x, i) =>\r\n\t\t{\r\n\t\t\tif(!predicate(x, i))\r\n\t\t\t{\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn false; // break\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// 'every' has been added here for parity/compatibility with an array.\r\n\tevery(predicate:Predicate<T>):boolean\r\n\t{\r\n\t\treturn this.all(predicate);\r\n\t}\r\n\r\n\t// Akin to '.some' on an array.\r\n\tany(predicate?:Predicate<T>):boolean\r\n\t{\r\n\t\tif(!predicate)\r\n\t\t\treturn super.any();\r\n\r\n\t\tvar result = false;\r\n\t\t// Splitting the forEach up this way reduces iterative processing.\r\n\t\t// forEach handles the generation and disposal of the enumerator.\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\tresult = predicate(x, i); // false = not found and therefore it should continue.  true = found and break;\r\n\t\t\t\treturn !result;\r\n\t\t\t});\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t// 'some' has been added here for parity/compatibility with an array.\r\n\tsome(predicate:Predicate<T>):boolean\r\n\t{\r\n\t\treturn this.any(predicate);\r\n\t}\r\n\r\n\r\n\tcontains<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):boolean\r\n\t{\r\n\t\treturn compareSelector\r\n\t\t\t? this.any(v=> compareSelector(v)===compareSelector(value))\r\n\t\t\t: this.any(v=> v===value);\r\n\t}\r\n\r\n\t// Originally has an overload for a predicate,\r\n\t// but that's a bad idea since this could be an enumeration of functions and therefore fail the intent.\r\n\t// Better to chain a where statement first to be more explicit.\r\n\tindexOf<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):number\r\n\t{\r\n\t\tvar found:number = -1;\r\n\t\tthis.forEach(\r\n\t\t\tcompareSelector\r\n\t\t\t\t?\r\n\t\t\t\t(element:T, i:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Values.areEqual(compareSelector(element, i), compareSelector(value, i), true))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfound = i;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t:\r\n\t\t\t\t(element:T, i:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\t// Why?  Because NaN doesn't equal NaN. :P\r\n\t\t\t\t\tif(Values.areEqual(element, value, true))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfound = i;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\r\n\t\treturn found;\r\n\t}\r\n\r\n\tlastIndexOf<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):number\r\n\t{\r\n\t\tvar result:number = -1;\r\n\t\tthis.forEach(\r\n\t\t\tcompareSelector\r\n\t\t\t\t?\r\n\t\t\t\t(element:T, i:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Values.areEqual(compareSelector(element, i), compareSelector(value, i), true)) result\r\n\t\t\t\t\t\t= i;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t:\r\n\t\t\t\t(element:T, i:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Values.areEqual(element, value, true)) result = i;\r\n\t\t\t\t});\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\r\n\tintersect<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _.isEndless;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet keys:Dictionary<T,boolean>;\r\n\t\t\t\tlet outs:Dictionary<T,boolean>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tkeys = new Dictionary<T, boolean>(compareSelector);\r\n\t\t\t\t\t\touts = new Dictionary<T, boolean>(compareSelector);\r\n\r\n\t\t\t\t\t\tforEach(second, key=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tkeys.addByKeyValue(key, true);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet current = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(!outs.containsKey(current) && keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\touts.addByKeyValue(current, true);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, keys, outs);\r\n\t\t\t\t\t},\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tsequenceEqual(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n\t{\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te1=> using(\r\n\t\t\t\tenumeratorFrom(second),\r\n\t\t\t\te2=>\r\n\t\t\t\t{\r\n\t\t\t\t\t// if both are endless, this will never evaluate.\r\n\t\t\t\t\tthrowIfEndless(e1.isEndless && e2.isEndless);\r\n\r\n\t\t\t\t\twhile(e1.moveNext())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(!e2.moveNext() || !equalityComparer(<T>e1.current, <T>e2.current))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn !e2.moveNext();\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t//isEquivalent(second:IEnumerableOrArray<T>,\r\n\t//\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n\t//{\r\n\t//\treturn this\r\n\t//\t\t.orderBy(keySelector)\r\n\t//\t\t.sequenceEqual(Enumerable.from(second).orderBy(keySelector))\r\n\t//}\r\n\r\n\r\n\t// #endregion\r\n\r\n\r\n\tofType<TType>(type:{ new (...params:any[]):TType }):Enumerable<TType>;\r\n\tofType<TType>(type:any):Enumerable<TType>\r\n\t{\r\n\t\treturn <Enumerable<TType>>super.ofType(type);\r\n\t}\r\n\r\n// #region Ordering Methods\r\n\r\n\torderBy<TKey extends Comparable>(keySelector:Selector<T, TKey> = Functions.Identity):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,TKey>(this, keySelector, Order.Ascending);\r\n\t}\r\n\r\n\torderUsing(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this, null, Order.Ascending, null, comparison);\r\n\t}\r\n\r\n\torderUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this, null, Order.Descending, null, comparison);\r\n\t}\r\n\r\n\torderByDescending<TKey extends Comparable>(keySelector:Selector<T, TKey> = Functions.Identity):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,TKey>(this, keySelector, Order.Descending);\r\n\t}\r\n\r\n\t/*\r\n\t\t weightedSample(weightSelector) {\r\n\t\t weightSelector = Utils.createLambda(weightSelector);\r\n\t\t var source = this;\r\n\r\n\t\t return new Enumerable<T>(() => {\r\n\t\t var sortedByBound;\r\n\t\t var totalWeight = 0;\r\n\r\n\t\t return new EnumeratorBase<T>(\r\n\t\t () => {\r\n\t\t sortedByBound = source\r\n\t\t .choose(function (x) {\r\n\t\t var weight = weightSelector(x);\r\n\t\t if (weight <= 0) return null; // ignore 0\r\n\r\n\t\t totalWeight += weight;\r\n\t\t return { value: x, bound: totalWeight }\r\n\t\t })\r\n\t\t .toArray();\r\n\t\t },\r\n\t\t () => {\r\n\t\t if (sortedByBound.length > 0) {\r\n\t\t var draw = (Math.random() * totalWeight) + 1;\r\n\r\n\t\t var lower = -1;\r\n\t\t var upper = sortedByBound.length;\r\n\t\t while (upper - lower > 1) {\r\n\t\t var index = ((lower + upper) / 2);\r\n\t\t if (sortedByBound[index].bound >= draw) {\r\n\t\t upper = index;\r\n\t\t }\r\n\t\t else {\r\n\t\t lower = index;\r\n\t\t }\r\n\t\t }\r\n\r\n\t\t return (<any>this).yieldReturn(sortedByBound[upper].value);\r\n\t\t }\r\n\r\n\t\t return (<any>this).yieldBreak();\r\n\t\t },\r\n\t\t Functions.Blank);\r\n\t\t });\r\n\t\t }\r\n\t\t */\r\n\t// #endregion\r\n\r\n\tbuffer(size:number):Enumerable<T[]>\r\n\t{\r\n\t\treturn <Enumerable<T[]>>super.buffer(size);\r\n\t}\r\n\r\n\t// #region Grouping Methods\r\n\r\n\t// Originally contained a result selector (not common use), but this could be done simply by a select statement after.\r\n\r\n\r\n\tgroupBy<TKey>(keySelector:Selector<T, TKey>):Enumerable<IGrouping<TKey, T>>;\r\n\tgroupBy<TKey, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, T>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, T>>;\r\n\tgroupBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, TElement>>\r\n\t{\r\n\t\tif(!elementSelector) elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\r\n\t\treturn new Enumerable<IGrouping<TKey, TElement>>(\r\n\t\t\t() => this\r\n\t\t\t\t.toLookup(keySelector, elementSelector, compareSelector)\r\n\t\t\t\t.getEnumerator()\r\n\t\t);\r\n\t}\r\n\r\n\tpartitionBy<TKey>(keySelector:Selector<T, TKey>):Enumerable<IGrouping<TKey, T>>;\r\n\tpartitionBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TElement>,\r\n\t\tresultSelector?:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, TElement>>;\r\n\tpartitionBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TElement>,\r\n\t\tresultSelector:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>\r\n\t\t\t= (key:TKey, elements:TElement[]) => new Grouping<TKey, TElement>(key, elements),\r\n\t\tcompareSelector:Selector<TKey, TCompare>\r\n\t\t\t= Functions.Identity):Enumerable<IGrouping<TKey, T>>|Enumerable<IGrouping<TKey, TElement>>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tif(!elementSelector) elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\r\n\t\treturn new Enumerable<IGrouping<TKey, TElement>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet key:TKey;\r\n\t\t\t\tlet compareKey:TCompare;\r\n\t\t\t\tlet group:TElement[]|null;\r\n\t\t\t\tlet len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<IGrouping<TKey, TElement>>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet v = <T>enumerator.current;\r\n\t\t\t\t\t\t\tkey = keySelector(v);\r\n\t\t\t\t\t\t\tcompareKey = compareSelector(key);\r\n\t\t\t\t\t\t\tgroup = [elementSelector!(v)];\r\n\t\t\t\t\t\t\tlen = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(!group)\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\tlet hasNext:boolean, c:T;\r\n\t\t\t\t\t\twhile((hasNext = enumerator.moveNext()))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(compareKey===compareSelector(keySelector(c)))\r\n\t\t\t\t\t\t\t\tgroup[len++] = elementSelector!(c);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet result:IGrouping<TKey, TElement>\r\n\t\t\t\t\t\t\t    = resultSelector(key, group);\r\n\r\n\t\t\t\t\t\tif(hasNext)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc = <T>enumerator.current;\r\n\t\t\t\t\t\t\tkey = keySelector(c);\r\n\t\t\t\t\t\t\tcompareKey = compareSelector(key);\r\n\t\t\t\t\t\t\tgroup = [elementSelector!(c)];\r\n\t\t\t\t\t\t\tlen = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region Aggregate Methods\r\n\r\n\taggregate(\r\n\t\tfunc:(a:T, b:T) => T,\r\n\t\tseed?:T):T|undefined\r\n\t{\r\n\t\treturn this\r\n\t\t\t.scan(func, seed)\r\n\t\t\t.lastOrDefault();\r\n\t}\r\n\r\n\taverage(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar count = 0;\r\n\t\tvar sum = this.sum((e, i)=>\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\treturn selector(e, i);\r\n\t\t});\r\n\r\n\t\treturn (isNaN(sum) || !count)\r\n\t\t\t? NaN\r\n\t\t\t: (sum/count);\r\n\t}\r\n\r\n\t// If using numbers, it may be useful to call .takeUntil(v=>v==Infinity,true) before calling max. See static versions for numbers.\r\n\tmax():T|undefined\r\n\t{\r\n\t\treturn this.aggregate(Functions.Greater);\r\n\t}\r\n\r\n\tmin():T|undefined\r\n\t{\r\n\t\treturn this.aggregate(Functions.Lesser);\r\n\t}\r\n\r\n\tmaxBy<TCompare>(keySelector:Selector<T, TCompare> = Functions.Identity):T|undefined\r\n\t{\r\n\t\treturn this.aggregate((a:T, b:T) => (keySelector(a)>keySelector(b)) ? a : b);\r\n\t}\r\n\r\n\tminBy<TCompare>(keySelector:Selector<T, TCompare> = Functions.Identity):T|undefined\r\n\t{\r\n\t\treturn this.aggregate((a:T, b:T) => (keySelector(a)<keySelector(b)) ? a : b);\r\n\t}\r\n\r\n\t// Addition...  Only works with numerical enumerations.\r\n\tsum(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar sum = 0;\r\n\r\n\t\t// This allows for infinity math that doesn't destroy the other values.\r\n\t\tvar sumInfinite = 0; // Needs more investigation since we are really trying to retain signs.\r\n\r\n\t\tthis.forEach(\r\n\t\t\tx=>\r\n\t\t\t{\r\n\t\t\t\tlet value = selector(x);\r\n\t\t\t\tif(isNaN(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tsum = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif(isFinite(value))\r\n\t\t\t\t\tsum += value;\r\n\t\t\t\telse\r\n\t\t\t\t\tsumInfinite +=\r\n\t\t\t\t\t\tvalue>0 ?\r\n\t\t\t\t\t\t\t(+1) :\r\n\t\t\t\t\t\t\t(-1);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn isNaN(sum) ? NaN : (sumInfinite ? (sumInfinite*Infinity) : sum);\r\n\t}\r\n\r\n\t// Multiplication...\r\n\tproduct(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar result = 1, exists:boolean = false;\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i)=>\r\n\t\t\t{\r\n\t\t\t\texists = true;\r\n\t\t\t\tlet value = selector(x, i);\r\n\t\t\t\tif(isNaN(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(value==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = 0; // Multiplying by zero will always end in zero.\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Multiplication can never recover from infinity and simply must retain signs.\r\n\t\t\t\t// You could cancel out infinity with 1/infinity but no available representation exists.\r\n\t\t\t\tresult *= value;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn (exists && isNaN(result)) ? NaN : result;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes the first number and divides it by all following.\r\n\t * @param selector\r\n\t * @returns {number}\r\n\t */\r\n\tquotient(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar count = 0;\r\n\t\tvar result:number = NaN;\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i)=>\r\n\t\t\t{\r\n\t\t\t\tlet value = selector(x, i);\r\n\t\t\t\tcount++;\r\n\r\n\t\t\t\tif(count===1)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = value;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(isNaN(value) || value===0 || !isFinite(value))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult /= value;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif(count===1)\r\n\t\t\tresult = NaN;\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region Single Value Return...\r\n\r\n\tlast():T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar value:T|undefined = VOID0;\r\n\t\tvar found:boolean = false;\r\n\t\t_.forEach(\r\n\t\t\tx =>\r\n\t\t\t{\r\n\t\t\t\tfound = true;\r\n\t\t\t\tvalue = x;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif(!found) throw new Error(\"last:No element satisfies the condition.\");\r\n\t\treturn <any>value;\r\n\t}\r\n\r\n\tlastOrDefault(defaultValue?:T):T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar value:T|undefined = VOID0;\r\n\t\tvar found:boolean = false;\r\n\t\t_.forEach(\r\n\t\t\tx=>\r\n\t\t\t{\r\n\t\t\t\tfound = true;\r\n\t\t\t\tvalue = x;\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn (!found) ? defaultValue : value;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tmemoize():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar disposed:boolean = !_.throwIfDisposed();\r\n\r\n\t\tvar cache:T[];\r\n\t\tvar enumerator:IEnumerator<T>;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tif(!enumerator)\r\n\t\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tif(!cache)\r\n\t\t\t\t\t\t\tcache = [];\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tlet i = index++;\r\n\r\n\t\t\t\t\t\tif(i>=cache.length)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t\t? yielder.yieldReturn(cache[i] = <T>enumerator.current)\r\n\t\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(cache[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t\tif(cache)\r\n\t\t\t\t\tcache.length = 0;\r\n\t\t\t\tcache = NULL;\r\n\r\n\t\t\t\tdispose(enumerator);\r\n\t\t\t\tenumerator = NULL;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n// Provided for type guarding.\r\nexport class FiniteEnumerable<T>\r\nextends Enumerable<T> implements IFiniteEnumerable<T>\r\n{\r\n\tconstructor(\r\n\t\tenumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:Closure)\r\n\t{\r\n\t\tsuper(enumeratorFactory, finalizer, false);\r\n\t}\r\n\r\n}\r\n\r\nclass ArrayEnumerable<T>\r\nextends FiniteEnumerable<T>\r\n{\r\n\tprivate _source:IArray<T>;\r\n\r\n\tconstructor(source:IArray<T>)\r\n\t{\r\n\t\tsuper(() =>\r\n\t\t{\r\n\t\t\t_.throwIfDisposed();\r\n\t\t\treturn new ArrayEnumerator<T>(() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed(\"The underlying ArrayEnumerable was disposed.\", \"ArrayEnumerator\");\r\n\r\n\t\t\t\treturn _._source; // Should never be null, but ArrayEnumerable if not disposed simply treats null as empty array.\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tconst _ = this;\r\n\t\t_._disposableObjectName = \"ArrayEnumerable\";\r\n\t\t_._source = source;\r\n\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._source = NULL;\r\n\t}\r\n\r\n\tget source():IArray<T>\r\n\t{\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn toArray(_._source);\r\n\t}\r\n\r\n\tasEnumerable():this\r\n\t{\r\n\t\treturn <any> new ArrayEnumerable<T>(this._source);\r\n\t}\r\n\r\n\t// Optimize forEach so that subsequent usage is optimized.\r\n\tforEach(action:Predicate<T> | Action<T>, max:number = Infinity):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn forEach(_._source, action, max);\r\n\t}\r\n\r\n\t// These methods should ALWAYS check for array length before attempting anything.\r\n\r\n\tany(predicate?:Predicate<T>):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn !!len && (!predicate || super.any(predicate));\r\n\t}\r\n\r\n\tcount(predicate?:Predicate<T>):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn len && (predicate ? super.count(predicate) : len);\r\n\t}\r\n\r\n\telementAtOrDefault(index:number, defaultValue?:T):T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\r\n\t\tvar source = _._source;\r\n\t\treturn index<source.length\r\n\t\t\t? source[index]\r\n\t\t\t: defaultValue;\r\n\t}\r\n\r\n\tlast():T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn (len)\r\n\t\t\t? source[len - 1]\r\n\t\t\t: super.last();\r\n\t}\r\n\r\n\tlastOrDefault(defaultValue?:T):T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn len\r\n\t\t\t? source[len - 1]\r\n\t\t\t: defaultValue;\r\n\t}\r\n\r\n\tskip(count:number):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn _;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() => new ArrayEnumerator<T>(() => _._source, count)\r\n\t\t);\r\n\t}\r\n\r\n\ttakeExceptLast(count:number = 1):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\treturn <any> _.take(_._source.length - count);\r\n\t}\r\n\r\n\tskipToLast(count:number):this\r\n\t{\r\n\t\tif(!(count>0))\r\n\t\t\treturn <any> Enumerable.empty<T>();\r\n\r\n\t\tconst _ = this;\r\n\t\tif(!isFinite(count))\r\n\t\t\treturn _;\r\n\r\n\t\tvar len = _._source\r\n\t\t\t? _._source.length\r\n\t\t\t: 0;\r\n\r\n\t\treturn <any> _.skip(len - count);\r\n\t}\r\n\r\n\treverse():this\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\treturn <any> new Enumerable<T>(\r\n\t\t\t() => new ArrayEnumerator<T>(\r\n\t\t\t\t() => _._source, _._source\r\n\t\t\t\t\t? (_._source.length - 1)\r\n\t\t\t\t\t: 0, -1\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tmemoize():this\r\n\t{\r\n\t\treturn this.asEnumerable();\r\n\t}\r\n\r\n\tsequenceEqual(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n\t{\r\n\t\tif(Type.isArrayLike(second))\r\n\t\t\treturn Arrays.areEqual(this.source, second, true, equalityComparer);\r\n\r\n\t\tif(second instanceof ArrayEnumerable)\r\n\t\t\treturn second.sequenceEqual(this.source, equalityComparer);\r\n\r\n\t\treturn super.sequenceEqual(second, equalityComparer);\r\n\t}\r\n\r\n\r\n\ttoJoinedString(separator:string = \"\", selector:Selector<T, string> = Functions.Identity)\r\n\t{\r\n\t\tvar s = this._source;\r\n\t\treturn !selector && Array.isArray(s)\r\n\t\t\t? (<Array<T>>s).join(separator)\r\n\t\t\t: super.toJoinedString(separator, selector);\r\n\t}\r\n\r\n}\r\n\r\nclass Grouping<TKey, TElement>\r\nextends ArrayEnumerable<TElement> implements IGrouping<TKey, TElement>\r\n{\r\n\r\n\tconstructor(private _groupKey:TKey, elements:TElement[])\r\n\t{\r\n\t\tsuper(elements);\r\n\t}\r\n\r\n\tget key():TKey\r\n\t{\r\n\t\treturn this._groupKey;\r\n\t}\r\n}\r\n\r\nclass Lookup<TKey, TElement>\r\nimplements ILookup<TKey, TElement>\r\n{\r\n\r\n\tconstructor(private _dictionary:IDictionary<TKey, TElement[]>)\r\n\t{\r\n\t}\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this._dictionary.count;\r\n\t}\r\n\r\n\tget(key:TKey):TElement[]\r\n\t{\r\n\t\treturn this._dictionary.getValue(key);\r\n\t}\r\n\r\n\tcontains(key:TKey):boolean\r\n\t{\r\n\t\treturn this._dictionary.containsKey(key);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<Grouping<TKey, TElement>>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tvar enumerator:IEnumerator<IKeyValuePair<TKey, TElement[]>>;\r\n\r\n\t\treturn new EnumeratorBase<Grouping<TKey, TElement>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tenumerator = _._dictionary.getEnumerator();\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(!enumerator.moveNext())\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\tlet current = <IKeyValuePair<TKey, TElement[]>>enumerator.current;\r\n\t\t\t\treturn yielder.yieldReturn(new Grouping<TKey, TElement>(current.key, current.value));\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdispose(enumerator);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n}\r\n\r\n\r\nclass OrderedEnumerable<T,TOrderBy extends Comparable>\r\nextends FiniteEnumerable<T> implements IOrderedEnumerable<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tprivate source:IEnumerable<T>,\r\n\t\tpublic keySelector:Selector<T,TOrderBy>|null,\r\n\t\tpublic order:Order,\r\n\t\tpublic parent?:OrderedEnumerable<T,any>|null,\r\n\t\tpublic comparer:Comparison<T> = Values.compare)\r\n\t{\r\n\t\tsuper(NULL);\r\n\t\tthrowIfEndless(!!source && !!source.isEndless);\r\n\t}\r\n\r\n\tprivate createOrderedEnumerable(\r\n\t\tkeySelector:Selector<T,TOrderBy>,\r\n\t\torder:Order):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,TOrderBy>(this.source, keySelector, order, this);\r\n\t}\r\n\r\n\tthenBy(keySelector:(value:T) => TOrderBy):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn this.createOrderedEnumerable(keySelector, Order.Ascending);\r\n\t}\r\n\r\n\tthenUsing(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this.source, null, Order.Ascending, this, comparison);\r\n\t}\r\n\r\n\tthenByDescending(keySelector:(value:T) => TOrderBy):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn this.createOrderedEnumerable(keySelector, Order.Descending);\r\n\t}\r\n\r\n\tthenUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this.source, null, Order.Descending, this, comparison);\r\n\t}\r\n\r\n\tgetEnumerator():EnumeratorBase<T>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tvar buffer:T[];\r\n\t\tvar indexes:number[];\r\n\t\tvar index:number = 0;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tindex = 0;\r\n\t\t\t\tbuffer = Enumerable.toArray(_.source);\r\n\t\t\t\tindexes = createSortContext(_)\r\n\t\t\t\t\t.generateSortedIndexes(buffer);\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\treturn (index<indexes.length)\r\n\t\t\t\t\t? yielder.yieldReturn(buffer[indexes[index++]])\r\n\t\t\t\t\t: false;\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tif(buffer)\r\n\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\tbuffer = NULL;\r\n\t\t\t\tif(indexes)\r\n\t\t\t\t\tindexes.length = 0;\r\n\t\t\t\tindexes = NULL;\r\n\t\t\t},\r\n\r\n\t\t\tfalse\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tconst _:this = this;\r\n\t\tsuper._onDispose();\r\n\t\t_.source = NULL;\r\n\t\t_.keySelector = NULL;\r\n\t\t_.order = NULL;\r\n\t\t_.parent = NULL;\r\n\t}\r\n\r\n}\r\n\r\n// A private static helper for the weave function.\r\nfunction nextEnumerator<T>(queue:Queue<IEnumerator<T>>, e:IEnumerator<T>):IEnumerator<T>|null\r\n{\r\n\tif(e)\r\n\t{\r\n\t\tif(e.moveNext())\r\n\t\t{\r\n\t\t\tqueue.enqueue(e);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdispose(e);\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\treturn e;\r\n}\r\n\r\n/**\r\n * Recursively builds a SortContext chain.\r\n * @param orderedEnumerable\r\n * @param currentContext\r\n * @returns {any}\r\n */\r\nfunction createSortContext<T, TOrderBy extends Comparable>(\r\n\torderedEnumerable:OrderedEnumerable<T,TOrderBy>,\r\n\tcurrentContext:IComparer<T>|null = null):KeySortedContext<T, TOrderBy>\r\n{\r\n\r\n\tvar context = new KeySortedContext<T, TOrderBy>(\r\n\t\tcurrentContext,\r\n\t\torderedEnumerable.keySelector,\r\n\t\torderedEnumerable.order,\r\n\t\torderedEnumerable.comparer);\r\n\r\n\tif(orderedEnumerable.parent)\r\n\t\treturn createSortContext(orderedEnumerable.parent, context);\r\n\r\n\treturn context;\r\n}\r\n\r\n// #region Helper Functions...\r\n// This allows for the use of a boolean instead of calling this.throwIfDisposed()\r\n// since there is a strong chance of introducing a circular reference.\r\nfunction throwIfDisposed(disposed:boolean):void\r\n{\r\n\tif(disposed) throw new ObjectDisposedException(\"Enumerable\");\r\n}\r\n// #endregion\r\n\r\nexport default Enumerable;\r\n"]}