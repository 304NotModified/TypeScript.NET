{"version":3,"sources":["System/Collections/LinkedNodeList.ts"],"names":[],"mappings":"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","file":"System/Collections/LinkedNodeList.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as TextUtility from \"../Text/Utility\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {EnumeratorBase} from \"./Enumeration/EnumeratorBase\";\r\nimport {ILinkedNode, ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerateEach} from \"./Enumeration/IEnumerateEach\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\nimport {ILinkedNodeList} from \"./ILinkedList\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {Predicate, Selector, Action} from \"../FunctionTypes\";\r\nimport {IArray} from \"./Array/IArray\";\r\nimport __extendsImport from \"../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport class LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IEnumerateEach<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode;\r\n\tprivate _last:TNode;\r\n\tunsafeCount:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t\tthis.unsafeCount = 0;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t */\r\n\tget first():TNode\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t */\r\n\tget last():TNode\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t// Note, no need for 'useCopy' since this avoids any modification conflict.\r\n\t// If iterating over a copy is necessary, a copy should be made manually.\r\n\tforEach(\r\n\t\taction:Predicate<TNode> | Action<TNode>):number\r\n\t{\r\n\t\tvar current:TNode = null,\r\n\t\t    next:TNode    = this.first, // Be sure to track the next node so if current node is removed.\r\n\t\t    index:number  = 0;\r\n\r\n\t\tdo {\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current && current.next;\r\n\t\t}\r\n\t\twhile(current\r\n\t\t&& <any>action(current, index++)!==false);\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\tmap<T>(selector:Selector<TNode,T>):T[]\r\n\t{\r\n\t\tif(!selector) throw new ArgumentNullException('selector');\r\n\r\n\t\tvar result:T[] = [];\r\n\t\tthis.forEach(node=>\r\n\t\t{\r\n\t\t\tresult.push(selector(node));\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, n:TNode, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcF++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.next;\r\n\t\t\tcurrent.next = null;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcL++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.previous;\r\n\t\t\tcurrent.previous = null;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\r\n\r\n\t\t_.unsafeCount = 0;\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!= -1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t */\r\n\tgetNodeAt(index:number):TNode\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && i++<index)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tfind(condition:Predicate<TNode>):TNode {\r\n\t\tvar node:TNode = null;\r\n\t\tthis.forEach((n,i)=>{\r\n\t\t\tif(condition(n,i)) {\r\n\t\t\t\tnode = n;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number\r\n\t{\r\n\t\tif(node && (node.previous || node.next))\r\n\t\t{\r\n\r\n\t\t\tvar index = 0;\r\n\t\t\tvar c:TNode, n:TNode = this._first;\r\n\t\t\tdo {\r\n\t\t\t\tc = n;\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\twhile((n = c && c.next));\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tvar _ = this;\r\n\t\tvar prev = node.previous, next = node.next, a:boolean = false, b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tvar removed = !a && !b;\r\n\t\tif(removed) {\r\n\t\t\t_.unsafeCount--;\r\n\t\t\tnode.previous = null;\r\n\t\t\tnode.next = null;\r\n\t\t}\r\n\t\treturn removed;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t */\r\n\taddNode(node:TNode):void\r\n\t{\r\n\t\tthis.addNodeAfter(node);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t */\r\n\taddNodeBefore(node:TNode, before?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!before)\r\n\t\t{\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before)\r\n\t\t{\r\n\t\t\tlet prev = before.previous;\r\n\t\t\tnode.previous = prev;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(prev) prev.next = node;\r\n\t\t\tif(before==_._first) _._first = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_.unsafeCount++;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t */\r\n\taddNodeAfter(node:TNode, after?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!after)\r\n\t\t{\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after)\r\n\t\t{\r\n\t\t\tlet next = after.next;\r\n\t\t\tnode.next = next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(next) next.previous = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_.unsafeCount++;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):void\r\n\t{\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tassertValidDetached(replacement, 'replacement');\r\n\r\n\t\tvar _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\t}\r\n\r\n\tstatic valueEnumeratorFrom<T>(list:LinkedNodeList<ILinkedNodeWithValue<T>>):IEnumerator<T> {\r\n\r\n\t\tif(!list) throw new ArgumentNullException('list');\r\n\r\n\t\tvar _ = this,\r\n\t\t    current:ILinkedNodeWithValue<T>,\r\n\t\t    next:ILinkedNodeWithValue<T>;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = list.first;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic copyValues<T,TDestination extends IArray<any>>(\r\n\t\tlist:LinkedNodeList<ILinkedNodeWithValue<T>>,\r\n\t\tarray:TDestination,\r\n\t\tindex:number = 0):TDestination\r\n\t{\r\n\t\tif(list && list.first)\r\n\t\t{\r\n\t\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t\tlist.forEach(\r\n\t\t\t\t(node, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = node.value;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(node:TNode, propName:string = 'node')\r\n{\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}\r\n\r\nexport default LinkedNodeList;"]}