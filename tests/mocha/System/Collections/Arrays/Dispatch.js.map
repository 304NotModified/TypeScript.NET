{"version":3,"sources":["System/Collections/Arrays/Dispatch.ts"],"names":[],"mappings":";AAAA,4BAA4B;AAC5B,+BAAiC;AACjC,2FAIwE;AAGxE,EAAE,CAAC,gCAAgC,EAAE;IAEpC,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,IAAM,CAAC,GAAoB;QAC1B,UAAC,CAAQ;YAER,MAAM,IAAI,CAAC,CAAC;QACb,CAAC;QACD,UAAC,CAAQ;YAER,MAAM,IAAI,CAAC,CAAC;QACb,CAAC;QACI,IAAI;KACT,CAAC;IAGF,mBAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAChB,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;IAE1B,MAAM,CAAC,KAAK,CAAC,iBAAM,CAAM,IAAI,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;IAC1C,MAAM,CAAC,KAAK,CAAC,iBAAM,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;IACvC,MAAM,CAAC,KAAK,CAAC,iBAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;IACtC,iBAAM,CAAM,IAAI,EAAC,EAAE,CAAC,CAAC;IACrB,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;AAC5B,CAAC,CAAC,CAAC;AAEH,IAAM,CAAC,GAAG;IACT;QAEC,MAAM,OAAO,CAAC;IACf,CAAC;CACD,CAAC;AAEF,EAAE,CAAC,yBAAyB,EAAC;IAC5B,MAAM,CAAC,MAAM,CAAC;QAEb,mBAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACjB,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,MAAM,CAAC;QAEb,iBAAM,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACf,CAAC,CAAC,CAAC;AACJ,CAAC,CAAC,CAAC;AAGH,EAAE,CAAC,oBAAoB,EAAC;IACvB,MAAM,CAAC,YAAY,CAAC;QAEnB,mBAAQ,CAAC,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;QACtB,mBAAQ,CAAC,CAAC,EAAE,EAAE,EAAC,UAAA,GAAG,IAAE,OAAA,MAAM,CAAC,KAAK,CAAC,GAAG,EAAC,OAAO,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAChD,CAAC,CAAC,CAAC;IAEH,MAAM,CAAC,YAAY,CAAC;QAEnB,iBAAM,CAAC,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;QACpB,iBAAM,CAAC,CAAC,EAAE,EAAE,EAAC,UAAA,GAAG,IAAE,OAAA,MAAM,CAAC,KAAK,CAAC,GAAG,EAAC,OAAO,CAAC,EAAzB,CAAyB,CAAC,CAAC;IAC9C,CAAC,CAAC,CAAC;AACJ,CAAC,CAAC,CAAC","file":"Dispatch.js","sourcesContent":["///<reference types=\"node\"/>\r\nimport * as assert from \"assert\";\r\nimport {\r\n\tdispatch,\r\n\tmapped,\r\n\tunsafe\r\n} from \"../../../../../dist/commonjs/System/Collections/Array/Dispatch\";\r\nimport {Action} from \"../../../../../source/System/FunctionTypes\";\r\n\r\nit(\"should apply closures in order\", ()=>\r\n{\r\n\tlet result = 0;\r\n\tconst a:Action<number>[] = [\r\n\t\t(p:number) =>\r\n\t\t{\r\n\t\t\tresult += p;\r\n\t\t},\r\n\t\t(p:number) =>\r\n\t\t{\r\n\t\t\tresult *= p;\r\n\t\t},\r\n\t\t<any>null\r\n\t];\r\n\r\n\r\n\tdispatch(a, 10);\r\n\tassert.equal(result, 100);\r\n\r\n\tassert.equal(mapped(<any>null, 20), null);\r\n\tassert.equal(mapped([], 20).length, 0);\r\n\tassert.equal(mapped(a, 20).length, 3);\r\n\tunsafe(<any>null,10);\r\n\tassert.equal(result, 2400);\r\n});\r\n\r\nconst b = [\r\n\t() =>\r\n\t{\r\n\t\tthrow \"error\";\r\n\t}\r\n];\r\n\r\nit(\"should propagate errors\",()=>{\r\n\tassert.throws(()=>\r\n\t{\r\n\t\tdispatch(b, 10);\r\n\t});\r\n\r\n\tassert.throws(()=>\r\n\t{\r\n\t\tmapped(b, 10);\r\n\t});\r\n});\r\n\r\n\r\nit(\"should trap errors\",()=>{\r\n\tassert.doesNotThrow(()=>\r\n\t{\r\n\t\tdispatch(b, 10, true);\r\n\t\tdispatch(b, 10,err=>assert.equal(err,'error'));\r\n\t});\r\n\r\n\tassert.doesNotThrow(()=>\r\n\t{\r\n\t\tmapped(b, 10, true);\r\n\t\tmapped(b, 10,err=>assert.equal(err,'error'));\r\n\t});\r\n});"]}