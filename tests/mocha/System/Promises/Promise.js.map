{"version":3,"sources":["System/Promises/Promise.ts"],"names":[],"mappings":";;;;;;;;;IAEA,wBAAsB,4CAA4C,CAAC,CAAA;IACnE,IAAY,EAAE,WAAM,qDAAqD,CAAC,CAAA;IAC1E,IAAI,MAAM,GAAG,OAAO,CAAC,wCAAwC,CAAC,CAAC;IAG/D,IAAI,MAAM,GAAG,2DAA2D,CAAC;IAGzE,IAAI,oBAAoB,GAAG,CAAC,cAAa,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;IAE3D,SAAS,CAAC;IAGV,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,0CAA0C,EAAE;QAGpD,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,IAAI,KAAK,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;QAC/B,IAAI,KAAK,GAAG,iBAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAEjC,EAAE,CAAC,mEAAmE,EAAE;YACvE,OAAA,KAAK;iBACH,MAAM,CAAC,UAAC,OAA2B,EAAE,OAAc;gBACnD,OAAA,OAAO,CAAC,IAAI,CAAC,UAAA,UAAU,IAAE,OAAA,UAAU,GAAG,OAAO,EAApB,CAAoB,CAAC;YAA9C,CAA8C,EAAE,KAAK,CAAC;iBACtD,IAAI,CAAC,UAAA,KAAK;gBACV,OAAA,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAC,CAAC,CAAC;YAAxC,CAAwC,CAAC;QAJ3C,CAI2C,CAC3C,CAAC;QAEF,EAAE,CAAC,qDAAqD,EAAE;YACzD,OAAA,KAAK;iBACH,MAAM,CAAC,UAAC,OAA2B,EAAE,OAAc;gBACnD,OAAA,OAAO,CAAC,IAAI,CAAC,UAAA,UAAU,IAAE,OAAA,iBAAO,CAAC,SAAS,CAAC,UAAU,GAAG,OAAO,CAAC,EAAvC,CAAuC,CAAC;YAAjE,CAAiE,EAAE,KAAK,CAAC;iBACzE,IAAI,CAAC,UAAA,KAAK;gBACV,OAAA,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAC,CAAC,CAAC;YAAxC,CAAwC,CAAC;QAJ3C,CAI2C,CAC3C,CAAC;IACH,CAAC,CAAC,CAAC;IAGH,QAAQ,CAAC,YAAY,EAAE;QACtB,EAAE,CAAC,yDAAyD,EAAE;YAC7D,IAAI,CAAC,GAAG,iBAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAC7B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,EAAC,IAAI,CAAC,CAAC;YAChC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,WAAW,EAAC,IAAI,CAAC,CAAC;YACjC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,EAAC,KAAK,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,8DAA8D,EAAE;YAClE,IAAI,CAAC,GAAG,iBAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;YAChC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,EAAC,KAAK,CAAC,CAAC;YAC5B,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,EAAC,IAAI,CAAC,CAAC;YAChC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,WAAW,EAAC,KAAK,CAAC,CAAC;YAClC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,EAAC,IAAI,CAAC,CAAC;QACjC,CAAC,CAAC,CAAC;IAWJ,CAAC,CAAC,CAAC","file":"System/Promises/Promise.js","sourcesContent":["///<reference path=\"../../import.d.ts\"/>\r\n\r\nimport {Promise} from \"../../../../source/System/Promises/Promise\";\r\nimport * as AU from \"../../../../source/System/Collections/Array/Utility\";\r\nvar assert = require('../../../../node_modules/assert/assert');\r\n\r\n\r\nvar REASON = \"this is not an error, but it might show up in the console\";\r\n\r\n// In browsers that support strict mode, it'll be `undefined`; otherwise, the global.\r\nvar calledAsFunctionThis = (function() { return this; }());\r\n\r\nafterEach(function()\r\n{\r\n\t//Q.onerror = null;\r\n});\r\n\r\ndescribe(\"computing sum of integers using promises\", ()=>\r\n{\r\n\t// Use triangular numbers...\r\n\tvar count = 1000;\r\n\tvar array = AU.range(1, count);\r\n\tvar pZero = Promise.fulfilled(0);\r\n\r\n\tit(\"should compute correct result without blowing stack (lambda only)\", ()=>\r\n\t\tarray\r\n\t\t\t.reduce((promise:PromiseLike<number>, nextVal:number) =>\r\n\t\t\t\tpromise.then(currentVal=>currentVal + nextVal), pZero)\r\n\t\t\t.then(value=>\r\n\t\t\t\tassert.equal(value, count*(count + 1)/2))\r\n\t);\r\n\r\n\tit(\"should compute correct result without blowing stack\", ()=>\r\n\t\tarray\r\n\t\t\t.reduce((promise:PromiseLike<number>, nextVal:number) =>\r\n\t\t\t\tpromise.then(currentVal=>Promise.fulfilled(currentVal + nextVal)), pZero)\r\n\t\t\t.then(value=>\r\n\t\t\t\tassert.equal(value, count*(count + 1)/2))\r\n\t);\r\n});\r\n\r\n\r\ndescribe(\"Q function\", function () {\r\n\tit(\"should result in a fulfilled promise when given a value\", function () {\r\n\t\tvar f = Promise.fulfilled(5);\r\n\t\tassert.equal(f.result,5);\r\n\t\tassert.equal(f.isResolved,true);\r\n\t\tassert.equal(f.isFulfilled,true);\r\n\t\tassert.equal(f.isRejected,false);\r\n\t});\r\n\r\n\tit(\"should result in a rejected promise when requesting rejected\", function () {\r\n\t\tvar f = Promise.rejected(\"err\");\r\n\t\tassert.equal(f.error,\"err\");\r\n\t\tassert.equal(f.isResolved,true);\r\n\t\tassert.equal(f.isFulfilled,false);\r\n\t\tassert.equal(f.isRejected,true);\r\n\t});\r\n\r\n\t// it(\"should be the identity when given promise\", function () {\r\n\t// \tvar f = Promise.fulfilled(5);\r\n\t// \tvar r = Promise.rejected(new Error(\"aaargh\"));\r\n\t// \t//var p = Q.promise(function () { });\r\n\t//\r\n\t// \texpect(Q(f)).toBe(f);\r\n\t// \texpect(Q(r)).toBe(r);\r\n\t// \texpect(Q(p)).toBe(p);\r\n\t// });\r\n});\r\n//\r\n// describe(\"defer and when\", function () {\r\n//\r\n// \tit(\"resolve before when\", function () {\r\n// \t\tvar turn = 0;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tdeferred.resolve(10);\r\n// \t\tvar promise = Q.when(deferred.promise, function (value) {\r\n// \t\t\texpect(turn).toEqual(1);\r\n// \t\t\texpect(value).toEqual(10);\r\n// \t\t});\r\n// \t\tturn++;\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"reject before when\", function () {\r\n// \t\tvar turn = 0;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tdeferred.reject(-1);\r\n// \t\tvar promise = Q.when(deferred.promise, function () {\r\n// \t\t\texpect(true).toBe(false);\r\n// \t\t}, function (value) {\r\n// \t\t\texpect(turn).toEqual(1);\r\n// \t\t\texpect(value).toEqual(-1);\r\n// \t\t});\r\n// \t\tturn++;\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"when before resolve\", function () {\r\n// \t\tvar turn = 0;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = deferred.promise.then(function (value) {\r\n// \t\t\texpect(turn).toEqual(2);\r\n// \t\t\texpect(value).toEqual(10);\r\n// \t\t\tturn++;\r\n// \t\t});\r\n// \t\tQ.nextTick(function () {\r\n// \t\t\texpect(turn).toEqual(1);\r\n// \t\t\tdeferred.resolve(10);\r\n// \t\t\tturn++;\r\n// \t\t});\r\n// \t\tturn++;\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"when before reject\", function () {\r\n// \t\tvar turn = 0;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = deferred.promise.then(function () {\r\n// \t\t\texpect(true).toBe(false);\r\n// \t\t}, function (value) {\r\n// \t\t\texpect(turn).toEqual(2);\r\n// \t\t\texpect(value).toEqual(-1);\r\n// \t\t\tturn++;\r\n// \t\t});\r\n// \t\tQ.nextTick(function () {\r\n// \t\t\texpect(turn).toEqual(1);\r\n// \t\t\tdeferred.reject(-1);\r\n// \t\t\tturn++;\r\n// \t\t});\r\n// \t\tturn++;\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"resolves multiple observers\", function (done) {\r\n// \t\tvar nextTurn = false;\r\n//\r\n// \t\tvar resolution = \"Taram pam param!\";\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar count = 10;\r\n// \t\tvar i = 0;\r\n//\r\n// \t\tfunction resolve(value) {\r\n// \t\t\ti++;\r\n// \t\t\texpect(value).toBe(resolution);\r\n// \t\t\texpect(nextTurn).toBe(true);\r\n// \t\t\tif (i === count) {\r\n// \t\t\t\tdone();\r\n// \t\t\t}\r\n// \t\t}\r\n//\r\n// \t\twhile (++i <= count) {\r\n// \t\t\tQ.when(deferred.promise, resolve);\r\n// \t\t}\r\n//\r\n// \t\tdeferred.resolve(resolution);\r\n// \t\ti = 0;\r\n// \t\tnextTurn = true;\r\n// \t});\r\n//\r\n// \tit(\"observers called even after throw\", function () {\r\n// \t\tvar threw = false;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tQ.when(deferred.promise, function () {\r\n// \t\t\tthrew = true;\r\n// \t\t\tthrow new Error(REASON);\r\n// \t\t});\r\n// \t\tvar promise = Q.when(deferred.promise, function (value) {\r\n// \t\t\texpect(value).toEqual(10);\r\n// \t\t}, function () {\r\n// \t\t\texpect(\"not\").toEqual(\"here\");\r\n// \t\t});\r\n// \t\tdeferred.resolve(10);\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"returns `undefined` from the deferred's methods\", function () {\r\n// \t\texpect(Q.defer().resolve()).toBe(undefined);\r\n// \t\texpect(Q.defer().reject()).toBe(undefined);\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"always next tick\", function () {\r\n//\r\n// \tit(\"generated by `resolve`\", function () {\r\n// \t\tvar turn = 0;\r\n// \t\tvar promise = Q.when(Q(), function () {\r\n// \t\t\texpect(turn).toEqual(1);\r\n// \t\t});\r\n// \t\tturn++;\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"generated by `reject`\", function () {\r\n// \t\tvar turn = 0;\r\n// \t\tvar promise = Q.when(Q.reject(), function () {\r\n// \t\t\texpect(true).toBe(false);\r\n// \t\t}, function () {\r\n// \t\t\texpect(turn).toEqual(1);\r\n// \t\t});\r\n// \t\tturn++;\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"allows overriding global nextTick\", function () {\r\n// \t\tvar spy = jasmine.createSpy();\r\n// \t\tspyOn(Q, 'nextTick').andCallFake(function immediateTick(task){\r\n// \t\t\ttask();\r\n// \t\t});\r\n//\r\n// \t\tQ.when(Q(), spy);\r\n//\r\n// \t\texpect(spy).toHaveBeenCalled();\r\n// \t\texpect(Q.nextTick).toHaveBeenCalled();\r\n// \t});\r\n// });\r\n//\r\n// describe(\"progress\", function () {\r\n//\r\n// \tit(\"calls a single progress listener\", function () {\r\n// \t\tvar progressed = false;\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressed).toBe(true);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tprogressed = true;\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"calls multiple progress listeners\", function () {\r\n// \t\tvar progressed1 = false;\r\n// \t\tvar progressed2 = false;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressed1).toBe(true);\r\n// \t\t\t\texpect(progressed2).toBe(true);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tprogressed1 = true;\r\n// \t\t\t}\r\n// \t\t);\r\n// \t\tQ.when(deferred.promise, null, null, function () {\r\n// \t\t\tprogressed2 = true;\r\n// \t\t});\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"calls all progress listeners even if one throws\", function () {\r\n// \t\tvar progressed1 = false;\r\n// \t\tvar progressed2 = false;\r\n// \t\tvar progressed3 = false;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressed1).toBe(true);\r\n// \t\t\t\texpect(progressed2).toBe(true);\r\n// \t\t\t\texpect(progressed3).toBe(true);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tprogressed1 = true;\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tQ.onerror = function () { };\r\n//\r\n// \t\tQ.when(deferred.promise, null, null, function () {\r\n// \t\t\tprogressed2 = true;\r\n// \t\t\tthrow new Error(\"just a test, ok if it shows up in the console\");\r\n// \t\t});\r\n// \t\tQ.when(deferred.promise, null, null, function () {\r\n// \t\t\tprogressed3 = true;\r\n// \t\t});\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"calls the progress listener even if later rejected\", function () {\r\n// \t\tvar progressed = false;\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressed).toEqual(true);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tprogressed = true;\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.reject();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"calls the progress listener with the notify values\", function () {\r\n// \t\tvar progressValues = [];\r\n// \t\tvar desiredProgressValues = [{}, {}, \"foo\", 5];\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\tfor (var i = 0; i < desiredProgressValues.length; ++i) {\r\n// \t\t\t\t\tvar desired = desiredProgressValues[i];\r\n// \t\t\t\t\tvar actual = progressValues[i];\r\n// \t\t\t\t\texpect(actual).toBe(desired);\r\n// \t\t\t\t}\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction (value) {\r\n// \t\t\t\tprogressValues.push(value);\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tfor (var i = 0; i < desiredProgressValues.length; ++i) {\r\n// \t\t\tdeferred.notify(desiredProgressValues[i]);\r\n// \t\t}\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"does not call the progress listener if notify is called after fulfillment\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar called = false;\r\n//\r\n// \t\tQ.when(deferred.promise, null, null, function () {\r\n// \t\t\tcalled = true;\r\n// \t\t});\r\n//\r\n// \t\tdeferred.resolve();\r\n// \t\tdeferred.notify();\r\n//\r\n// \t\treturn Q.delay(10).then(function () {\r\n// \t\t\texpect(called).toBe(false);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"does not call the progress listener if notify is called after rejection\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar called = false;\r\n//\r\n// \t\tQ.when(deferred.promise, null, null, function () {\r\n// \t\t\tcalled = true;\r\n// \t\t});\r\n//\r\n// \t\tdeferred.reject();\r\n// \t\tdeferred.notify();\r\n//\r\n// \t\treturn Q.delay(10).then(function () {\r\n// \t\t\texpect(called).toBe(false);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"should not save and re-emit progress notifications\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar progressValues = [];\r\n//\r\n// \t\tdeferred.notify(1);\r\n//\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressValues).toEqual([2]);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction (progressValue) {\r\n// \t\t\t\tprogressValues.push(progressValue);\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdeferred.notify(2);\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should allow attaching progress listeners w/ .progress\", function () {\r\n// \t\tvar progressed = false;\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tdeferred.promise.progress(function () {\r\n// \t\t\tprogressed = true;\r\n// \t\t});\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn deferred.promise;\r\n// \t});\r\n//\r\n// \tit(\"should allow attaching progress listeners w/ Q.progress\", function () {\r\n// \t\tvar progressed = false;\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tQ.progress(deferred.promise, function () {\r\n// \t\t\tprogressed = true;\r\n// \t\t});\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn deferred.promise;\r\n// \t});\r\n//\r\n// \tit(\"should call the progress listener with undefined context\", function () {\r\n// \t\tvar progressed = false;\r\n// \t\tvar progressContext = {};\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressed).toBe(true);\r\n// \t\t\t\texpect(progressContext).toBe(calledAsFunctionThis);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tprogressed = true;\r\n// \t\t\t\tprogressContext = this;\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should forward only the first notify argument to listeners\", function () {\r\n// \t\tvar progressValueArrays = [];\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tvar promise = Q.when(\r\n// \t\t\tdeferred.promise,\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressValueArrays).toEqual([[1], [2], [4]]);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tvar args = Array.prototype.slice.call(arguments);\r\n// \t\t\t\tprogressValueArrays.push(args);\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdeferred.notify(1);\r\n// \t\tdeferred.notify(2, 3);\r\n// \t\tdeferred.notify(4, 5, 6);\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should work with .then as well\", function () {\r\n// \t\tvar progressed = false;\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tvar promise = deferred.promise.then(\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressed).toBe(true);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\tprogressed = true;\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdeferred.notify();\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should re-throw all errors thrown by listeners to Q.onerror\", function () {\r\n// \t\tvar theError = new Error(\"boo!\");\r\n//\r\n// \t\tvar def = Q.defer();\r\n// \t\tdef.promise.progress(function () {\r\n// \t\t\tthrow theError;\r\n// \t\t});\r\n//\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tQ.onerror = function (error) {\r\n// \t\t\texpect(error).toBe(theError);\r\n// \t\t\tdeferred.resolve();\r\n// \t\t};\r\n// \t\tQ.delay(100).then(deferred.reject);\r\n//\r\n// \t\tdef.notify();\r\n//\r\n// \t\treturn deferred.promise;\r\n// \t});\r\n// });\r\n//\r\n// describe(\"promises for objects\", function () {\r\n//\r\n// \tdescribe(\"get\", function () {\r\n//\r\n// \t\tit(\"fulfills a promise\", function () {\r\n// \t\t\tvar deferred = Q.defer();\r\n// \t\t\tdeferred.resolve({a: 1});\r\n// \t\t\treturn deferred.promise.get(\"a\")\r\n// \t\t\t\t.then(function (a) {\r\n// \t\t\t\t\texpect(a).toBe(1);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"propagates a rejection\", function () {\r\n// \t\t\tvar exception = new Error(\"boo!\");\r\n// \t\t\treturn Q.fcall(function () {\r\n// \t\t\t\tthrow exception;\r\n// \t\t\t})\r\n// \t\t\t\t.get(\"a\")\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"be\").toBe(\"not to be\");\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"set\", function () {\r\n//\r\n// \t\tit(\"fulfills a promise\", function () {\r\n// \t\t\tvar object = {};\r\n// \t\t\treturn Q(object)\r\n// \t\t\t\t.set(\"a\", 1)\r\n// \t\t\t\t.then(function (result) {\r\n// \t\t\t\t\texpect(result).toBe(undefined);\r\n// \t\t\t\t\texpect(object.a).toBe(1);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"propagates a rejection\", function () {\r\n// \t\t\tvar exception = new Error(\"Gah!\");\r\n// \t\t\treturn Q.reject(exception)\r\n// \t\t\t\t.set(\"a\", 1)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"frozen over\").toBe(\"quite warm\");\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"del\", function () {\r\n//\r\n// \t\tit(\"fulfills a promise\", function () {\r\n// \t\t\tvar object = {a: 10};\r\n// \t\t\treturn Q.fcall(function () {\r\n// \t\t\t\treturn object;\r\n// \t\t\t})\r\n// \t\t\t\t.del(\"a\")\r\n// \t\t\t\t.then(function (result) {\r\n// \t\t\t\t\texpect(\"a\" in object).toBe(false);\r\n// \t\t\t\t\texpect(result).toBe(void 0);\r\n// \t\t\t\t}, function () {\r\n// \t\t\t\t\texpect(\"up\").toBe(\"down\");\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"propagates a rejection\", function () {\r\n// \t\t\tvar exception = new Error(\"hah-hah\");\r\n// \t\t\treturn Q.fcall(function () {\r\n// \t\t\t\tthrow exception;\r\n// \t\t\t})\r\n// \t\t\t\t.del(\"a\")\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"post\", function () {\r\n//\r\n// \t\tit(\"fulfills a promise\", function () {\r\n// \t\t\tvar subject = {\r\n// \t\t\t\ta: function a(value) {\r\n// \t\t\t\t\tthis._a = value;\r\n// \t\t\t\t\treturn 1 + value;\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n// \t\t\treturn Q.when(Q.post(subject, \"a\", [1]), function (two) {\r\n// \t\t\t\texpect(subject._a).toBe(1);\r\n// \t\t\t\texpect(two).toBe(2);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"works as apply when given no name\", function () {\r\n// \t\t\treturn Q(function (a, b, c) {\r\n// \t\t\t\treturn a + b + c;\r\n// \t\t\t})\r\n// \t\t\t\t.post(undefined, [1, 2, 3])\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"send\", function () {\r\n//\r\n// \t\tit(\"fulfills a promise\", function () {\r\n// \t\t\tvar foo;\r\n// \t\t\tvar subject = {\r\n// \t\t\t\tfoo: function (_bar) {\r\n// \t\t\t\t\treturn _bar;\r\n// \t\t\t\t},\r\n// \t\t\t\tbar: function (_foo, _bar) {\r\n// \t\t\t\t\tfoo = _foo;\r\n// \t\t\t\t\treturn this.foo(_bar);\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n// \t\t\treturn Q.send(subject, \"bar\", 1, 2)\r\n// \t\t\t\t.then(function (two) {\r\n// \t\t\t\t\texpect(foo).toEqual(1);\r\n// \t\t\t\t\texpect(two).toEqual(2);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"is rejected for undefined method\", function () {\r\n// \t\t\tvar subject = {};\r\n// \t\t\treturn Q(subject)\r\n// \t\t\t\t.send(\"foo\")\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"here\").toEqual(\"not here\");\r\n// \t\t\t\t}, function () {\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"is rejected for undefined object\", function () {\r\n// \t\t\treturn Q()\r\n// \t\t\t\t.send(\"foo\")\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"here\").toEqual(\"not here\");\r\n// \t\t\t\t}, function () {\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"keys\", function () {\r\n//\r\n// \t\tfunction Klass (a, b) {\r\n// \t\t\tthis.a = a;\r\n// \t\t\tthis.b = b;\r\n// \t\t}\r\n// \t\tKlass.prototype.notOwn = 1;\r\n//\r\n// \t\tit(\"fulfills a promise\", function () {\r\n// \t\t\treturn Q.keys(new Klass(10, 20))\r\n// \t\t\t\t.then(function (keys) {\r\n// \t\t\t\t\texpect(keys.sort()).toEqual([\"a\", \"b\"]);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"promises for functions\", function () {\r\n//\r\n// \tdescribe(\"fapply\", function () {\r\n// \t\tit(\"fulfills a promise using arguments\", function () {\r\n// \t\t\treturn Q(function (a, b, c) {\r\n// \t\t\t\treturn a + b + c;\r\n// \t\t\t})\r\n// \t\t\t\t.fapply([1, 2, 3])\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"fcall\", function () {\r\n// \t\tit(\"fulfills a promise using arguments\", function () {\r\n// \t\t\treturn Q(function (a, b, c) {\r\n// \t\t\t\treturn a + b + c;\r\n// \t\t\t})\r\n// \t\t\t\t.fcall(1, 2, 3)\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"fbind\", function () {\r\n//\r\n// \t\tit(\"accepts a promise for a function\", function () {\r\n// \t\t\treturn Q.fbind(Q(function (high, low) {\r\n// \t\t\t\treturn high - low;\r\n// \t\t\t}))\r\n// \t\t\t(2, 1)\r\n// \t\t\t\t.then(function (difference) {\r\n// \t\t\t\t\texpect(difference).toEqual(1);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"chains partial application on a promise for a function\", function () {\r\n// \t\t\treturn Q(function (a, b) {\r\n// \t\t\t\treturn a * b;\r\n// \t\t\t})\r\n// \t\t\t\t.fbind(2)(3)\r\n// \t\t\t\t.then(function (product) {\r\n// \t\t\t\t\texpect(product).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"returns a fulfilled promise\", function () {\r\n// \t\t\tvar result = {};\r\n// \t\t\tvar bound = Q.fbind(function () {\r\n// \t\t\t\treturn result;\r\n// \t\t\t});\r\n// \t\t\treturn bound()\r\n// \t\t\t\t.then(function (_result) {\r\n// \t\t\t\t\texpect(_result).toBe(result);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"returns a rejected promise from a thrown error\", function () {\r\n// \t\t\tvar exception = new Error(\"Boo!\");\r\n// \t\t\tvar bound = Q.fbind(function () {\r\n// \t\t\t\tthrow exception;\r\n// \t\t\t});\r\n// \t\t\treturn bound()\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"flying pigs\").toBe(\"swillin' pigs\");\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"passes arguments through\", function () {\r\n// \t\t\tvar x = {}, y = {};\r\n// \t\t\tvar bound = Q.fbind(function (a, b) {\r\n// \t\t\t\texpect(a).toBe(x);\r\n// \t\t\t\texpect(b).toBe(y);\r\n// \t\t\t});\r\n// \t\t\treturn bound(x, y);\r\n// \t\t});\r\n//\r\n// \t\tit(\"passes and also partially applies arguments\", function () {\r\n// \t\t\tvar x = {}, y = {};\r\n// \t\t\tvar bound = Q.fbind(function (a, b) {\r\n// \t\t\t\texpect(a).toBe(x);\r\n// \t\t\t\texpect(b).toBe(y);\r\n// \t\t\t}, x);\r\n// \t\t\treturn bound(y);\r\n// \t\t});\r\n//\r\n// \t\tit(\"doesn't bind `this`\", function () {\r\n// \t\t\tvar theThis = { me: \"this\" };\r\n// \t\t\tvar bound = Q.fbind(function () {\r\n// \t\t\t\texpect(this).toBe(theThis);\r\n// \t\t\t});\r\n//\r\n// \t\t\treturn bound.call(theThis);\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"inspect\", function () {\r\n//\r\n// \tit(\"for a fulfilled promise\", function () {\r\n// \t\texpect(Q(10).inspect()).toEqual({\r\n// \t\t\tstate: \"fulfilled\",\r\n// \t\t\tvalue: 10\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"for a rejected promise\", function () {\r\n// \t\tvar error = new Error(\"In your face.\");\r\n// \t\tvar rejected = Q.reject(error);\r\n// \t\texpect(rejected.inspect()).toEqual({\r\n// \t\t\tstate: \"rejected\",\r\n// \t\t\treason: error\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"for a pending, unresolved promise\", function () {\r\n// \t\tvar pending = Q.defer().promise;\r\n// \t\texpect(pending.inspect()).toEqual({ state: \"pending\" });\r\n// \t});\r\n//\r\n// \tit(\"for a promise resolved to a rejected promise\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar error = new Error(\"Rejected!\");\r\n// \t\tvar rejected = Q.reject(error);\r\n// \t\tdeferred.resolve(rejected);\r\n//\r\n// \t\texpect(deferred.promise.inspect()).toEqual({\r\n// \t\t\tstate: \"rejected\",\r\n// \t\t\treason: error\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"for a promise resolved to a fulfilled promise\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar fulfilled = Q(10);\r\n// \t\tdeferred.resolve(fulfilled);\r\n//\r\n// \t\texpect(deferred.promise.inspect()).toEqual({\r\n// \t\t\tstate: \"fulfilled\",\r\n// \t\t\tvalue: 10\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"for a promise resolved to a pending promise\", function () {\r\n// \t\tvar a = Q.defer();\r\n// \t\tvar b = Q.defer();\r\n// \t\ta.resolve(b.promise);\r\n//\r\n// \t\texpect(a.promise.inspect()).toEqual({ state: \"pending\" });\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"promise states\", function () {\r\n//\r\n// \tit(\"of fulfilled value\", function () {\r\n// \t\texpect(Q.isFulfilled(void 0)).toBe(true);\r\n// \t\texpect(Q.isRejected(false)).toBe(false);\r\n// \t\texpect(Q.isPending(true)).toBe(false);\r\n// \t});\r\n//\r\n// \tit(\"of fulfillment\", function () {\r\n// \t\tvar promise = Q(10);\r\n// \t\texpect(Q.isFulfilled(promise)).toBe(true);\r\n// \t\texpect(promise.isFulfilled()).toBe(true);\r\n// \t\texpect(Q.isRejected(promise)).toBe(false);\r\n// \t\texpect(promise.isRejected()).toBe(false);\r\n// \t\texpect(Q.isPending(promise)).toBe(false);\r\n// \t\texpect(promise.isPending()).toBe(false);\r\n// \t});\r\n//\r\n// \tit(\"of rejection\", function () {\r\n// \t\tvar error = new Error(\"Oh, snap.\");\r\n// \t\tvar promise = Q.reject(error);\r\n// \t\texpect(promise.isFulfilled()).toBe(false);\r\n// \t\texpect(promise.isRejected()).toBe(true);\r\n// \t\texpect(promise.isPending()).toBe(false);\r\n// \t});\r\n//\r\n// \tit(\"of rejection with a falsy value\", function () {\r\n// \t\tvar promise = Q.reject(undefined);\r\n// \t\texpect(promise.isFulfilled()).toBe(false);\r\n// \t\texpect(promise.isRejected()).toBe(true);\r\n// \t\texpect(promise.isPending()).toBe(false);\r\n// \t});\r\n//\r\n// \tit(\"of deferred\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar promise = deferred.promise;\r\n// \t\texpect(promise.isFulfilled()).toBe(false);\r\n// \t\texpect(promise.isRejected()).toBe(false);\r\n// \t\texpect(promise.isPending()).toBe(true);\r\n// \t});\r\n//\r\n// \tit(\"of deferred rejection\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar rejection = Q.reject(new Error(\"Rejected!\"));\r\n// \t\tdeferred.resolve(rejection);\r\n// \t\tvar promise = deferred.promise;\r\n// \t\texpect(promise.isFulfilled()).toBe(false);\r\n// \t\texpect(promise.isRejected()).toBe(true);\r\n// \t\texpect(promise.isPending()).toBe(false);\r\n// \t});\r\n//\r\n// \tit(\"of deferred fulfillment\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tdeferred.resolve(10);\r\n// \t\tvar promise = deferred.promise;\r\n// \t\texpect(promise.isFulfilled()).toBe(true);\r\n// \t\texpect(promise.isRejected()).toBe(false);\r\n// \t\texpect(promise.isPending()).toBe(false);\r\n// \t});\r\n//\r\n// \tit(\"of deferred deferred\", function () {\r\n// \t\tvar a = Q.defer();\r\n// \t\tvar b = Q.defer();\r\n// \t\ta.resolve(b.promise);\r\n// \t\tvar promise = a.promise;\r\n// \t\texpect(promise.isFulfilled()).toBe(false);\r\n// \t\texpect(promise.isRejected()).toBe(false);\r\n// \t\texpect(promise.isPending()).toBe(true);\r\n// \t});\r\n//\r\n// \tit(\"of isFulfilled side effects\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tvar finished = false;\r\n//\r\n// \t\twaitsFor(function () {\r\n// \t\t\treturn finished;\r\n// \t\t});\r\n//\r\n// \t\tvar parentPromise = deferred.promise;\r\n//\r\n// \t\tvar childPromise = parentPromise.then(function () {\r\n// \t\t\texpect(parentPromise.isFulfilled()).toBe(true);\r\n// \t\t\texpect(childPromise.isFulfilled()).toBe(false);\r\n//\r\n// \t\t\treturn parentPromise.then(function (value) {\r\n// \t\t\t\tfinished = true;\r\n// \t\t\t\treturn value + 1;\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdeferred.resolve(1);\r\n//\r\n// \t\truns(function () {\r\n// \t\t\texpect(childPromise.isPending()).toBe(false);\r\n// \t\t\texpect(childPromise.isRejected()).toBe(false);\r\n// \t\t\texpect(childPromise.isFulfilled()).toBe(true);\r\n// \t\t\texpect(childPromise.inspect().value).toBe(2);\r\n// \t\t});\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"propagation\", function () {\r\n//\r\n// \tit(\"propagate through then with no callback\", function () {\r\n// \t\treturn Q(10)\r\n// \t\t\t.then()\r\n// \t\t\t.then(function (ten) {\r\n// \t\t\t\texpect(ten).toBe(10);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"propagate through then with modifying callback\", function () {\r\n// \t\treturn Q(10)\r\n// \t\t\t.then(function (ten) {\r\n// \t\t\t\treturn ten + 10;\r\n// \t\t\t})\r\n// \t\t\t.then(function (twen) {\r\n// \t\t\t\texpect(twen).toBe(20);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"errback recovers from exception\", function () {\r\n// \t\tvar error = new Error(\"Bah!\");\r\n// \t\treturn Q.reject(error)\r\n// \t\t\t.then(null, function (_error) {\r\n// \t\t\t\texpect(_error).toBe(error);\r\n// \t\t\t\treturn 10;\r\n// \t\t\t})\r\n// \t\t\t.then(function (value) {\r\n// \t\t\t\texpect(value).toBe(10);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"rejection propagates through then with no errback\", function () {\r\n// \t\tvar error = new Error(\"Foolish mortals!\");\r\n// \t\treturn Q.reject(error)\r\n// \t\t\t.then()\r\n// \t\t\t.then(null, function (_error) {\r\n// \t\t\t\texpect(_error).toBe(error);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"rejection intercepted and rethrown\", function () {\r\n// \t\tvar error = new Error(\"Foolish mortals!\");\r\n// \t\tvar nextError = new Error(\"Silly humans!\");\r\n// \t\treturn Q.reject(error)\r\n// \t\t\t.fail(function () {\r\n// \t\t\t\tthrow nextError;\r\n// \t\t\t})\r\n// \t\t\t.then(null, function (_error) {\r\n// \t\t\t\texpect(_error).toBe(nextError);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"resolution is forwarded through deferred promise\", function () {\r\n// \t\tvar a = Q.defer();\r\n// \t\tvar b = Q.defer();\r\n// \t\ta.resolve(b.promise);\r\n// \t\tb.resolve(10);\r\n// \t\treturn a.promise.then(function (eh) {\r\n// \t\t\texpect(eh).toEqual(10);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"should propagate progress by default\", function () {\r\n// \t\tvar d = Q.defer();\r\n//\r\n// \t\tvar progressValues = [];\r\n// \t\tvar promise = d.promise\r\n// \t\t\t.then()\r\n// \t\t\t.then(\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(progressValues).toEqual([1]);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction (progressValue) {\r\n// \t\t\t\t\tprogressValues.push(progressValue);\r\n// \t\t\t\t}\r\n// \t\t\t);\r\n//\r\n// \t\td.notify(1);\r\n// \t\td.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should allow translation of progress in the progressback\", function () {\r\n// \t\tvar d = Q.defer();\r\n//\r\n// \t\tvar progressValues = [];\r\n// \t\tvar promise = d.promise\r\n// \t\t\t.progress(function (p) {\r\n// \t\t\t\treturn p + 5;\r\n// \t\t\t})\r\n// \t\t\t.then(\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(progressValues).toEqual([10]);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction (progressValue) {\r\n// \t\t\t\t\tprogressValues.push(progressValue);\r\n// \t\t\t\t}\r\n// \t\t\t);\r\n//\r\n// \t\td.notify(5);\r\n// \t\td.resolve();\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n//\r\n// \tit(\"should stop progress propagation if an error is thrown\", function () {\r\n// \t\tvar def = Q.defer();\r\n// \t\tvar p2 = def.promise.progress(function () {\r\n// \t\t\tthrow new Error(\"boo!\");\r\n// \t\t});\r\n//\r\n// \t\tQ.onerror = function () { /* just swallow it for this test */ };\r\n//\r\n// \t\tvar progressValues = [];\r\n// \t\tvar result = p2.then(\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressValues).toEqual([]);\r\n// \t\t\t},\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction (progressValue) {\r\n// \t\t\t\tprogressValues.push(progressValue);\r\n// \t\t\t}\r\n// \t\t);\r\n//\r\n// \t\tdef.notify();\r\n// \t\tdef.resolve();\r\n// \t\treturn result;\r\n// \t});\r\n// });\r\n//\r\n// describe(\"all\", function () {\r\n// \tit(\"fulfills when passed an empty array\", function () {\r\n// \t\treturn Q.all([]);\r\n// \t});\r\n//\r\n// \tit(\"rejects after any constituent promise is rejected\", function () {\r\n// \t\tvar toResolve = Q.defer(); // never resolve\r\n// \t\tvar toReject = Q.defer();\r\n// \t\tvar promises = [toResolve.promise, toReject.promise];\r\n// \t\tvar promise = Q.all(promises);\r\n//\r\n// \t\ttoReject.reject(new Error(\"Rejected\"));\r\n//\r\n// \t\treturn Q.delay(250)\r\n// \t\t\t.then(function () {\r\n// \t\t\t\texpect(promise.isRejected()).toBe(true);\r\n// \t\t\t})\r\n// \t\t\t.timeout(1000);\r\n// \t});\r\n//\r\n// \tit(\"resolves foreign thenables\", function () {\r\n// \t\tvar normal = Q(1);\r\n// \t\tvar foreign = { then: function (f) { f(2); } };\r\n//\r\n// \t\treturn Q.all([normal, foreign])\r\n// \t\t\t.then(function (result) {\r\n// \t\t\t\texpect(result).toEqual([1, 2]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"fulfills when passed an sparse array\", function () {\r\n// \t\tvar toResolve = Q.defer();\r\n// \t\tvar promises = [];\r\n// \t\tpromises[0] = Q(0);\r\n// \t\tpromises[2] = toResolve.promise;\r\n// \t\tvar promise = Q.all(promises);\r\n//\r\n// \t\ttoResolve.resolve(2);\r\n//\r\n// \t\treturn promise.then(function (result) {\r\n// \t\t\texpect(result).toEqual([0, void 0, 2]);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"modifies the input array\", function () {\r\n// \t\tvar input = [Q(0), Q(1)];\r\n//\r\n// \t\treturn Q.all(input).then(function (result) {\r\n// \t\t\texpect(result).toBe(input);\r\n// \t\t\texpect(input).toEqual([0, 1]);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"sends { index, value } progress updates\", function () {\r\n// \t\tvar deferred1 = Q.defer();\r\n// \t\tvar deferred2 = Q.defer();\r\n//\r\n// \t\tvar progressValues = [];\r\n//\r\n// \t\tQ.delay(50).then(function () {\r\n// \t\t\tdeferred1.notify(\"a\");\r\n// \t\t});\r\n// \t\tQ.delay(100).then(function () {\r\n// \t\t\tdeferred2.notify(\"b\");\r\n// \t\t\tdeferred2.resolve();\r\n// \t\t});\r\n// \t\tQ.delay(150).then(function () {\r\n// \t\t\tdeferred1.notify(\"c\");\r\n// \t\t\tdeferred1.resolve();\r\n// \t\t});\r\n//\r\n// \t\treturn Q.all([deferred1.promise, deferred2.promise]).then(\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(progressValues).toEqual([\r\n// \t\t\t\t\t{ index: 0, value: \"a\" },\r\n// \t\t\t\t\t{ index: 1, value: \"b\" },\r\n// \t\t\t\t\t{ index: 0, value: \"c\" }\r\n// \t\t\t\t]);\r\n// \t\t\t},\r\n// \t\t\tundefined,\r\n// \t\t\tfunction (progressValue) {\r\n// \t\t\t\tprogressValues.push(progressValue);\r\n// \t\t\t}\r\n// \t\t)\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"any\", function() {\r\n// \tit(\"fulfills when passed an empty array\", function() {\r\n// \t\treturn Q.any([]);\r\n// \t});\r\n//\r\n// \tit(\"rejects after all promises are rejected\", function() {\r\n// \t\tvar deferreds = [Q.defer(), Q.defer()];\r\n// \t\tvar promises = [deferreds[0].promise, deferreds[1].promise];\r\n//\r\n// \t\treturn testReject(promises, deferreds);\r\n// \t});\r\n//\r\n// \tit(\"rejects after all promises in a sparse array are rejected\", function() {\r\n// \t\tvar deferreds = [Q.defer(), Q.defer()];\r\n// \t\tvar promises = [];\r\n// \t\tpromises[0] = deferreds[0].promise;\r\n// \t\tpromises[3] = deferreds[1].promise;\r\n//\r\n// \t\treturn testReject(promises, deferreds);\r\n// \t});\r\n//\r\n// \tfunction testReject(promises, deferreds) {\r\n// \t\tvar promise = Q.any(promises);\r\n// \t\tvar expectedError = new Error('Rejected');\r\n//\r\n// \t\tfor (var index = 0; index < deferreds.length; index++) {\r\n// \t\t\tvar deferred = deferreds[index];\r\n// \t\t\t(function() {\r\n// \t\t\t\tdeferred.reject(expectedError);\r\n// \t\t\t})();\r\n// \t\t}\r\n//\r\n// \t\treturn Q.delay(250)\r\n// \t\t\t.then(function() {\r\n// \t\t\t\texpect(promise.isRejected()).toBe(true);\r\n// \t\t\t\texpect(promise.inspect().reason).toBe(expectedError);\r\n// \t\t\t\texpect(promise.inspect().reason.message)\r\n// \t\t\t\t\t.toBe(\"Q can't get fulfillment value from any promise, all promises were rejected. Last error message: Rejected\");\r\n// \t\t\t})\r\n// \t\t\t.timeout(1000);\r\n// \t}\r\n//\r\n// \tit(\"fulfills with the first resolved promise\", function() {\r\n// \t\tvar deferreds = [Q.defer(), Q.defer()];\r\n// \t\tvar promises = [deferreds[0].promise, deferreds[1].promise];\r\n//\r\n// \t\ttestFulfill(promises, deferreds);\r\n// \t});\r\n//\r\n// \tit(\"fulfills when passed a sparse array\", function() {\r\n// \t\tvar deferreds = [Q.defer(), Q.defer()];\r\n// \t\tvar promises = [];\r\n// \t\tpromises[0] = deferreds[0].promise;\r\n// \t\tpromises[2] = deferreds[1].promise;\r\n//\r\n// \t\ttestFulfill(promises, deferreds);\r\n// \t});\r\n//\r\n// \tfunction testFulfill(promises, deferreds) {\r\n// \t\tvar promise = Q.any(promises);\r\n//\r\n// \t\tvar j = 1;\r\n// \t\tfor (var index = 0; index < deferreds.length; index++) {\r\n// \t\t\tvar toResolve = deferreds[index];\r\n// \t\t\tif (!toResolve || !Q.isPromiseAlike(toResolve.promise)) {\r\n// \t\t\t\tcontinue;\r\n// \t\t\t}\r\n//\r\n// \t\t\t(function(index, toResolve) {\r\n// \t\t\t\tvar time = index * 50;\r\n// \t\t\t\tQ.delay(time).then(function() {\r\n// \t\t\t\t\ttoResolve.resolve('Fulfilled' + index);\r\n// \t\t\t\t});\r\n// \t\t\t})(j, toResolve);\r\n//\r\n// \t\t\tj++;\r\n// \t\t}\r\n//\r\n// \t\treturn Q.delay(400)\r\n// \t\t\t.then(function() {\r\n// \t\t\t\texpect(promise.isFulfilled()).toBe(true);\r\n// \t\t\t\texpect(promise.inspect().value).toBe('Fulfilled1');\r\n// \t\t\t})\r\n// \t\t\t.timeout(1000);\r\n// \t}\r\n//\r\n// \tit(\"fulfills with the first value\", function() {\r\n// \t\tvar toResolve1 = Q.defer();\r\n// \t\tvar toResolve2 = Q.defer();\r\n// \t\tvar toResolve3 = Q.defer();\r\n// \t\tvar promises = [toResolve1.promise, toResolve2.promise, 4, 5,\r\n// \t\t\ttoResolve3.promise\r\n// \t\t];\r\n//\r\n// \t\tvar promise = Q.any(promises);\r\n//\r\n// \t\tQ.delay(150).then(function() {\r\n// \t\t\ttoResolve1.resolve(1);\r\n// \t\t});\r\n// \t\tQ.delay(50).then(function() {\r\n// \t\t\ttoResolve2.resolve(2);\r\n// \t\t});\r\n// \t\tQ.delay(100).then(function() {\r\n// \t\t\ttoResolve3.resolve(3);\r\n// \t\t});\r\n//\r\n// \t\treturn Q.delay(250)\r\n// \t\t\t.then(function() {\r\n// \t\t\t\texpect(promise.isFulfilled()).toBe(true);\r\n// \t\t\t\texpect(promise.inspect().value).toBe(4);\r\n// \t\t\t})\r\n// \t\t\t.timeout(1000);\r\n// \t});\r\n//\r\n// \tit(\"fulfills after rejections\", function() {\r\n// \t\tvar toReject = [Q.defer(), Q.defer()];\r\n// \t\tvar toResolve = Q.defer();\r\n// \t\tvar promises = [toReject[0].promise, toReject[1].promise,\r\n// \t\t\ttoResolve\r\n// \t\t\t\t.promise\r\n// \t\t];\r\n//\r\n// \t\tvar promise = Q.any(promises);\r\n//\r\n// \t\ttestFulfillAfterRejections(promises, toReject, toResolve);\r\n// \t});\r\n//\r\n// \tit(\"fulfills after rejections in sparse array\", function() {\r\n// \t\tvar toReject = [Q.defer(), Q.defer()];\r\n// \t\tvar toResolve = Q.defer();\r\n// \t\tvar promises = [];\r\n// \t\tpromises[2] = toReject[0].promise;\r\n// \t\tpromises[5] = toReject[1].promise;\r\n// \t\tpromises[9] = toResolve.promise;\r\n//\r\n// \t\ttestFulfillAfterRejections(promises, toReject, toResolve);\r\n// \t});\r\n//\r\n// \tfunction testFulfillAfterRejections(promises, rejectDeferreds,\r\n// \t\tfulfillDeferred) {\r\n// \t\tvar promise = Q.any(promises);\r\n//\r\n// \t\tfor (var index = 0; index < rejectDeferreds.length; index++) {\r\n// \t\t\tvar toReject = rejectDeferreds[index];\r\n// \t\t\t(function(index, toReject) {\r\n// \t\t\t\tvar time = (index + 1) * 50;\r\n// \t\t\t\tQ.delay(time).then(function() {\r\n// \t\t\t\t\ttoReject.reject(new Error('Rejected'));\r\n// \t\t\t\t});\r\n// \t\t\t})(index, toReject);\r\n//\r\n// \t\t\tindex++;\r\n// \t\t}\r\n// \t\tQ.delay(index * 50).then(function() {\r\n// \t\t\tfulfillDeferred.resolve('Fulfilled');\r\n// \t\t});\r\n//\r\n// \t\treturn Q.delay(400)\r\n// \t\t\t.then(function() {\r\n// \t\t\t\texpect(promise.isFulfilled()).toBe(true);\r\n// \t\t\t\texpect(promise.inspect().value).toBe('Fulfilled');\r\n// \t\t\t})\r\n// \t\t\t.timeout(1000);\r\n// \t}\r\n//\r\n// \tit(\"resolves foreign thenables\", function() {\r\n// \t\tvar normal = Q.delay(150)\r\n// \t\t\t.then(function() {})\r\n// \t\t\t.thenResolve(1);\r\n// \t\tvar foreign = {\r\n// \t\t\tthen: function(f) {\r\n// \t\t\t\treturn f(2);\r\n// \t\t\t}\r\n// \t\t};\r\n//\r\n// \t\treturn Q.any([normal, foreign])\r\n// \t\t\t.then(function(result) {\r\n// \t\t\t\texpect(result).toEqual(2);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"sends { index, value } progress updates\", function() {\r\n// \t\tvar deferred1 = Q.defer();\r\n// \t\tvar deferred2 = Q.defer();\r\n//\r\n// \t\tvar progressValues = [];\r\n//\r\n// \t\tQ.delay(50).then(function() {\r\n// \t\t\tdeferred1.notify(\"a\");\r\n// \t\t});\r\n// \t\tQ.delay(100).then(function() {\r\n// \t\t\tdeferred2.notify(\"b\");\r\n// \t\t\tdeferred2.resolve();\r\n// \t\t});\r\n// \t\tQ.delay(150).then(function() {\r\n// \t\t\tdeferred1.notify(\"c\"); // Is lost, deferred2 already resolved.\r\n// \t\t\tdeferred1.resolve();\r\n// \t\t});\r\n//\r\n// \t\treturn Q.any([deferred1.promise, deferred2.promise])\r\n// \t\t\t.delay(250)\r\n// \t\t\t.then(function() {\r\n// \t\t\t\t\texpect(progressValues).toEqual([{\r\n// \t\t\t\t\t\tindex: 0,\r\n// \t\t\t\t\t\tvalue: \"a\"\r\n// \t\t\t\t\t}, {\r\n// \t\t\t\t\t\tindex: 1,\r\n// \t\t\t\t\t\tvalue: \"b\"\r\n// \t\t\t\t\t}]);\r\n// \t\t\t\t},\r\n// \t\t\t\tundefined,\r\n// \t\t\t\tfunction(progressValue) {\r\n// \t\t\t\t\tprogressValues.push(progressValue);\r\n// \t\t\t\t}\r\n// \t\t\t);\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"allSettled\", function () {\r\n// \tit(\"works on an empty array\", function () {\r\n// \t\treturn Q.allSettled([])\r\n// \t\t\t.then(function (snapshots) {\r\n// \t\t\t\texpect(snapshots).toEqual([]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"deals with a mix of non-promises and promises\", function () {\r\n// \t\treturn Q.allSettled([1, Q(2), Q.reject(3)])\r\n// \t\t\t.then(function (snapshots) {\r\n// \t\t\t\texpect(snapshots).toEqual([\r\n// \t\t\t\t\t{ state: \"fulfilled\", value: 1 },\r\n// \t\t\t\t\t{ state: \"fulfilled\", value: 2 },\r\n// \t\t\t\t\t{ state: \"rejected\", reason: 3 }\r\n// \t\t\t\t]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"is settled after every constituent promise is settled\", function () {\r\n// \t\tvar toFulfill = Q.defer();\r\n// \t\tvar toReject = Q.defer();\r\n// \t\tvar promises = [toFulfill.promise, toReject.promise];\r\n// \t\tvar fulfilled;\r\n// \t\tvar rejected;\r\n//\r\n// \t\tQ.fcall(function () {\r\n// \t\t\ttoReject.reject();\r\n// \t\t\trejected = true;\r\n// \t\t})\r\n// \t\t\t.delay(15)\r\n// \t\t\t.then(function () {\r\n// \t\t\t\ttoFulfill.resolve();\r\n// \t\t\t\tfulfilled = true;\r\n// \t\t\t});\r\n//\r\n// \t\treturn Q.allSettled(promises)\r\n// \t\t\t.then(function () {\r\n// \t\t\t\texpect(fulfilled).toBe(true);\r\n// \t\t\t\texpect(rejected).toBe(true);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"does not modify the input array\", function () {\r\n// \t\tvar input = [1, Q(2), Q.reject(3)];\r\n//\r\n// \t\treturn Q.allSettled(input)\r\n// \t\t\t.then(function (snapshots) {\r\n// \t\t\t\texpect(snapshots).not.toBe(input);\r\n// \t\t\t\texpect(snapshots).toEqual([\r\n// \t\t\t\t\t{ state: \"fulfilled\", value: 1 },\r\n// \t\t\t\t\t{ state: \"fulfilled\", value: 2 },\r\n// \t\t\t\t\t{ state: \"rejected\", reason: 3 }\r\n// \t\t\t\t]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"spread\", function () {\r\n//\r\n// \tit(\"spreads values across arguments\", function () {\r\n// \t\treturn Q.spread([1, 2, 3], function (a, b) {\r\n// \t\t\texpect(b).toBe(2);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"spreads promises for arrays across arguments\", function () {\r\n// \t\treturn Q([Q(10)])\r\n// \t\t\t.spread(function (value) {\r\n// \t\t\t\texpect(value).toEqual(10);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"spreads arrays of promises across arguments\", function () {\r\n// \t\tvar deferredA = Q.defer();\r\n// \t\tvar deferredB = Q.defer();\r\n//\r\n// \t\tvar promise = Q.spread([deferredA.promise, deferredB.promise],\r\n// \t\t\tfunction (a, b) {\r\n// \t\t\t\texpect(a).toEqual(10);\r\n// \t\t\t\texpect(b).toEqual(20);\r\n// \t\t\t});\r\n//\r\n// \t\tQ.delay(5).then(function () {\r\n// \t\t\tdeferredA.resolve(10);\r\n// \t\t});\r\n// \t\tQ.delay(10).then(function () {\r\n// \t\t\tdeferredB.resolve(20);\r\n// \t\t});\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"calls the errback when given a rejected promise\", function () {\r\n// \t\tvar err = new Error();\r\n// \t\treturn Q.spread([Q(10), Q.reject(err)],\r\n// \t\t\tfunction () {\r\n// \t\t\t\texpect(true).toBe(false);\r\n// \t\t\t},\r\n// \t\t\tfunction (actual) {\r\n// \t\t\t\texpect(actual).toBe(err);\r\n// \t\t\t}\r\n// \t\t);\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"fin\", function () {\r\n//\r\n// \tvar exception1 = new Error(\"boo!\");\r\n// \tvar exception2 = new TypeError(\"evil!\");\r\n//\r\n// \tdescribe(\"when the promise is fulfilled\", function () {\r\n//\r\n// \t\tit(\"should call the callback\", function () {\r\n// \t\t\tvar called = false;\r\n//\r\n// \t\t\treturn Q(\"foo\")\r\n// \t\t\t\t.fin(function () {\r\n// \t\t\t\t\tcalled = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(called).toBe(true);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"should fulfill with the original value\", function () {\r\n// \t\t\treturn Q(\"foo\")\r\n// \t\t\t\t.fin(function () {\r\n// \t\t\t\t\treturn \"bar\";\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function (result) {\r\n// \t\t\t\t\texpect(result).toBe(\"foo\");\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"when the callback returns a promise\", function () {\r\n//\r\n// \t\t\tdescribe(\"that is fulfilled\", function () {\r\n// \t\t\t\tit(\"should fulfill with the original reason after that promise resolves\", function () {\r\n// \t\t\t\t\tvar promise = Q.delay(250);\r\n//\r\n// \t\t\t\t\treturn Q(\"foo\")\r\n// \t\t\t\t\t\t.fin(function () {\r\n// \t\t\t\t\t\t\treturn promise;\r\n// \t\t\t\t\t\t})\r\n// \t\t\t\t\t\t.then(function (result) {\r\n// \t\t\t\t\t\t\texpect(Q.isPending(promise)).toBe(false);\r\n// \t\t\t\t\t\t\texpect(result).toBe(\"foo\");\r\n// \t\t\t\t\t\t});\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n//\r\n// \t\t\tdescribe(\"that is rejected\", function () {\r\n// \t\t\t\tit(\"should reject with this new rejection reason\", function () {\r\n// \t\t\t\t\treturn Q(\"foo\")\r\n// \t\t\t\t\t\t.fin(function () {\r\n// \t\t\t\t\t\t\treturn Q.reject(exception1);\r\n// \t\t\t\t\t\t})\r\n// \t\t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t\t},\r\n// \t\t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\t\texpect(exception).toBe(exception1);\r\n// \t\t\t\t\t\t\t});\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n//\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"when the callback throws an exception\", function () {\r\n// \t\t\tit(\"should reject with this new exception\", function () {\r\n// \t\t\t\treturn Q(\"foo\")\r\n// \t\t\t\t\t.fin(function () {\r\n// \t\t\t\t\t\tthrow exception1;\r\n// \t\t\t\t\t})\r\n// \t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\texpect(exception).toBe(exception1);\r\n// \t\t\t\t\t\t});\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"when the promise is rejected\", function () {\r\n//\r\n// \t\tit(\"should call the callback\", function () {\r\n// \t\t\tvar called = false;\r\n//\r\n// \t\t\treturn Q.reject(exception1)\r\n// \t\t\t\t.fin(function () {\r\n// \t\t\t\t\tcalled = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(called).toBe(true);\r\n// \t\t\t\t}, function () {\r\n// \t\t\t\t\texpect(called).toBe(true);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"should reject with the original reason\", function () {\r\n// \t\t\treturn Q.reject(exception1)\r\n// \t\t\t\t.fin(function () {\r\n// \t\t\t\t\treturn \"bar\";\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t},\r\n// \t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\texpect(exception).toBe(exception1);\r\n// \t\t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"when the callback returns a promise\", function () {\r\n//\r\n// \t\t\tdescribe(\"that is fulfilled\", function () {\r\n// \t\t\t\tit(\"should reject with the original reason after that promise resolves\", function () {\r\n// \t\t\t\t\tvar promise = Q.delay(250);\r\n//\r\n// \t\t\t\t\treturn Q.reject(exception1)\r\n// \t\t\t\t\t\t.fin(function () {\r\n// \t\t\t\t\t\t\treturn promise;\r\n// \t\t\t\t\t\t})\r\n// \t\t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t\t},\r\n// \t\t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\t\texpect(exception).toBe(exception1);\r\n// \t\t\t\t\t\t\t\texpect(Q.isPending(promise)).toBe(false);\r\n// \t\t\t\t\t\t\t});\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n//\r\n// \t\t\tdescribe(\"that is rejected\", function () {\r\n// \t\t\t\tit(\"should reject with the new reason\", function () {\r\n// \t\t\t\t\treturn Q.reject(exception1)\r\n// \t\t\t\t\t\t.fin(function () {\r\n// \t\t\t\t\t\t\treturn Q.reject(exception2);\r\n// \t\t\t\t\t\t})\r\n// \t\t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t\t},\r\n// \t\t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\t\texpect(exception).toBe(exception2);\r\n// \t\t\t\t\t\t\t});\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n//\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"when the callback throws an exception\", function () {\r\n// \t\t\tit(\"should reject with this new exception\", function () {\r\n// \t\t\t\treturn Q.reject(exception1)\r\n// \t\t\t\t\t.fin(function () {\r\n// \t\t\t\t\t\tthrow exception2;\r\n// \t\t\t\t\t})\r\n// \t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\texpect(exception).toBe(exception2);\r\n// \t\t\t\t\t\t});\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"when the callback is invalid\", function () {\r\n// \t\tdescribe(\"undefined\", function () {\r\n// \t\t\tit(\"should have a useful error\", function () {\r\n// \t\t\t\tvar foo = {},\r\n// \t\t\t\t    threw = false;\r\n//\r\n// \t\t\t\ttry {\r\n// \t\t\t\t\tQ().fin(foo.bar);\r\n// \t\t\t\t} catch (err) {\r\n// \t\t\t\t\texpect(err.message).toBe(\"Q can't apply finally callback\");\r\n// \t\t\t\t\tthrew = true;\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\texpect(threw).toBe(true);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"not a function\", function () {\r\n// \t\t\tit(\"should have a useful error\", function () {\r\n// \t\t\t\tvar threw = false;\r\n//\r\n// \t\t\t\ttry {\r\n// \t\t\t\t\tQ().fin(123);\r\n// \t\t\t\t} catch (err) {\r\n// \t\t\t\t\texpect(err.message).toBe(\"Q can't apply finally callback\");\r\n// \t\t\t\t\tthrew = true;\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\texpect(threw).toBe(true);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n// });\r\n//\r\n// // Almost like \"fin\"\r\n// describe(\"tap\", function () {\r\n// \tvar exception1 = new Error(\"boo!\");\r\n//\r\n// \tdescribe(\"when the promise is fulfilled\", function () {\r\n// \t\tit(\"should call the callback\", function () {\r\n// \t\t\tvar called = false;\r\n// \t\t\treturn Q(\"foo\")\r\n// \t\t\t\t.tap(function () {\r\n// \t\t\t\t\tcalled = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(called).toBe(true);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"should fulfill with the original value\", function () {\r\n// \t\t\treturn Q(\"foo\")\r\n// \t\t\t\t.tap(function () {\r\n// \t\t\t\t\treturn \"bar\";\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function (result) {\r\n// \t\t\t\t\texpect(result).toBe(\"foo\");\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"when the callback returns a promise\", function () {\r\n// \t\t\tdescribe(\"that is fulfilled\", function () {\r\n// \t\t\t\tit(\"should fulfill with the original reason after that promise resolves\", function () {\r\n// \t\t\t\t\tvar promise = Q.delay(250);\r\n//\r\n// \t\t\t\t\treturn Q(\"foo\")\r\n// \t\t\t\t\t\t.tap(function () {\r\n// \t\t\t\t\t\t\treturn promise;\r\n// \t\t\t\t\t\t})\r\n// \t\t\t\t\t\t.then(function (result) {\r\n// \t\t\t\t\t\t\texpect(Q.isPending(promise)).toBe(false);\r\n// \t\t\t\t\t\t\texpect(result).toBe(\"foo\");\r\n// \t\t\t\t\t\t});\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n//\r\n// \t\t\tdescribe(\"that is rejected\", function () {\r\n// \t\t\t\tit(\"should reject with this new rejection reason\", function () {\r\n// \t\t\t\t\treturn Q(\"foo\")\r\n// \t\t\t\t\t\t.tap(function () {\r\n// \t\t\t\t\t\t\treturn Q.reject(exception1);\r\n// \t\t\t\t\t\t})\r\n// \t\t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t\t},\r\n// \t\t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\t\texpect(exception).toBe(exception1);\r\n// \t\t\t\t\t\t\t});\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n//\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"when the callback throws an exception\", function () {\r\n// \t\t\tit(\"should reject with this new exception\", function () {\r\n// \t\t\t\treturn Q(\"foo\")\r\n// \t\t\t\t\t.tap(function () {\r\n// \t\t\t\t\t\tthrow exception1;\r\n// \t\t\t\t\t})\r\n// \t\t\t\t\t.then(function () {\r\n// \t\t\t\t\t\t\texpect(false).toBe(true);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\tfunction (exception) {\r\n// \t\t\t\t\t\t\texpect(exception).toBe(exception1);\r\n// \t\t\t\t\t\t});\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"when the promise is rejected\", function () {\r\n// \t\tit(\"should not call the callback\", function () {\r\n// \t\t\tvar called = false;\r\n//\r\n// \t\t\treturn Q.reject(exception1)\r\n// \t\t\t\t.tap(function () {\r\n// \t\t\t\t\tcalled = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(called).toBe(false);\r\n// \t\t\t\t}, function () {\r\n// \t\t\t\t\texpect(called).toBe(false);\r\n// \t\t\t\t});\r\n// \t\t});\r\n// \t});\r\n// });\r\n//\r\n//\r\n// describe(\"done\", function () {\r\n// \tdescribe(\"when the promise is fulfilled\", function () {\r\n// \t\tdescribe(\"and the callback does not throw\", function () {\r\n// \t\t\tit(\"should call the callback and return nothing\", function () {\r\n// \t\t\t\tvar called = false;\r\n//\r\n// \t\t\t\tvar promise = Q();\r\n//\r\n// \t\t\t\tvar returnValue = promise.done(function () {\r\n// \t\t\t\t\tcalled = true;\r\n// \t\t\t\t});\r\n//\r\n// \t\t\t\treturn promise.fail(function () { }).fin(function () {\r\n// \t\t\t\t\texpect(called).toBe(true);\r\n// \t\t\t\t\texpect(returnValue).toBe(undefined);\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"and the callback throws\", function () {\r\n// \t\t\tit(\"should rethrow that error in the next turn and return nothing\", function () {\r\n// \t\t\t\tvar turn = 0;\r\n// \t\t\t\tQ.nextTick(function () {\r\n// \t\t\t\t\t++turn;\r\n// \t\t\t\t});\r\n//\r\n// \t\t\t\tvar returnValue = Q().done(\r\n// \t\t\t\t\tfunction () {\r\n// \t\t\t\t\t\tthrow \"foo\";\r\n// \t\t\t\t\t}\r\n// \t\t\t\t);\r\n//\r\n// \t\t\t\tvar deferred = Q.defer();\r\n// \t\t\t\tQ.onerror = function (error) {\r\n// \t\t\t\t\texpect(turn).toBe(1);\r\n// \t\t\t\t\texpect(error).toBe(\"foo\");\r\n// \t\t\t\t\texpect(returnValue).toBe(undefined);\r\n// \t\t\t\t\tdeferred.resolve();\r\n// \t\t\t\t};\r\n// \t\t\t\tQ.delay(100).then(deferred.reject);\r\n//\r\n// \t\t\t\treturn deferred.promise;\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"when the promise is rejected\", function () {\r\n// \t\tdescribe(\"and the errback handles it\", function () {\r\n// \t\t\tit(\"should call the errback and return nothing\", function () {\r\n// \t\t\t\tvar called = false;\r\n//\r\n// \t\t\t\tvar promise = Q.reject(new Error());\r\n//\r\n// \t\t\t\tvar returnValue = promise.done(\r\n// \t\t\t\t\tfunction () { },\r\n// \t\t\t\t\tfunction () {\r\n// \t\t\t\t\t\tcalled = true;\r\n// \t\t\t\t\t}\r\n// \t\t\t\t);\r\n//\r\n// \t\t\t\treturn promise.fail(function () { }).fin(function () {\r\n// \t\t\t\t\texpect(called).toBe(true);\r\n// \t\t\t\t\texpect(returnValue).toBe(undefined);\r\n// \t\t\t\t});\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"and the errback throws\", function () {\r\n// \t\t\tit(\"should rethrow that error in the next turn and return nothing\", function () {\r\n// \t\t\t\tvar turn = 0;\r\n// \t\t\t\tQ.nextTick(function () {\r\n// \t\t\t\t\t++turn;\r\n// \t\t\t\t});\r\n//\r\n// \t\t\t\tvar returnValue = Q.reject(\"bar\").done(\r\n// \t\t\t\t\tnull,\r\n// \t\t\t\t\tfunction () {\r\n// \t\t\t\t\t\tthrow \"foo\";\r\n// \t\t\t\t\t}\r\n// \t\t\t\t);\r\n//\r\n// \t\t\t\tvar deferred = Q.defer();\r\n// \t\t\t\tQ.onerror = function (error) {\r\n// \t\t\t\t\texpect(turn).toBe(1);\r\n// \t\t\t\t\texpect(error).toBe(\"foo\");\r\n// \t\t\t\t\texpect(returnValue).toBe(undefined);\r\n// \t\t\t\t\tdeferred.resolve();\r\n// \t\t\t\t};\r\n// \t\t\t\tQ.delay(100).then(deferred.reject);\r\n//\r\n// \t\t\t\treturn deferred.promise;\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"and there is no errback\", function () {\r\n// \t\t\tit(\"should throw the original error in the next turn\", function () {\r\n// \t\t\t\tvar turn = 0;\r\n// \t\t\t\tQ.nextTick(function () {\r\n// \t\t\t\t\t++turn;\r\n// \t\t\t\t});\r\n//\r\n// \t\t\t\tvar returnValue = Q.reject(\"bar\").done();\r\n//\r\n// \t\t\t\tvar deferred = Q.defer();\r\n// \t\t\t\tQ.onerror = function (error) {\r\n// \t\t\t\t\texpect(turn).toBe(1);\r\n// \t\t\t\t\texpect(error).toBe(\"bar\");\r\n// \t\t\t\t\texpect(returnValue).toBe(undefined);\r\n// \t\t\t\t\tdeferred.resolve();\r\n// \t\t\t\t};\r\n// \t\t\t\tQ.delay(10).then(deferred.reject);\r\n//\r\n// \t\t\t\treturn deferred.promise;\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"should attach a progress listener\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tvar spy = jasmine.createSpy();\r\n// \t\tdeferred.promise.done(null, null, spy);\r\n//\r\n// \t\tdeferred.notify(10);\r\n// \t\tdeferred.resolve();\r\n//\r\n// \t\treturn deferred.promise.then(function () {\r\n// \t\t\texpect(spy).toHaveBeenCalledWith(10);\r\n// \t\t});\r\n// \t});\r\n// });\r\n//\r\n// describe(\"timeout\", function () {\r\n// \tit(\"should do nothing if the promise fulfills quickly\", function () {\r\n// \t\treturn Q.delay(10).timeout(200);\r\n// \t});\r\n//\r\n// \tit(\"should do nothing if the promise rejects quickly\", function () {\r\n// \t\tvar goodError = new Error(\"haha!\");\r\n// \t\treturn Q.delay(10)\r\n// \t\t\t.then(function () {\r\n// \t\t\t\tthrow goodError;\r\n// \t\t\t})\r\n// \t\t\t.timeout(200)\r\n// \t\t\t.then(undefined, function (error) {\r\n// \t\t\t\texpect(error).toBe(goodError);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"should reject with a timeout error if the promise is too slow\", function () {\r\n// \t\treturn Q.delay(100)\r\n// \t\t\t.timeout(10)\r\n// \t\t\t.then(\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction (error) {\r\n// \t\t\t\t\texpect(/time/i.test(error.message)).toBe(true);\r\n// \t\t\t\t}\r\n// \t\t\t);\r\n// \t});\r\n//\r\n// \tit(\"should pass through progress notifications\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tvar progressValsSeen = [];\r\n// \t\tvar promise = Q.timeout(deferred.promise, 300).then(function () {\r\n// \t\t\texpect(progressValsSeen).toEqual([1, 2, 3]);\r\n// \t\t}, undefined, function (progressVal) {\r\n// \t\t\tprogressValsSeen.push(progressVal);\r\n// \t\t});\r\n//\r\n// \t\tQ.delay(5).then(function () { deferred.notify(1); });\r\n// \t\tQ.delay(15).then(function () { deferred.notify(2); });\r\n// \t\tQ.delay(25).then(function () { deferred.notify(3); });\r\n// \t\tQ.delay(35).then(function () { deferred.resolve(); });\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should reject with a custom timeout error if the promise is too slow and msg was provided\", function () {\r\n// \t\treturn Q.delay(100)\r\n// \t\t\t.timeout(10, \"custom\")\r\n// \t\t\t.then(\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction (error) {\r\n// \t\t\t\t\texpect(/custom/i.test(error.message)).toBe(true);\r\n// \t\t\t\t\texpect(error.code).toBe(\"ETIMEDOUT\");\r\n// \t\t\t\t}\r\n// \t\t\t);\r\n// \t});\r\n//\r\n// \tit(\"should reject with a custom timeout error if the promise is too slow and Error object was provided\", function () {\r\n// \t\tvar customError = new Error(\"custom\");\r\n// \t\tcustomError.isCustom = true;\r\n// \t\treturn Q.delay(100)\r\n// \t\t\t.timeout(10, customError)\r\n// \t\t\t.then(\r\n// \t\t\t\tfunction () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t},\r\n// \t\t\t\tfunction (error) {\r\n// \t\t\t\t\texpect(/custom/i.test(error.message)).toBe(true);\r\n// \t\t\t\t\texpect(error.isCustom).toBe(true);\r\n// \t\t\t\t}\r\n// \t\t\t);\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"delay\", function () {\r\n// \tit(\"should delay fulfillment\", function () {\r\n// \t\tvar promise = Q(5).delay(50);\r\n//\r\n// \t\tsetTimeout(function () {\r\n// \t\t\texpect(promise.isPending()).toBe(true);\r\n// \t\t}, 40);\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should not delay rejection\", function () {\r\n// \t\tvar promise = Q.reject(5).delay(50);\r\n//\r\n// \t\treturn Q.delay(20).then(function () {\r\n// \t\t\texpect(promise.isPending()).toBe(false);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"should treat a single argument as a time\", function () {\r\n// \t\tvar promise = Q.delay(50);\r\n//\r\n// \t\tsetTimeout(function () {\r\n// \t\t\texpect(promise.isPending()).toBe(true);\r\n// \t\t}, 40);\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n//\r\n// \tit(\"should treat two arguments as a value + a time\", function () {\r\n// \t\tvar promise = Q.delay(\"what\", 50);\r\n//\r\n// \t\tsetTimeout(function () {\r\n// \t\t\texpect(promise.isPending()).toBe(true);\r\n// \t\t}, 40);\r\n//\r\n// \t\treturn promise.then(function (value) {\r\n// \t\t\texpect(value).toBe(\"what\");\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"should delay after resolution\", function () {\r\n// \t\tvar promise1 = Q.delay(\"what\", 30);\r\n// \t\tvar promise2 = promise1.delay(30);\r\n//\r\n// \t\tsetTimeout(function () {\r\n// \t\t\texpect(promise1.isPending()).toBe(false);\r\n// \t\t\texpect(promise2.isPending()).toBe(true);\r\n// \t\t}, 40);\r\n//\r\n// \t\treturn promise2.then(function (value) {\r\n// \t\t\texpect(value).toBe(\"what\");\r\n// \t\t});\r\n// \t});\r\n//\r\n//\r\n// \tit(\"should pass through progress notifications from passed promises\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n//\r\n// \t\tvar progressValsSeen = [];\r\n// \t\tvar promise = Q.delay(deferred.promise, 100).then(function () {\r\n// \t\t\texpect(progressValsSeen).toEqual([1, 2, 3]);\r\n// \t\t}, undefined, function (progressVal) {\r\n// \t\t\tprogressValsSeen.push(progressVal);\r\n// \t\t});\r\n//\r\n// \t\tQ.delay(5).then(function () { deferred.notify(1); });\r\n// \t\tQ.delay(15).then(function () { deferred.notify(2); });\r\n// \t\tQ.delay(25).then(function () { deferred.notify(3); });\r\n// \t\tQ.delay(35).then(function () { deferred.resolve(); });\r\n//\r\n// \t\treturn promise;\r\n// \t});\r\n// });\r\n//\r\n// describe(\"thenResolve\", function () {\r\n// \tdescribe(\"Resolving with a non-thenable value\", function () {\r\n// \t\tit(\"returns a promise for that object once the promise is resolved\", function () {\r\n// \t\t\tvar waited = false;\r\n// \t\t\treturn Q.delay(20)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\twaited = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.thenResolve(\"foo\")\r\n// \t\t\t\t.then(function (val) {\r\n// \t\t\t\t\texpect(waited).toBe(true);\r\n// \t\t\t\t\texpect(val).toBe(\"foo\");\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"based off a rejected promise\", function () {\r\n// \t\t\tit(\"does nothing, letting the rejection flow through\", function () {\r\n// \t\t\t\treturn Q.reject(\"boo\")\r\n// \t\t\t\t\t.thenResolve(\"foo\")\r\n// \t\t\t\t\t.then(\r\n// \t\t\t\t\t\tfunction () {\r\n// \t\t\t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\tfunction (reason) {\r\n// \t\t\t\t\t\t\texpect(reason).toBe(\"boo\");\r\n// \t\t\t\t\t\t}\r\n// \t\t\t\t\t);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"Resolving with an promise\", function () {\r\n// \t\tit(\"returns a promise for the result of that promise once the promise is resolved\", function () {\r\n// \t\t\tvar waited = false;\r\n// \t\t\treturn Q.delay(20)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\twaited = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.thenResolve(Q(\"foo\"))\r\n// \t\t\t\t.then(function (val) {\r\n// \t\t\t\t\texpect(waited).toBe(true);\r\n// \t\t\t\t\texpect(val).toBe(\"foo\");\r\n// \t\t\t\t});\r\n// \t\t});\r\n// \t});\r\n// });\r\n//\r\n// describe(\"thenReject\", function () {\r\n// \tdescribe(\"Rejecting with a reason\", function () {\r\n// \t\tit(\"returns a promise rejected with that object once the original promise is resolved\", function () {\r\n// \t\t\tvar waited = false;\r\n// \t\t\treturn Q.delay(20)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\twaited = true;\r\n// \t\t\t\t})\r\n// \t\t\t\t.thenReject(\"foo\")\r\n// \t\t\t\t.then(\r\n// \t\t\t\t\tfunction () {\r\n// \t\t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t\t},\r\n// \t\t\t\t\tfunction (reason) {\r\n// \t\t\t\t\t\texpect(waited).toBe(true);\r\n// \t\t\t\t\t\texpect(reason).toBe(\"foo\");\r\n// \t\t\t\t\t}\r\n// \t\t\t\t);\r\n// \t\t});\r\n//\r\n// \t\tdescribe(\"based off a rejected promise\", function () {\r\n// \t\t\tit(\"does nothing, letting the rejection flow through\", function () {\r\n// \t\t\t\treturn Q.reject(\"boo\")\r\n// \t\t\t\t\t.thenResolve(\"foo\")\r\n// \t\t\t\t\t.then(\r\n// \t\t\t\t\t\tfunction () {\r\n// \t\t\t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t\t\t},\r\n// \t\t\t\t\t\tfunction (reason) {\r\n// \t\t\t\t\t\t\texpect(reason).toBe(\"boo\");\r\n// \t\t\t\t\t\t}\r\n// \t\t\t\t\t);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n// });\r\n//\r\n// describe(\"thenables\", function () {\r\n//\r\n// \tit(\"assimilates a thenable with fulfillment with resolve\", function () {\r\n// \t\treturn Q({\r\n// \t\t\tthen: function (resolved) {\r\n// \t\t\t\tresolved(10);\r\n// \t\t\t}\r\n// \t\t})\r\n// \t\t\t.then(function (ten) {\r\n// \t\t\t\texpect(ten).toEqual(10);\r\n// \t\t\t})\r\n// \t\t\t.then(function (undefined) {\r\n// \t\t\t\texpect(undefined).toEqual(void 0);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"assimilates a thenable with progress and fulfillment (using resolve)\", function () {\r\n// \t\tvar progressValueArrays = [];\r\n// \t\treturn Q({\r\n// \t\t\tthen: function (fulfilled, rejected, progressed) {\r\n// \t\t\t\tQ.nextTick(function () {\r\n// \t\t\t\t\tprogressed(1, 2);\r\n// \t\t\t\t\tprogressed(3, 4, 5);\r\n// \t\t\t\t\tfulfilled();\r\n// \t\t\t\t});\r\n// \t\t\t}\r\n// \t\t})\r\n// \t\t\t.progress(function () {\r\n// \t\t\t\tprogressValueArrays.push(Array.prototype.slice.call(arguments));\r\n// \t\t\t})\r\n// \t\t\t.then(function () {\r\n// \t\t\t\texpect(progressValueArrays).toEqual([[1], [3]]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"assimilates a thenable with progress and fulfillment (using when)\", function () {\r\n// \t\tvar progressValueArrays = [];\r\n// \t\treturn Q.when({\r\n// \t\t\tthen: function (fulfilled, rejected, progressed) {\r\n// \t\t\t\tQ.nextTick(function () {\r\n// \t\t\t\t\tprogressed(1, 2);\r\n// \t\t\t\t\tprogressed(3, 4, 5);\r\n// \t\t\t\t\tfulfilled();\r\n// \t\t\t\t});\r\n// \t\t\t}\r\n// \t\t})\r\n// \t\t\t.progress(function () {\r\n// \t\t\t\tprogressValueArrays.push(Array.prototype.slice.call(arguments));\r\n// \t\t\t})\r\n// \t\t\t.then(function () {\r\n// \t\t\t\texpect(progressValueArrays).toEqual([[1], [3]]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"flows fulfillment into a promise pipeline\", function () {\r\n// \t\treturn Q({\r\n// \t\t\tthen: function (resolved) {\r\n// \t\t\t\tresolved([10]);\r\n// \t\t\t}\r\n// \t\t})\r\n// \t\t\t.get(0)\r\n// \t\t\t.then(function (ten) {\r\n// \t\t\t\texpect(ten).toEqual(10);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"assimilates an immediately-fulfilled thenable in allSettled\", function () {\r\n// \t\treturn Q.allSettled([\r\n// \t\t\t{then: function (win) {\r\n// \t\t\t\twin(10);\r\n// \t\t\t}}\r\n// \t\t])\r\n// \t\t\t.then(function (snapshots) {\r\n// \t\t\t\texpect(snapshots).toEqual([{ state: \"fulfilled\", value: 10 }]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// \tit(\"assimilates an eventually-fulfilled thenable in allSettled\", function () {\r\n// \t\treturn Q.allSettled([\r\n// \t\t\t{then: function (win) {\r\n// \t\t\t\tsetTimeout(function () {\r\n// \t\t\t\t\twin(10);\r\n// \t\t\t\t}, 100);\r\n// \t\t\t}}\r\n// \t\t])\r\n// \t\t\t.then(function (snapshots) {\r\n// \t\t\t\texpect(snapshots).toEqual([{ state: \"fulfilled\", value: 10 }]);\r\n// \t\t\t});\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"node support\", function () {\r\n//\r\n// \tvar exception = new Error(\"That is not your favorite color.\");\r\n//\r\n// \tvar obj = {\r\n// \t\tmethod: function (a, b, c, callback) {\r\n// \t\t\tcallback(null, a + b + c);\r\n// \t\t},\r\n// \t\tthispChecker: function (callback) {\r\n// \t\t\tcallback(null, this === obj);\r\n// \t\t},\r\n// \t\terrorCallbacker: function (a, b, c, callback) {\r\n// \t\t\tcallback(exception);\r\n// \t\t},\r\n// \t\terrorThrower: function () {\r\n// \t\t\tthrow exception;\r\n// \t\t}\r\n// \t};\r\n//\r\n// \tdescribe(\"nfapply\", function () {\r\n//\r\n// \t\tit(\"fulfills with callback result\", function () {\r\n// \t\t\treturn Q.nfapply(function (a, b, c, callback) {\r\n// \t\t\t\tcallback(null, a + b + c);\r\n// \t\t\t}, [1, 2, 3])\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects with callback error\", function () {\r\n// \t\t\tvar exception = new Error(\"That is not your favorite color.\");\r\n// \t\t\treturn Q.nfapply(function (a, b, c, callback) {\r\n// \t\t\t\tcallback(exception);\r\n// \t\t\t}, [1, 2, 3])\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"nfcall\", function () {\r\n// \t\tit(\"fulfills with callback result\", function () {\r\n// \t\t\treturn Q.nfcall(function (a, b, c, callback) {\r\n// \t\t\t\tcallback(null, a + b + c);\r\n// \t\t\t}, 1, 2, 3)\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects with callback error\", function () {\r\n// \t\t\tvar exception = new Error(\"That is not your favorite color.\");\r\n// \t\t\treturn Q.nfcall(function (a, b, c, callback) {\r\n// \t\t\t\tcallback(exception);\r\n// \t\t\t}, 1, 2, 3)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"nfbind\", function () {\r\n//\r\n// \t\tit(\"mixes partial application with complete application\", function () {\r\n// \t\t\treturn Q.nfbind(function (a, b, c, d, callback) {\r\n// \t\t\t\tcallback(null, a + b + c + d);\r\n// \t\t\t}, 1, 2).call({}, 3, 4)\r\n// \t\t\t\t.then(function (ten) {\r\n// \t\t\t\t\texpect(ten).toBe(10);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"nbind\", function () {\r\n//\r\n// \t\tit(\"binds this, and mixes partial application with complete application\", function () {\r\n// \t\t\treturn Q.nbind(function (a, b, c, callback) {\r\n// \t\t\t\tcallback(null, this + a + b + c);\r\n// \t\t\t}, 1, 2).call(3 /* effectively ignored as fn bound to 1 */, 4, 5)\r\n// \t\t\t\t.then(function (twelve) {\r\n// \t\t\t\t\texpect(twelve).toBe(12);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"second arg binds this\", function() {\r\n// \t\t\tvar expectedThis = { test: null };\r\n//\r\n// \t\t\treturn Q.nbind(function(callback) {\r\n// \t\t\t\tcallback(null, this);\r\n// \t\t\t}, expectedThis).call()\r\n// \t\t\t\t.then(function(actualThis) {\r\n// \t\t\t\t\texpect(actualThis).toEqual(expectedThis);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"npost\", function () {\r\n//\r\n// \t\tit(\"fulfills with callback result\", function () {\r\n// \t\t\treturn Q.npost(obj, \"method\", [1, 2, 3])\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"gets the correct thisp\", function () {\r\n// \t\t\treturn Q.npost(obj, \"thispChecker\", [])\r\n// \t\t\t\t.then(function (result) {\r\n// \t\t\t\t\texpect(result).toBe(true);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects with callback error\", function () {\r\n// \t\t\treturn Q.npost(obj, \"errorCallbacker\", [1, 2, 3])\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"blue\").toBe(\"no, yellow!\");\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects with thrown error\", function () {\r\n// \t\t\treturn Q.npost(obj, \"errorThrower\", [1, 2, 3])\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"works on promises for objects with Node methods\", function () {\r\n// \t\t\treturn Q(obj)\r\n// \t\t\t\t.npost(\"method\", [1, 2, 3])\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"nsend\", function () {\r\n//\r\n// \t\tit(\"fulfills with callback result\", function () {\r\n// \t\t\treturn Q.nsend(obj, \"method\", 1, 2, 3)\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"gets the correct thisp\", function () {\r\n// \t\t\treturn Q.nsend(obj, \"thispChecker\")\r\n// \t\t\t\t.then(function (result) {\r\n// \t\t\t\t\texpect(result).toBe(true);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects with callback error\", function () {\r\n// \t\t\treturn Q.nsend(obj, \"errorCallbacker\", 1, 2, 3)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(\"blue\").toBe(\"no, yellow!\");\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects with thrown error\", function () {\r\n// \t\t\treturn Q.nsend(obj, \"errorThrower\", 1, 2, 3)\r\n// \t\t\t\t.then(function () {\r\n// \t\t\t\t\texpect(true).toBe(false);\r\n// \t\t\t\t}, function (_exception) {\r\n// \t\t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"works on promises for objects with Node methods\", function () {\r\n// \t\t\treturn Q(obj)\r\n// \t\t\t\t.nsend(\"method\", 1, 2, 3)\r\n// \t\t\t\t.then(function (sum) {\r\n// \t\t\t\t\texpect(sum).toEqual(6);\r\n// \t\t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"deferred.makeNodeResolver\", function () {\r\n//\r\n// \t\tit(\"fulfills a promise with a single callback argument\", function () {\r\n// \t\t\tvar deferred = Q.defer();\r\n// \t\t\tvar callback = deferred.makeNodeResolver();\r\n// \t\t\tcallback(null, 10);\r\n// \t\t\treturn deferred.promise.then(function (value) {\r\n// \t\t\t\texpect(value).toBe(10);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"fulfills a promise with multiple callback arguments\", function () {\r\n// \t\t\tvar deferred = Q.defer();\r\n// \t\t\tvar callback = deferred.makeNodeResolver();\r\n// \t\t\tcallback(null, 10, 20);\r\n// \t\t\treturn deferred.promise.then(function (value) {\r\n// \t\t\t\texpect(value).toEqual([10, 20]);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"rejects a promise\", function () {\r\n// \t\t\tvar deferred = Q.defer();\r\n// \t\t\tvar callback = deferred.makeNodeResolver();\r\n// \t\t\tvar exception = new Error(\"Holy Exception of Anitoch\");\r\n// \t\t\tcallback(exception);\r\n// \t\t\treturn deferred.promise.then(function () {\r\n// \t\t\t\texpect(5).toBe(3);\r\n// \t\t\t}, function (_exception) {\r\n// \t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// \tdescribe(\"nodeify\", function () {\r\n//\r\n// \t\tit(\"calls back with a resolution\", function () {\r\n// \t\t\tvar spy = jasmine.createSpy();\r\n// \t\t\tQ(10).nodeify(spy);\r\n// \t\t\twaitsFor(function () {\r\n// \t\t\t\treturn spy.argsForCall.length;\r\n// \t\t\t});\r\n// \t\t\truns(function () {\r\n// \t\t\t\texpect(spy.argsForCall).toEqual([[null, 10]]);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"calls back with an error\", function () {\r\n// \t\t\tvar spy = jasmine.createSpy();\r\n// \t\t\tQ.reject(10).nodeify(spy);\r\n// \t\t\twaitsFor(function () {\r\n// \t\t\t\treturn spy.argsForCall.length;\r\n// \t\t\t});\r\n// \t\t\truns(function () {\r\n// \t\t\t\texpect(spy.argsForCall).toEqual([[10]]);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t\tit(\"forwards a promise\", function () {\r\n// \t\t\treturn Q(10).nodeify().then(function (ten) {\r\n// \t\t\t\texpect(ten).toBe(10);\r\n// \t\t\t});\r\n// \t\t});\r\n//\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"browser support\", function () {\r\n// \tvar _Q;\r\n//\r\n// \tbeforeEach(function() {\r\n// \t\t_Q = Q;\r\n// \t});\r\n//\r\n// \tafterEach(function() {\r\n// \t\tQ = _Q;\r\n// \t});\r\n//\r\n// \tit(\"sets the global Q object to its original value\", function() {\r\n// \t\tif (typeof window !== 'undefined') {\r\n// \t\t\t// If window is not undefined, the tests are running in the browser\r\n// \t\t\t// assert that Q.noConflict returns window.Q to it's initial value\r\n// \t\t\t// In this context the original value of Q is undefined\r\n// \t\t\tQ.noConflict();\r\n// \t\t\texpect(Q).toEqual(undefined);\r\n// \t\t}\r\n// \t});\r\n//\r\n// \tit(\"throws an error if Q.noConflict is called in node\", function () {\r\n// \t\tif (typeof window === 'undefined') {\r\n// \t\t\t// If window is undefined the tests are being run in node, and\r\n// \t\t\t// Q.noConflict should throw an error\r\n// \t\t\texpect(Q.noConflict).toThrow();\r\n// \t\t}\r\n// \t});\r\n// });\r\n//\r\n// describe(\"isPromise\", function () {\r\n// \tit(\"returns true if passed a promise\", function () {\r\n// \t\texpect(Q.isPromise(Q(10))).toBe(true);\r\n// \t});\r\n//\r\n// \tit(\"returns false if not passed a promise\", function () {\r\n// \t\texpect(Q.isPromise(undefined)).toBe(false);\r\n// \t\texpect(Q.isPromise(null)).toBe(false);\r\n// \t\texpect(Q.isPromise(10)).toBe(false);\r\n// \t\texpect(Q.isPromise(\"str\")).toBe(false);\r\n// \t\texpect(Q.isPromise(\"\")).toBe(false);\r\n// \t\texpect(Q.isPromise(true)).toBe(false);\r\n// \t\texpect(Q.isPromise(false)).toBe(false);\r\n// \t\texpect(Q.isPromise({})).toBe(false);\r\n// \t\texpect(Q.isPromise({\r\n// \t\t\tthen: function () {}\r\n// \t\t})).toBe(false);\r\n// \t\texpect(Q.isPromise(function () {})).toBe(false);\r\n// \t});\r\n// });\r\n//\r\n// describe(\"isPromiseAlike\", function () {\r\n// \tit(\"returns true if passed a promise like object\", function () {\r\n// \t\texpect(Q.isPromiseAlike(Q(10))).toBe(true);\r\n// \t\texpect(Q.isPromiseAlike({\r\n// \t\t\tthen: function () {}\r\n// \t\t})).toBe(true);\r\n// \t});\r\n//\r\n// \tit(\"returns false if not passed a promise like object\", function () {\r\n// \t\texpect(Q.isPromiseAlike(undefined)).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(null)).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(10)).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(\"str\")).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(\"\")).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(true)).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(false)).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike({})).toBe(false);\r\n// \t\texpect(Q.isPromiseAlike(function () {})).toBe(false);\r\n// \t});\r\n// });\r\n//\r\n// if (typeof require === \"function\") {\r\n// \tvar domain;\r\n// \ttry {\r\n// \t\tdomain = require(\"domain\");\r\n// \t} catch (e) { }\r\n//\r\n// \tif (domain) {\r\n// \t\tvar EventEmitter = require(\"events\").EventEmitter;\r\n//\r\n// \t\tdescribe(\"node domain support\", function () {\r\n// \t\t\tvar d;\r\n//\r\n// \t\t\tbeforeEach(function () {\r\n// \t\t\t\td = domain.create();\r\n// \t\t\t});\r\n// \t\t\tafterEach(function() {\r\n// \t\t\t\td.dispose();\r\n// \t\t\t});\r\n//\r\n// \t\t\tit(\"should work for non-promise async inside a promise handler\",\r\n// \t\t\t\tfunction (done) {\r\n// \t\t\t\t\tvar error = new Error(\"should be caught by the domain\");\r\n//\r\n// \t\t\t\t\td.run(function () {\r\n// \t\t\t\t\t\tQ().then(function () {\r\n// \t\t\t\t\t\t\tsetTimeout(function () {\r\n// \t\t\t\t\t\t\t\tthrow error;\r\n// \t\t\t\t\t\t\t}, 10);\r\n// \t\t\t\t\t\t});\r\n// \t\t\t\t\t});\r\n//\r\n// \t\t\t\t\tvar errorTimeout = setTimeout(function () {\r\n// \t\t\t\t\t\tdone(new Error(\"Wasn't caught\"));\r\n// \t\t\t\t\t}, 100);\r\n//\r\n// \t\t\t\t\td.on(\"error\", function (theError) {\r\n// \t\t\t\t\t\texpect(theError).toBe(error);\r\n// \t\t\t\t\t\tclearTimeout(errorTimeout);\r\n// \t\t\t\t\t\tdone();\r\n// \t\t\t\t\t});\r\n// \t\t\t\t});\r\n//\r\n// \t\t\tit(\"should transfer errors from `done` into the domain\",\r\n// \t\t\t\tfunction (done) {\r\n// \t\t\t\t\tvar error = new Error(\"should be caught by the domain\");\r\n//\r\n// \t\t\t\t\td.run(function () {\r\n// \t\t\t\t\t\tQ.reject(error).done();\r\n// \t\t\t\t\t});\r\n//\r\n// \t\t\t\t\tvar errorTimeout = setTimeout(function () {\r\n// \t\t\t\t\t\tdone(new Error(\"Wasn't caught\"));\r\n// \t\t\t\t\t}, 100);\r\n//\r\n// \t\t\t\t\td.on(\"error\", function (theError) {\r\n// \t\t\t\t\t\texpect(theError).toBe(error);\r\n// \t\t\t\t\t\tclearTimeout(errorTimeout);\r\n// \t\t\t\t\t\tdone();\r\n// \t\t\t\t\t});\r\n// \t\t\t\t});\r\n//\r\n// \t\t\tit(\"should take care of re-used event emitters\", function (done) {\r\n// \t\t\t\t// See discussion in https://github.com/kriskowal/q/issues/120\r\n// \t\t\t\tvar error = new Error(\"should be caught by the domain\");\r\n//\r\n// \t\t\t\tvar e = new EventEmitter();\r\n//\r\n// \t\t\t\td.run(function () {\r\n// \t\t\t\t\tcallAsync().done();\r\n// \t\t\t\t});\r\n// \t\t\t\tsetTimeout(function () {\r\n// \t\t\t\t\te.emit(\"beep\");\r\n// \t\t\t\t}, 100);\r\n//\r\n// \t\t\t\tvar errorTimeout = setTimeout(function () {\r\n// \t\t\t\t\tdone(new Error(\"Wasn't caught\"));\r\n// \t\t\t\t}, 500);\r\n//\r\n// \t\t\t\td.on(\"error\", function (theError) {\r\n// \t\t\t\t\texpect(theError).toBe(error);\r\n// \t\t\t\t\tclearTimeout(errorTimeout);\r\n// \t\t\t\t\tdone();\r\n// \t\t\t\t});\r\n//\r\n// \t\t\t\tfunction callAsync() {\r\n// \t\t\t\t\tvar def = Q.defer();\r\n// \t\t\t\t\te.once(\"beep\", function () {\r\n// \t\t\t\t\t\tdef.reject(error);\r\n// \t\t\t\t\t});\r\n// \t\t\t\t\treturn def.promise;\r\n// \t\t\t\t}\r\n// \t\t\t});\r\n// \t\t});\r\n// \t}\r\n// }\r\n//\r\n// describe(\"decorator functions\", function () {\r\n// \tdescribe(\"promised\", function () {\r\n// \t\tvar exception = new Error(\"That is not the meaning of life.\");\r\n// \t\tit(\"resolves promised arguments\", function () {\r\n// \t\t\tvar sum = Q.promised(function add(a, b) {\r\n// \t\t\t\treturn a + b;\r\n// \t\t\t});\r\n// \t\t\treturn sum(Q(4), Q(5)).then(function (sum) {\r\n// \t\t\t\texpect(sum).toEqual(9);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t\tit(\"resolves promised `this`\", function () {\r\n// \t\t\tvar inc = Q.promised(function inc(a) {\r\n// \t\t\t\treturn this + a;\r\n// \t\t\t});\r\n// \t\t\treturn inc.call(Q(4), Q(5)).then(function (sum) {\r\n// \t\t\t\texpect(sum).toEqual(9);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t\tit(\"is rejected if an argument is rejected\", function () {\r\n// \t\t\tvar sum = Q.promised(function add(a, b) {\r\n// \t\t\t\treturn a + b;\r\n// \t\t\t});\r\n// \t\t\treturn sum(Q.reject(exception), Q(4)).then(function () {\r\n// \t\t\t\texpect(4).toEqual(42);\r\n// \t\t\t}, function (_exception) {\r\n// \t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t\tit(\"is rejected if `this` is rejected\", function () {\r\n// \t\t\tvar inc = Q.promised(function inc(a) {\r\n// \t\t\t\treturn this + a;\r\n// \t\t\t});\r\n// \t\t\treturn inc.call(Q.reject(exception), Q(4)).then(function () {\r\n// \t\t\t\texpect(4).toEqual(42);\r\n// \t\t\t}, function (_exception) {\r\n// \t\t\t\texpect(_exception).toBe(exception);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n// });\r\n//\r\n// describe(\"stack trace formatting\", function () {\r\n// \tit(\"doesn't mangle a stack trace that gets handled twice\", function () {\r\n// \t\tvar d1 = Q.defer();\r\n// \t\tvar d2 = Q.defer();\r\n// \t\tvar captured = [];\r\n// \t\td1.promise.done();\r\n// \t\td2.promise.done();\r\n//\r\n// \t\tQ.onerror = function (err) {\r\n// \t\t\tcaptured.push(err.stack);\r\n// \t\t};\r\n//\r\n// \t\tvar error = new Error(\"boom!\");\r\n// \t\td1.reject(error);\r\n// \t\td2.reject(error);\r\n//\r\n// \t\treturn Q.all([d1.promise.fail(function () {}), d2.promise.fail(function () { })])\r\n// \t\t\t.then(function () {\r\n// \t\t\t\texpect(captured[0]).toEqual(captured[1]);\r\n// \t\t\t});\r\n// \t});\r\n// });\r\n//\r\n// describe(\"possible regressions\", function () {\r\n//\r\n// \tdescribe(\"gh-9\", function () {\r\n// \t\tit(\"treats falsy values as resolved values without error\", function () {\r\n// \t\t\texpect(Q.isPending(null)).toEqual(false);\r\n// \t\t\texpect(Q.isPending(void 0)).toEqual(false);\r\n// \t\t\texpect(Q.isPending(false)).toEqual(false);\r\n// \t\t\texpect(Q.isPending()).toEqual(false);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"gh-22\", function () {\r\n// \t\tit(\"ensures that the array prototype is intact\", function () {\r\n// \t\t\tvar keys = [];\r\n// \t\t\tfor (var key in []) {\r\n// \t\t\t\tkeys.push(key);\r\n// \t\t\t}\r\n// \t\t\texpect(keys.length).toBe(0);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"gh-73\", function () {\r\n// \t\tit(\"does not choke on non-error rejection reasons\", function () {\r\n// \t\t\tQ.reject(REASON).done();\r\n//\r\n// \t\t\tvar deferred = Q.defer();\r\n//\r\n// \t\t\tQ.onerror = function (error) {\r\n// \t\t\t\texpect(error).toBe(REASON);\r\n// \t\t\t\tdeferred.resolve();\r\n// \t\t\t};\r\n// \t\t\tQ.delay(10).then(deferred.reject);\r\n//\r\n// \t\t\treturn deferred.promise;\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"gh-90\", function () {\r\n// \t\tit(\"does not choke on rejection reasons with an undefined `stack`\", function () {\r\n// \t\t\tvar error = new RangeError(REASON);\r\n// \t\t\terror.stack = undefined;\r\n// \t\t\tQ.reject(error).done();\r\n//\r\n// \t\t\tvar deferred = Q.defer();\r\n//\r\n// \t\t\tQ.onerror = function (theError) {\r\n// \t\t\t\texpect(theError).toBe(error);\r\n// \t\t\t\tdeferred.resolve();\r\n// \t\t\t};\r\n// \t\t\tQ.delay(10).then(deferred.reject);\r\n//\r\n// \t\t\treturn deferred.promise;\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tdescribe(\"gh-75\", function () {\r\n// \t\tit(\"does not double-resolve misbehaved promises\", function () {\r\n// \t\t\tvar badPromise = Q.makePromise({\r\n// \t\t\t\tpost: function () { return \"hello\"; }\r\n// \t\t\t});\r\n//\r\n// \t\t\tvar resolutions = 0;\r\n// \t\t\tfunction onResolution() {\r\n// \t\t\t\t++resolutions;\r\n// \t\t\t}\r\n//\r\n// \t\t\treturn Q.when(badPromise, onResolution, onResolution).then(function () {\r\n// \t\t\t\texpect(resolutions).toBe(1);\r\n// \t\t\t});\r\n// \t\t});\r\n// \t});\r\n//\r\n// });\r\n//\r\n// describe(\"unhandled rejection reporting\", function () {\r\n// \tbeforeEach(function () {\r\n// \t\tQ.resetUnhandledRejections();\r\n// \t});\r\n//\r\n// \tit(\"doesn't report a resolve, then reject (gh-252)\", function () {\r\n// \t\tvar deferred = Q.defer();\r\n// \t\tdeferred.resolve();\r\n// \t\tdeferred.reject();\r\n//\r\n// \t\texpect(Q.getUnhandledReasons().length).toEqual(0);\r\n// \t});\r\n//\r\n// \tit(\"doesn't report when you chain off a rejection\", function () {\r\n// \t\treturn Q.reject(\"this will be handled\").get(\"property\").fail(function () {\r\n// \t\t\t// now it should be handled.\r\n// \t\t}).fin(function() {\r\n// \t\t\texpect(Q.getUnhandledReasons().length).toEqual(0);\r\n// \t\t});\r\n// \t});\r\n//\r\n// \tit(\"reports the most basic case\", function () {\r\n// \t\tQ.reject(\"a reason\");\r\n//\r\n// \t\texpect(Q.getUnhandledReasons()).toEqual([\"(no stack) a reason\"]);\r\n// \t});\r\n//\r\n// \tit(\"reports a stack trace\", function () {\r\n// \t\tvar error = new Error(\"a reason\");\r\n// \t\tQ.reject(error);\r\n//\r\n// \t\texpect(Q.getUnhandledReasons()).toEqual([error.stack]);\r\n// \t});\r\n//\r\n// \tit(\"doesn't let you mutate the internal array\", function () {\r\n// \t\tQ.reject(\"a reason\");\r\n//\r\n// \t\tQ.getUnhandledReasons().length = 0;\r\n// \t\texpect(Q.getUnhandledReasons()).toEqual([\"(no stack) a reason\"]);\r\n// \t});\r\n//\r\n// \tit(\"resets after calling `Q.resetUnhandledRejections`\", function () {\r\n// \t\tQ.reject(\"a reason\");\r\n//\r\n// \t\tQ.resetUnhandledRejections();\r\n// \t\texpect(Q.getUnhandledReasons()).toEqual([]);\r\n// \t});\r\n//\r\n// \tit(\"stops tracking after calling `Q.stopUnhandledRejectionTracking`\", function () {\r\n// \t\tQ.reject(\"a reason\");\r\n//\r\n// \t\tQ.stopUnhandledRejectionTracking();\r\n//\r\n// \t\tQ.reject(\"another reason\");\r\n//\r\n// \t\texpect(Q.getUnhandledReasons()).toEqual([]);\r\n// \t});\r\n// });\r\n// /*!\r\n//  * @author electricessence / https://github.com/electricessence/\r\n//  * Licensing: MIT\r\n//  */\r\n\r\n"]}